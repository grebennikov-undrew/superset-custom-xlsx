/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["plugins_legacy-plugin-chart-parallel-coordinates_src_ReactParallelCoordinates_jsx"],{

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js":
/*!*************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");\n/* harmony import */ var _vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/parcoords/divgrid */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n/* eslint-disable react/sort-prop-types */\n\n\n\n\n\n\n\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)),\n  width: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  colorMetric: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  includeSeries: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  linearColorScheme: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  metrics: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  series: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  showDatatable: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool) };\n\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable } =\n  props;\n\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach((v) => {\n    ttypes[v] = 'number';\n  });\n\n  const colorScale = colorMetric ?\n  (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().\n  get(linearColorScheme).\n  createLinearScale(d3__WEBPACK_IMPORTED_MODULE_0___default().extent(data, (d) => d[colorMetric])) :\n  () => 'grey';\n  const color = (d) => colorScale(d[colorMetric]);\n  const container = d3__WEBPACK_IMPORTED_MODULE_0___default().select(element).\n  classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n\n  const div = container.\n  append('div').\n  style('height', `${effHeight}px`).\n  classed('parcoords', true);\n\n  const chart = (0,_vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()(div.node()).\n  width(width).\n  color(color).\n  alpha(0.5).\n  composite('darken').\n  height(effHeight).\n  data(data).\n  dimensions(cols).\n  types(ttypes).\n  render().\n  createAxes().\n  shadows().\n  reorderable().\n  brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = (0,_vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    container.\n    append('div').\n    style('height', `${effHeight}px`).\n    datum(data).\n    call(grid).\n    classed('parcoords grid', true).\n    selectAll('.row').\n    on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n      mouseout: chart.unhighlight });\n\n    // update data table on brush event\n    chart.on('brush', (d) => {\n      d3__WEBPACK_IMPORTED_MODULE_0___default().select('.grid').\n      datum(d).\n      call(grid).\n      selectAll('.row').\n      on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n        mouseout: chart.unhighlight });\n\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;const _default =\n\nParallelCoordinates;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");reactHotLoader.register(ParallelCoordinates, \"ParallelCoordinates\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvUGFyYWxsZWxDb29yZGluYXRlcy5qcz9mYTA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3NvcnQtcHJvcC10eXBlcyAqL1xyXG5pbXBvcnQgZDMgZnJvbSAnZDMnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgeyBnZXRTZXF1ZW50aWFsU2NoZW1lUmVnaXN0cnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XHJcblxyXG5pbXBvcnQgcGFyY29vcmRzIGZyb20gJy4vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMnO1xyXG5pbXBvcnQgZGl2Z3JpZCBmcm9tICcuL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgLy8gU3RhbmRhcmQgdGFidWxhciBkYXRhIFt7IGZpZWxkTmFtZTE6IHZhbHVlMSwgZmllbGROYW1lMjogdmFsdWUyIH1dXHJcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXHJcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gIGNvbG9yTWV0cmljOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gIGluY2x1ZGVTZXJpZXM6IFByb3BUeXBlcy5ib29sLFxyXG4gIGxpbmVhckNvbG9yU2NoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gIG1ldHJpY3M6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxyXG4gIHNlcmllczogUHJvcFR5cGVzLnN0cmluZyxcclxuICBzaG93RGF0YXRhYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxufTtcclxuXHJcbmZ1bmN0aW9uIFBhcmFsbGVsQ29vcmRpbmF0ZXMoZWxlbWVudCwgcHJvcHMpIHtcclxuICBjb25zdCB7XHJcbiAgICBkYXRhLFxyXG4gICAgd2lkdGgsXHJcbiAgICBoZWlnaHQsXHJcbiAgICBjb2xvck1ldHJpYyxcclxuICAgIGluY2x1ZGVTZXJpZXMsXHJcbiAgICBsaW5lYXJDb2xvclNjaGVtZSxcclxuICAgIG1ldHJpY3MsXHJcbiAgICBzZXJpZXMsXHJcbiAgICBzaG93RGF0YXRhYmxlLFxyXG4gIH0gPSBwcm9wcztcclxuXHJcbiAgY29uc3QgY29scyA9IGluY2x1ZGVTZXJpZXMgPyBbc2VyaWVzXS5jb25jYXQobWV0cmljcykgOiBtZXRyaWNzO1xyXG5cclxuICBjb25zdCB0dHlwZXMgPSB7fTtcclxuICB0dHlwZXNbc2VyaWVzXSA9ICdzdHJpbmcnO1xyXG4gIG1ldHJpY3MuZm9yRWFjaCh2ID0+IHtcclxuICAgIHR0eXBlc1t2XSA9ICdudW1iZXInO1xyXG4gIH0pO1xyXG5cclxuICBjb25zdCBjb2xvclNjYWxlID0gY29sb3JNZXRyaWNcclxuICAgID8gZ2V0U2VxdWVudGlhbFNjaGVtZVJlZ2lzdHJ5KClcclxuICAgICAgICAuZ2V0KGxpbmVhckNvbG9yU2NoZW1lKVxyXG4gICAgICAgIC5jcmVhdGVMaW5lYXJTY2FsZShkMy5leHRlbnQoZGF0YSwgZCA9PiBkW2NvbG9yTWV0cmljXSkpXHJcbiAgICA6ICgpID0+ICdncmV5JztcclxuICBjb25zdCBjb2xvciA9IGQgPT4gY29sb3JTY2FsZShkW2NvbG9yTWV0cmljXSk7XHJcbiAgY29uc3QgY29udGFpbmVyID0gZDNcclxuICAgIC5zZWxlY3QoZWxlbWVudClcclxuICAgIC5jbGFzc2VkKCdzdXBlcnNldC1sZWdhY3ktY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMnLCB0cnVlKTtcclxuICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XHJcbiAgY29uc3QgZWZmSGVpZ2h0ID0gc2hvd0RhdGF0YWJsZSA/IGhlaWdodCAvIDIgOiBoZWlnaHQ7XHJcblxyXG4gIGNvbnN0IGRpdiA9IGNvbnRhaW5lclxyXG4gICAgLmFwcGVuZCgnZGl2JylcclxuICAgIC5zdHlsZSgnaGVpZ2h0JywgYCR7ZWZmSGVpZ2h0fXB4YClcclxuICAgIC5jbGFzc2VkKCdwYXJjb29yZHMnLCB0cnVlKTtcclxuXHJcbiAgY29uc3QgY2hhcnQgPSBwYXJjb29yZHMoKShkaXYubm9kZSgpKVxyXG4gICAgLndpZHRoKHdpZHRoKVxyXG4gICAgLmNvbG9yKGNvbG9yKVxyXG4gICAgLmFscGhhKDAuNSlcclxuICAgIC5jb21wb3NpdGUoJ2RhcmtlbicpXHJcbiAgICAuaGVpZ2h0KGVmZkhlaWdodClcclxuICAgIC5kYXRhKGRhdGEpXHJcbiAgICAuZGltZW5zaW9ucyhjb2xzKVxyXG4gICAgLnR5cGVzKHR0eXBlcylcclxuICAgIC5yZW5kZXIoKVxyXG4gICAgLmNyZWF0ZUF4ZXMoKVxyXG4gICAgLnNoYWRvd3MoKVxyXG4gICAgLnJlb3JkZXJhYmxlKClcclxuICAgIC5icnVzaE1vZGUoJzFELWF4ZXMnKTtcclxuXHJcbiAgaWYgKHNob3dEYXRhdGFibGUpIHtcclxuICAgIC8vIGNyZWF0ZSBkYXRhIHRhYmxlLCByb3cgaG92ZXIgaGlnaGxpZ2h0aW5nXHJcbiAgICBjb25zdCBncmlkID0gZGl2Z3JpZCgpO1xyXG4gICAgY29udGFpbmVyXHJcbiAgICAgIC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JywgYCR7ZWZmSGVpZ2h0fXB4YClcclxuICAgICAgLmRhdHVtKGRhdGEpXHJcbiAgICAgIC5jYWxsKGdyaWQpXHJcbiAgICAgIC5jbGFzc2VkKCdwYXJjb29yZHMgZ3JpZCcsIHRydWUpXHJcbiAgICAgIC5zZWxlY3RBbGwoJy5yb3cnKVxyXG4gICAgICAub24oe1xyXG4gICAgICAgIG1vdXNlb3ZlcihkKSB7XHJcbiAgICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdXNlb3V0OiBjaGFydC51bmhpZ2hsaWdodCxcclxuICAgICAgfSk7XHJcbiAgICAvLyB1cGRhdGUgZGF0YSB0YWJsZSBvbiBicnVzaCBldmVudFxyXG4gICAgY2hhcnQub24oJ2JydXNoJywgZCA9PiB7XHJcbiAgICAgIGQzLnNlbGVjdCgnLmdyaWQnKVxyXG4gICAgICAgIC5kYXR1bShkKVxyXG4gICAgICAgIC5jYWxsKGdyaWQpXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnLnJvdycpXHJcbiAgICAgICAgLm9uKHtcclxuICAgICAgICAgIG1vdXNlb3ZlcihkZCkge1xyXG4gICAgICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RkXSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbW91c2VvdXQ6IGNoYXJ0LnVuaGlnaGxpZ2h0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5QYXJhbGxlbENvb3JkaW5hdGVzLmRpc3BsYXlOYW1lID0gJ1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xyXG5QYXJhbGxlbENvb3JkaW5hdGVzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBhcmFsbGVsQ29vcmRpbmF0ZXM7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx":
/*!*******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx ***!
  \*******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/chart/components/reactify.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/utils.ts\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ParallelCoordinates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ParallelCoordinates */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\n\n\nconst ReactComponent = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_ParallelCoordinates__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n\nconst ParallelCoordianes = (_ref) => {let { className, ...otherProps } = _ref;return (\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { className: className },\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(ReactComponent, otherProps)));};\n\n\n\nParallelCoordianes.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string.isRequired) };const _default =\n\n\n(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(ParallelCoordianes)`\n  ${(_ref2) => {let { theme } = _ref2;return `\n    .superset-legacy-chart-parallel-coordinates {\n      div.grid {\n        overflow: auto;\n        div.row {\n          &:hover {\n            background-color: ${theme.colors.grayscale.light2};\n          }\n        }\n      }\n    }\n    .parcoords svg,\n    .parcoords canvas {\n      font-size: ${theme.typography.sizes.s}px;\n      position: absolute;\n    }\n    .parcoords > canvas {\n      pointer-events: none;\n    }\n\n    .parcoords text.label {\n      font: 100%;\n      font-size: ${theme.typography.sizes.s}px;\n      cursor: drag;\n    }\n    .parcoords rect.background {\n      fill: transparent;\n    }\n    .parcoords rect.background:hover {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.base, 0.2)};\n    }\n    .parcoords .resize rect {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.1)};\n    }\n    .parcoords rect.extent {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.light5, 0.25)};\n      stroke: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.6)};\n    }\n    .parcoords .axis line,\n    .parcoords .axis path {\n      fill: none;\n      stroke: ${theme.colors.grayscale.dark1};\n      shape-rendering: crispEdges;\n    }\n    .parcoords canvas {\n      opacity: 1;\n      -moz-transition: opacity 0.3s;\n      -webkit-transition: opacity 0.3s;\n      -o-transition: opacity 0.3s;\n    }\n    .parcoords canvas.faded {\n      opacity: ${theme.opacity.mediumLight};\n    }\n    .parcoords {\n      -webkit-touch-callout: none;\n      -webkit-user-select: none;\n      -khtml-user-select: none;\n      -moz-user-select: none;\n      -ms-user-select: none;\n      user-select: none;\n      background-color: ${theme.colors.grayscale.light5};\n    }\n\n    /* data table styles */\n    .parcoords .row,\n    .parcoords .header {\n      clear: left;\n      font-size: ${theme.typography.sizes.s}px;\n      line-height: 18px;\n      height: 18px;\n      margin: 0px;\n    }\n    .parcoords .row:nth-child(odd) {\n      background: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.05)};\n    }\n    .parcoords .header {\n      font-weight: ${theme.typography.weights.bold};\n    }\n    .parcoords .cell {\n      float: left;\n      overflow: hidden;\n      white-space: nowrap;\n      width: 100px;\n      height: 18px;\n    }\n    .parcoords .col-0 {\n      width: 180px;\n    }\n  `;}}\n`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ReactComponent, \"ReactComponent\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");reactHotLoader.register(ParallelCoordianes, \"ParallelCoordianes\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3g/MjY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBzdHlsZWQsIHJlYWN0aWZ5LCBhZGRBbHBoYSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xyXG5cclxuY29uc3QgUmVhY3RDb21wb25lbnQgPSByZWFjdGlmeShDb21wb25lbnQpO1xyXG5cclxuY29uc3QgUGFyYWxsZWxDb29yZGlhbmVzID0gKHsgY2xhc3NOYW1lLCAuLi5vdGhlclByb3BzIH0pID0+IChcclxuICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cclxuICAgIDxSZWFjdENvbXBvbmVudCB7Li4ub3RoZXJQcm9wc30gLz5cclxuICA8L2Rpdj5cclxuKTtcclxuXHJcblBhcmFsbGVsQ29vcmRpYW5lcy5wcm9wVHlwZXMgPSB7XHJcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQoUGFyYWxsZWxDb29yZGlhbmVzKWBcclxuICAkeyh7IHRoZW1lIH0pID0+IGBcclxuICAgIC5zdXBlcnNldC1sZWdhY3ktY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMge1xyXG4gICAgICBkaXYuZ3JpZCB7XHJcbiAgICAgICAgb3ZlcmZsb3c6IGF1dG87XHJcbiAgICAgICAgZGl2LnJvdyB7XHJcbiAgICAgICAgICAmOmhvdmVyIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0Mn07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAucGFyY29vcmRzIHN2ZyxcclxuICAgIC5wYXJjb29yZHMgY2FudmFzIHtcclxuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyA+IGNhbnZhcyB7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5wYXJjb29yZHMgdGV4dC5sYWJlbCB7XHJcbiAgICAgIGZvbnQ6IDEwMCU7XHJcbiAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XHJcbiAgICAgIGN1cnNvcjogZHJhZztcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kIHtcclxuICAgICAgZmlsbDogdHJhbnNwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICAucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZDpob3ZlciB7XHJcbiAgICAgIGZpbGw6ICR7YWRkQWxwaGEodGhlbWUuY29sb3JzLmdyYXlzY2FsZS5iYXNlLCAwLjIpfTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLnJlc2l6ZSByZWN0IHtcclxuICAgICAgZmlsbDogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyLCAwLjEpfTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgcmVjdC5leHRlbnQge1xyXG4gICAgICBmaWxsOiAke2FkZEFscGhhKHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1LCAwLjI1KX07XHJcbiAgICAgIHN0cm9rZTogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyLCAwLjYpfTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLmF4aXMgbGluZSxcclxuICAgIC5wYXJjb29yZHMgLmF4aXMgcGF0aCB7XHJcbiAgICAgIGZpbGw6IG5vbmU7XHJcbiAgICAgIHN0cm9rZTogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsxfTtcclxuICAgICAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzO1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyBjYW52YXMge1xyXG4gICAgICBvcGFjaXR5OiAxO1xyXG4gICAgICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcclxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XHJcbiAgICAgIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgY2FudmFzLmZhZGVkIHtcclxuICAgICAgb3BhY2l0eTogJHt0aGVtZS5vcGFjaXR5Lm1lZGl1bUxpZ2h0fTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMge1xyXG4gICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XHJcbiAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0NX07XHJcbiAgICB9XHJcblxyXG4gICAgLyogZGF0YSB0YWJsZSBzdHlsZXMgKi9cclxuICAgIC5wYXJjb29yZHMgLnJvdyxcclxuICAgIC5wYXJjb29yZHMgLmhlYWRlciB7XHJcbiAgICAgIGNsZWFyOiBsZWZ0O1xyXG4gICAgICBmb250LXNpemU6ICR7dGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xyXG4gICAgICBsaW5lLWhlaWdodDogMThweDtcclxuICAgICAgaGVpZ2h0OiAxOHB4O1xyXG4gICAgICBtYXJnaW46IDBweDtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLnJvdzpudGgtY2hpbGQob2RkKSB7XHJcbiAgICAgIGJhY2tncm91bmQ6ICR7YWRkQWxwaGEodGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMiwgMC4wNSl9O1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyAuaGVhZGVyIHtcclxuICAgICAgZm9udC13ZWlnaHQ6ICR7dGhlbWUudHlwb2dyYXBoeS53ZWlnaHRzLmJvbGR9O1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyAuY2VsbCB7XHJcbiAgICAgIGZsb2F0OiBsZWZ0O1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gICAgICB3aWR0aDogMTAwcHg7XHJcbiAgICAgIGhlaWdodDogMThweDtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLmNvbC0wIHtcclxuICAgICAgd2lkdGg6IDE4MHB4O1xyXG4gICAgfVxyXG4gIGB9XHJcbmA7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js":
/*!***********************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js ***!
  \***********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.regexp.flags.js */ \"./node_modules/core-js/modules/es.regexp.flags.js\");\n/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_0__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\nfunction (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: [] };\n\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.\n    append('svg').\n    attr('width', __.width).\n    attr('height', __.height).\n    append('svg:g').\n    attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n  this,\n  [\n  'render',\n  'resize',\n  'highlight',\n  'brush',\n  'brushend',\n  'axesreorder'].\n  concat(d3.keys(__))),\n\n  w = function () {\n    return __.width - __.margin.right - __.margin.left;\n  },\n  h = function () {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n  flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false },\n\n  xscale = d3.scale.ordinal(),\n  yscale = {},\n  dragging = {},\n  line = d3.svg.line(),\n  axis = d3.svg.axis().orient('left').ticks(5),\n  g, // groups for axes, brushes\n  ctx = {},\n  canvas = {},\n  clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch.\n  apply(this, d3.keys(__)).\n  on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).\n  on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).\n  on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).\n  on('width', function (d) {\n    pc.resize();\n  }).\n  on('height', function (d) {\n    pc.resize();\n  }).\n  on('margin', function (d) {\n    pc.resize();\n  }).\n  on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).\n  on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).\n  on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).\n  on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n      h() +\n      1 -\n      __.nullValueSeparatorPadding.bottom -\n      __.nullValueSeparatorPadding.top,\n      1];\n\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n      h() + 1,\n      1 +\n      __.nullValueSeparatorPadding.bottom +\n      __.nullValueSeparatorPadding.top];\n\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n        domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      } };\n\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection.\n    selectAll('canvas').\n    style('margin-top', __.margin.top + 'px').\n    style('margin-left', __.margin.left + 'px').\n    attr('width', w() + 2).\n    attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n      scales.\n      map(function (p, i) {\n        return yscale[p].domain();\n      }).\n      reduce(function (a, b) {\n        return a.concat(b);\n      }));\n\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n        d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString.\n    call(v).\n    match(/\\s([a-zA-Z]+)/)[1].\n    toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.\n  renderQueue(path_foreground).\n  rate(50).\n  clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.\n  renderQueue(path_brushed).\n  rate(50).\n  clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i]);\n          var rightCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n    $V([\n    centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n    centroids[0].e(2)]));\n\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n    $V([\n    centroids[cols - 1].e(1) +\n    a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n    centroids[cols - 1].e(2)]));\n\n\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n      cps[i].e(1),\n      cps[i].e(2),\n      cps[i + 1].e(1),\n      cps[i + 1].e(2),\n      cps[i + 2].e(1),\n      cps[i + 2].e(2));\n\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n    __.bundleDimension !== null && __.bundlingStrength > 0 ||\n    __.smoothness > 0)\n    {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n      __.bundleDimension !== null && __.bundlingStrength > 0 ||\n      __.smoothness > 0)\n      {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n      \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      } else {\n        ctx.lineTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n  pc,\n  axis,\n  'ticks',\n  'orient',\n  'tickValues',\n  'tickSubdivide',\n  'tickSize',\n  'tickPadding',\n  'tickFormat');\n\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement).\n    transition().\n    duration(1100).\n    call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg.\n    selectAll('text.label').\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg.\n    selectAll('.dimension').\n    data(__.dimensions, function (d) {\n      return d;\n    }).\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n\n    // Add an axis and title.\n    g.append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', 1 + __.nullValueSeparatorPadding.top).\n      attr('x2', w()).\n      attr('y2', 1 + __.nullValueSeparatorPadding.top).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('x2', w()).\n      attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data.\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 0).\n    append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.\n    select('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.\n    select('.label').\n    transition().\n    duration(1100).\n    text(dimensionLabels).\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition().\n    duration(1100).\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 1);\n\n    pc.svg.\n    selectAll('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n    d3.behavior.\n    drag().\n    on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).\n    on('drag', function (d) {\n      dragging[d] = Math.min(\n      w(),\n      Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).\n    on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n      j = __.dimensions.indexOf(d),\n      elem = this,\n      parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions);\n        // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).\n      transition().\n      attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition().\n      duration(1500).\n      attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        } } },\n\n\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    } };\n\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]);\n\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n    strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n      id = strum.dims.i,\n      points = [strum.p1, strum.p2],\n      line = svg.selectAll('line#strum-' + id).data([strum]),\n      circles = svg.selectAll('circle#strum-' + id).data(points),\n      drag = d3.behavior.drag();\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(\n        Math.max(strum.minX + 1, ev.x),\n        strum.maxX);\n\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h() };\n\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n        Math.max(strum.minX + 1, ev.x - __.margin.left),\n        strum.maxX);\n\n        strum.p2[1] = Math.min(\n        Math.max(strum.minY, ev.y - __.margin.top),\n        strum.maxY);\n\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n      p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n      m1 = 1 - width / p1[0],\n      b1 = p1[1] * (1 - m1),\n      m2 = 1 - width / p2[0],\n      b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n        y = p[1],\n        y1 = m1 * x + b1,\n        y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n      brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n        test = containmentTest(strum, strums.width(id)),\n        d1 = strum.dims.left,\n        d2 = strum.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n      svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n        strum &&\n        strum.p1[0] === strum.p2[0] &&\n        strum.p1[1] === strum.p2[1])\n        {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'strums').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag.\n      on('dragstart', onDragStart(strums)).\n      on('drag', onDrag(strums)).\n      on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#strums').\n      attr('id', 'strum-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      } };\n\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).\n      extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).\n      resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n    strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n      id = arc.dims.i,\n      points = [arc.p2, arc.p3],\n      line = svg.selectAll('line#arc-' + id).data([\n      { p1: arc.p1, p2: arc.p2 },\n      { p1: arc.p1, p2: arc.p3 }]),\n\n      circles = svg.selectAll('circle#arc-' + id).data(points),\n      drag = d3.behavior.drag(),\n      path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path.\n      enter().\n      append('path').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc').\n      style('fill', 'orange').\n      style('opacity', 0.5);\n\n      path.\n      attr('d', arc.arc).\n      attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event,\n        angle = 0;\n\n        i = i + 2;\n\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (\n        arc.startAngle < Math.PI &&\n        arc.endAngle < Math.PI &&\n        angle < Math.PI ||\n        arc.startAngle >= Math.PI &&\n        arc.endAngle >= Math.PI &&\n        angle >= Math.PI)\n        {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0) };\n\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n        Math.max(arc.minX + 1, ev.x - __.margin.left),\n        arc.maxX);\n\n        arc.p2[1] = Math.min(\n        Math.max(arc.minY, ev.y - __.margin.top),\n        arc.maxY);\n\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\r\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\r\n     * However, one can only select lines from 0 to PI, so we compute the\r\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\r\n     * are 12 and 6 o'clock respectively.\r\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n      brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n        test = containmentTest(arc),\n        d1 = arc.dims.left,\n        d2 = arc.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        a = arcs.width(id),\n        b = y1(d[d1]) - y2(d[d2]),\n        c = hypothenuse(a, b),\n        angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n      svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.\n          outerRadius(arcs.length(arcs.active)).\n          startAngle(angle).\n          endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n        b = p1[1] - p2[1],\n        c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n        b = arc.p1[1] - arc.p2[1],\n        c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'arcs').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag.\n      on('dragstart', onDragStart(arcs)).\n      on('drag', onDrag(arcs)).\n      on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#arcs').\n      attr('id', 'arc-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      } };\n\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection.\n    select('svg').\n    attr('width', __.width).\n    attr('height', __.height);\n    pc.svg.attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin });\n\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n      ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n      (a.x - b.x) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n      ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n      (a.y - b.y) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)) };\n\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows');\n\n  };\n\n  return pc;\n}; /* [LICENSE TBD] */ /* eslint-disable *//* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n  _rate = 10, // number of calls per frame\n  _clear = function () {}, // clearing function\n  _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzP2I2NGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogW0xJQ0VOU0UgVEJEXSAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgdmFyIF9fID0ge1xyXG4gICAgZGF0YTogW10sXHJcbiAgICBoaWdobGlnaHRlZDogW10sXHJcbiAgICBkaW1lbnNpb25zOiBbXSxcclxuICAgIGRpbWVuc2lvblRpdGxlczoge30sXHJcbiAgICBkaW1lbnNpb25UaXRsZVJvdGF0aW9uOiAwLFxyXG4gICAgdHlwZXM6IHt9LFxyXG4gICAgYnJ1c2hlZDogZmFsc2UsXHJcbiAgICBicnVzaGVkQ29sb3I6IG51bGwsXHJcbiAgICBhbHBoYU9uQnJ1c2hlZDogMC4wLFxyXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxyXG4gICAgcmF0ZTogMjAsXHJcbiAgICB3aWR0aDogNjAwLFxyXG4gICAgaGVpZ2h0OiAzMDAsXHJcbiAgICBtYXJnaW46IHsgdG9wOiAyNCwgcmlnaHQ6IDAsIGJvdHRvbTogMTIsIGxlZnQ6IDAgfSxcclxuICAgIG51bGxWYWx1ZVNlcGFyYXRvcjogJ3VuZGVmaW5lZCcsIC8vIHNldCB0byBcInRvcFwiIG9yIFwiYm90dG9tXCJcclxuICAgIG51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmc6IHsgdG9wOiA4LCByaWdodDogMCwgYm90dG9tOiA4LCBsZWZ0OiAwIH0sXHJcbiAgICBjb2xvcjogJyMwNjknLFxyXG4gICAgY29tcG9zaXRlOiAnc291cmNlLW92ZXInLFxyXG4gICAgYWxwaGE6IDAuNyxcclxuICAgIGJ1bmRsaW5nU3RyZW5ndGg6IDAuNSxcclxuICAgIGJ1bmRsZURpbWVuc2lvbjogbnVsbCxcclxuICAgIHNtb290aG5lc3M6IDAuMCxcclxuICAgIHNob3dDb250cm9sUG9pbnRzOiBmYWxzZSxcclxuICAgIGhpZGVBeGlzOiBbXSxcclxuICB9O1xyXG5cclxuICBleHRlbmQoX18sIGNvbmZpZyk7XHJcblxyXG4gIHZhciBwYyA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcclxuICAgIHNlbGVjdGlvbiA9IHBjLnNlbGVjdGlvbiA9IGQzLnNlbGVjdChzZWxlY3Rpb24pO1xyXG5cclxuICAgIF9fLndpZHRoID0gc2VsZWN0aW9uWzBdWzBdLmNsaWVudFdpZHRoO1xyXG4gICAgX18uaGVpZ2h0ID0gc2VsZWN0aW9uWzBdWzBdLmNsaWVudEhlaWdodDtcclxuXHJcbiAgICAvLyBjYW52YXMgZGF0YSBsYXllcnNcclxuICAgIFsnbWFya3MnLCAnZm9yZWdyb3VuZCcsICdicnVzaGVkJywgJ2hpZ2hsaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICAgIGNhbnZhc1tsYXllcl0gPSBzZWxlY3Rpb24uYXBwZW5kKCdjYW52YXMnKS5hdHRyKCdjbGFzcycsIGxheWVyKVswXVswXTtcclxuICAgICAgY3R4W2xheWVyXSA9IGNhbnZhc1tsYXllcl0uZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHN2ZyB0aWNrIGFuZCBicnVzaCBsYXllcnNcclxuICAgIHBjLnN2ZyA9IHNlbGVjdGlvblxyXG4gICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAuYXR0cignd2lkdGgnLCBfXy53aWR0aClcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIF9fLmhlaWdodClcclxuICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxyXG4gICAgICAuYXR0cihcclxuICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScsXHJcbiAgICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHBjO1xyXG4gIH07XHJcbiAgdmFyIGV2ZW50cyA9IGQzLmRpc3BhdGNoLmFwcGx5KFxyXG4gICAgICB0aGlzLFxyXG4gICAgICBbXHJcbiAgICAgICAgJ3JlbmRlcicsXHJcbiAgICAgICAgJ3Jlc2l6ZScsXHJcbiAgICAgICAgJ2hpZ2hsaWdodCcsXHJcbiAgICAgICAgJ2JydXNoJyxcclxuICAgICAgICAnYnJ1c2hlbmQnLFxyXG4gICAgICAgICdheGVzcmVvcmRlcicsXHJcbiAgICAgIF0uY29uY2F0KGQzLmtleXMoX18pKSxcclxuICAgICksXHJcbiAgICB3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX18ud2lkdGggLSBfXy5tYXJnaW4ucmlnaHQgLSBfXy5tYXJnaW4ubGVmdDtcclxuICAgIH0sXHJcbiAgICBoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX18uaGVpZ2h0IC0gX18ubWFyZ2luLnRvcCAtIF9fLm1hcmdpbi5ib3R0b207XHJcbiAgICB9LFxyXG4gICAgZmxhZ3MgPSB7XHJcbiAgICAgIGJydXNoYWJsZTogZmFsc2UsXHJcbiAgICAgIHJlb3JkZXJhYmxlOiBmYWxzZSxcclxuICAgICAgYXhlczogZmFsc2UsXHJcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcclxuICAgICAgZGVidWc6IGZhbHNlLFxyXG4gICAgfSxcclxuICAgIHhzY2FsZSA9IGQzLnNjYWxlLm9yZGluYWwoKSxcclxuICAgIHlzY2FsZSA9IHt9LFxyXG4gICAgZHJhZ2dpbmcgPSB7fSxcclxuICAgIGxpbmUgPSBkMy5zdmcubGluZSgpLFxyXG4gICAgYXhpcyA9IGQzLnN2Zy5heGlzKCkub3JpZW50KCdsZWZ0JykudGlja3MoNSksXHJcbiAgICBnLCAvLyBncm91cHMgZm9yIGF4ZXMsIGJydXNoZXNcclxuICAgIGN0eCA9IHt9LFxyXG4gICAgY2FudmFzID0ge30sXHJcbiAgICBjbHVzdGVyQ2VudHJvaWRzID0gW107XHJcblxyXG4gIC8vIHNpZGUgZWZmZWN0cyBmb3Igc2V0dGVyc1xyXG4gIHZhciBzaWRlX2VmZmVjdHMgPSBkMy5kaXNwYXRjaFxyXG4gICAgLmFwcGx5KHRoaXMsIGQzLmtleXMoX18pKVxyXG4gICAgLm9uKCdjb21wb3NpdGUnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xyXG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xyXG4gICAgfSlcclxuICAgIC5vbignYWxwaGEnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XHJcbiAgICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gZC52YWx1ZTtcclxuICAgIH0pXHJcbiAgICAub24oJ2JydXNoZWRDb2xvcicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZC52YWx1ZTtcclxuICAgIH0pXHJcbiAgICAub24oJ3dpZHRoJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgcGMucmVzaXplKCk7XHJcbiAgICB9KVxyXG4gICAgLm9uKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBwYy5yZXNpemUoKTtcclxuICAgIH0pXHJcbiAgICAub24oJ21hcmdpbicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIHBjLnJlc2l6ZSgpO1xyXG4gICAgfSlcclxuICAgIC5vbigncmF0ZScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIGJydXNoZWRRdWV1ZS5yYXRlKGQudmFsdWUpO1xyXG4gICAgICBmb3JlZ3JvdW5kUXVldWUucmF0ZShkLnZhbHVlKTtcclxuICAgIH0pXHJcbiAgICAub24oJ2RpbWVuc2lvbnMnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xyXG4gICAgICBpZiAoZmxhZ3MuaW50ZXJhY3RpdmUpIHtcclxuICAgICAgICBwYy5yZW5kZXIoKS51cGRhdGVBeGVzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICAub24oJ2J1bmRsZURpbWVuc2lvbicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcclxuICAgICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcclxuICAgICAgaWYgKHR5cGVvZiBkLnZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmIChkLnZhbHVlIDwgX18uZGltZW5zaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IF9fLmRpbWVuc2lvbnNbZC52YWx1ZV07XHJcbiAgICAgICAgfSBlbHNlIGlmIChkLnZhbHVlIDwgX18uaGlkZUF4aXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5oaWRlQXhpc1tkLnZhbHVlXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX18uYnVuZGxlRGltZW5zaW9uID0gZC52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX18uY2x1c3RlckNlbnRyb2lkcyA9IGNvbXB1dGVfY2x1c3Rlcl9jZW50cm9pZHMoX18uYnVuZGxlRGltZW5zaW9uKTtcclxuICAgIH0pXHJcbiAgICAub24oJ2hpZGVBeGlzJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xyXG4gICAgICBwYy5kaW1lbnNpb25zKHdpdGhvdXQoX18uZGltZW5zaW9ucywgZC52YWx1ZSkpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIGV4cG9zZSB0aGUgc3RhdGUgb2YgdGhlIGNoYXJ0XHJcbiAgcGMuc3RhdGUgPSBfXztcclxuICBwYy5mbGFncyA9IGZsYWdzO1xyXG5cclxuICAvLyBjcmVhdGUgZ2V0dGVyL3NldHRlcnNcclxuICBnZXRzZXQocGMsIF9fLCBldmVudHMpO1xyXG5cclxuICAvLyBleHBvc2UgZXZlbnRzXHJcbiAgZDMucmViaW5kKHBjLCBldmVudHMsICdvbicpO1xyXG5cclxuICAvLyBnZXR0ZXIvc2V0dGVyIHdpdGggZXZlbnQgZmlyaW5nXHJcbiAgZnVuY3Rpb24gZ2V0c2V0KG9iaiwgc3RhdGUsIGV2ZW50cykge1xyXG4gICAgZDMua2V5cyhzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIG9ialtrZXldID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybiBzdGF0ZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2xkID0gc3RhdGVba2V5XTtcclxuICAgICAgICBzdGF0ZVtrZXldID0geDtcclxuICAgICAgICBzaWRlX2VmZmVjdHNba2V5XS5jYWxsKHBjLCB7IHZhbHVlOiB4LCBwcmV2aW91czogb2xkIH0pO1xyXG4gICAgICAgIGV2ZW50c1trZXldLmNhbGwocGMsIHsgdmFsdWU6IHgsIHByZXZpb3VzOiBvbGQgfSk7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gd2l0aG91dChhcnIsIGl0ZW0pIHtcclxuICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgIHJldHVybiBpdGVtLmluZGV4T2YoZWxlbSkgPT09IC0xO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKiBhZGp1c3RzIGFuIGF4aXMnIGRlZmF1bHQgcmFuZ2UgW2goKSsxLCAxXSBpZiBhIE51bGxWYWx1ZVNlcGFyYXRvciBpcyBzZXQgKi9cclxuICBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcclxuICAgIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ2JvdHRvbScpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICBoKCkgK1xyXG4gICAgICAgICAgMSAtXHJcbiAgICAgICAgICBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSAtXHJcbiAgICAgICAgICBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcCxcclxuICAgICAgICAxLFxyXG4gICAgICBdO1xyXG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICBoKCkgKyAxLFxyXG4gICAgICAgIDEgK1xyXG4gICAgICAgICAgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20gK1xyXG4gICAgICAgICAgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3AsXHJcbiAgICAgIF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2goKSArIDEsIDFdO1xyXG4gIH1cclxuXHJcbiAgcGMuYXV0b3NjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8geXNjYWxlXHJcbiAgICB2YXIgZGVmYXVsdFNjYWxlcyA9IHtcclxuICAgICAgZGF0ZTogZnVuY3Rpb24gKGspIHtcclxuICAgICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZFtrXSA/IGRba10uZ2V0VGltZSgpIDogbnVsbDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGlmIHNpbmdsZSB2YWx1ZVxyXG4gICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xyXG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGQzLnRpbWUuc2NhbGUoKS5kb21haW4oZXh0ZW50KS5yYW5nZShnZXRSYW5nZSgpKTtcclxuICAgICAgfSxcclxuICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiArZFtrXTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGlmIHNpbmdsZSB2YWx1ZVxyXG4gICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xyXG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihleHRlbnQpLnJhbmdlKGdldFJhbmdlKCkpO1xyXG4gICAgICB9LFxyXG4gICAgICBzdHJpbmc6IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgdmFyIGNvdW50cyA9IHt9LFxyXG4gICAgICAgICAgZG9tYWluID0gW107XHJcblxyXG4gICAgICAgIC8vIExldCdzIGdldCB0aGUgY291bnQgZm9yIGVhY2ggdmFsdWUgc28gdGhhdCB3ZSBjYW4gc29ydCB0aGUgZG9tYWluIGJhc2VkXHJcbiAgICAgICAgLy8gb24gdGhlIG51bWJlciBvZiBpdGVtcyBmb3IgZWFjaCB2YWx1ZS5cclxuICAgICAgICBfXy5kYXRhLm1hcChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgaWYgKHBba10gPT09IHVuZGVmaW5lZCAmJiBfXy5udWxsVmFsdWVTZXBhcmF0b3IgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gbnVsbCB2YWx1ZXMgd2lsbCBiZSBkcmF3biBiZXlvbmQgdGhlIGhvcml6b250YWwgbnVsbCB2YWx1ZSBzZXBhcmF0b3IhXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY291bnRzW3Bba11dID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY291bnRzW3Bba11dID0gMTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IGNvdW50c1twW2tdXSArIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRvbWFpbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvdW50cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgcmV0dXJuIGNvdW50c1thXSAtIGNvdW50c1tiXTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oZG9tYWluKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIHlzY2FsZVtrXSA9IGRlZmF1bHRTY2FsZXNbX18udHlwZXNba11dKGspO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX18uaGlkZUF4aXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xyXG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHhzY2FsZVxyXG4gICAgeHNjYWxlLnJhbmdlUG9pbnRzKFswLCB3KCldLCAxKTtcclxuXHJcbiAgICAvLyBjYW52YXMgc2l6ZXNcclxuICAgIHBjLnNlbGVjdGlvblxyXG4gICAgICAuc2VsZWN0QWxsKCdjYW52YXMnKVxyXG4gICAgICAuc3R5bGUoJ21hcmdpbi10b3AnLCBfXy5tYXJnaW4udG9wICsgJ3B4JylcclxuICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsIF9fLm1hcmdpbi5sZWZ0ICsgJ3B4JylcclxuICAgICAgLmF0dHIoJ3dpZHRoJywgdygpICsgMilcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgc3R5bGVzLCBuZWVkcyB0byBiZSBzZXQgd2hlbiBjYW52YXMgd2lkdGggY2hhbmdlc1xyXG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBfXy5jb2xvcjtcclxuICAgIGN0eC5mb3JlZ3JvdW5kLmxpbmVXaWR0aCA9IDEuNDtcclxuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IF9fLmNvbXBvc2l0ZTtcclxuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XHJcbiAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IF9fLmJydXNoZWRDb2xvcjtcclxuICAgIGN0eC5icnVzaGVkLmxpbmVXaWR0aCA9IDEuNDtcclxuICAgIGN0eC5icnVzaGVkLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IF9fLmNvbXBvc2l0ZTtcclxuICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XHJcbiAgICBjdHguaGlnaGxpZ2h0LmxpbmVXaWR0aCA9IDM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgcGMuc2NhbGUgPSBmdW5jdGlvbiAoZCwgZG9tYWluKSB7XHJcbiAgICB5c2NhbGVbZF0uZG9tYWluKGRvbWFpbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgcGMuZmxpcCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAvL3lzY2FsZVtkXS5kb21haW4oKS5yZXZlcnNlKCk7ICAgICAgICAgLy8gZG9lcyBub3Qgd29ya1xyXG4gICAgeXNjYWxlW2RdLmRvbWFpbih5c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpKTsgLy8gd29ya3NcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBwYy5jb21tb25TY2FsZSA9IGZ1bmN0aW9uIChnbG9iYWwsIHR5cGUpIHtcclxuICAgIHZhciB0ID0gdHlwZSB8fCAnbnVtYmVyJztcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBnbG9iYWwgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNjYWxlcyBvZiB0aGUgc2FtZSB0eXBlXHJcbiAgICB2YXIgc2NhbGVzID0gX18uZGltZW5zaW9ucy5jb25jYXQoX18uaGlkZUF4aXMpLmZpbHRlcihmdW5jdGlvbiAocCkge1xyXG4gICAgICByZXR1cm4gX18udHlwZXNbcF0gPT0gdDtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChnbG9iYWwpIHtcclxuICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChcclxuICAgICAgICBzY2FsZXNcclxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHlzY2FsZVtwXS5kb21haW4oKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB5c2NhbGVbZF0uZG9tYWluKGV4dGVudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcclxuICAgICAgICB5c2NhbGVba10uZG9tYWluKFxyXG4gICAgICAgICAgZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiArZFtrXTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSBjZW50cm9pZHNcclxuICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwpIHtcclxuICAgICAgcGMuYnVuZGxlRGltZW5zaW9uKF9fLmJ1bmRsZURpbWVuc2lvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuICBwYy5kZXRlY3REaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcGMudHlwZXMocGMuZGV0ZWN0RGltZW5zaW9uVHlwZXMoX18uZGF0YSkpO1xyXG4gICAgcGMuZGltZW5zaW9ucyhkMy5rZXlzKHBjLnR5cGVzKCkpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIGEgYmV0dGVyIFwidHlwZW9mXCIgZnJvbSB0aGlzIHBvc3Q6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzM5MDQyNi9iZXR0ZXItd2F5LXRvLWdldC10eXBlLW9mLWEtamF2YXNjcmlwdC12YXJpYWJsZVxyXG4gIHBjLnRvVHlwZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4ge30udG9TdHJpbmdcclxuICAgICAgLmNhbGwodilcclxuICAgICAgLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdXHJcbiAgICAgIC50b0xvd2VyQ2FzZSgpO1xyXG4gIH07XHJcblxyXG4gIC8vIHRyeSB0byBjb2VyY2UgdG8gbnVtYmVyIGJlZm9yZSByZXR1cm5pbmcgdHlwZVxyXG4gIHBjLnRvVHlwZUNvZXJjZU51bWJlcnMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgaWYgKHBhcnNlRmxvYXQodikgPT0gdiAmJiB2ICE9IG51bGwpIHtcclxuICAgICAgcmV0dXJuICdudW1iZXInO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBjLnRvVHlwZSh2KTtcclxuICB9O1xyXG5cclxuICAvLyBhdHRlbXB0IHRvIGRldGVybWluZSB0eXBlcyBvZiBlYWNoIGRpbWVuc2lvbiBiYXNlZCBvbiBmaXJzdCByb3cgb2YgZGF0YVxyXG4gIHBjLmRldGVjdERpbWVuc2lvblR5cGVzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHZhciB0eXBlcyA9IHt9O1xyXG4gICAgZDMua2V5cyhkYXRhWzBdKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgdHlwZXNbY29sXSA9IHBjLnRvVHlwZUNvZXJjZU51bWJlcnMoZGF0YVswXVtjb2xdKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHR5cGVzO1xyXG4gIH07XHJcbiAgcGMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gdHJ5IHRvIGF1dG9kZXRlY3QgZGltZW5zaW9ucyBhbmQgY3JlYXRlIHNjYWxlc1xyXG4gICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xyXG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcclxuXHJcbiAgICBwYy5yZW5kZXJbX18ubW9kZV0oKTtcclxuXHJcbiAgICBldmVudHMucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBwYy5yZW5kZXJCcnVzaGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xyXG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcclxuXHJcbiAgICBwYy5yZW5kZXJCcnVzaGVkW19fLm1vZGVdKCk7XHJcblxyXG4gICAgZXZlbnRzLnJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gaXNCcnVzaGVkKCkge1xyXG4gICAgaWYgKF9fLmJydXNoZWQgJiYgX18uYnJ1c2hlZC5sZW5ndGggIT09IF9fLmRhdGEubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB2YXIgb2JqZWN0ID0gYnJ1c2guY3VycmVudE1vZGUoKS5icnVzaFN0YXRlKCk7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xyXG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcGMucmVuZGVyLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBwYy5jbGVhcignZm9yZWdyb3VuZCcpO1xyXG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xyXG5cclxuICAgIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCgpO1xyXG5cclxuICAgIF9fLmRhdGEuZm9yRWFjaChwYXRoX2ZvcmVncm91bmQpO1xyXG4gIH07XHJcblxyXG4gIHZhciBmb3JlZ3JvdW5kUXVldWUgPSBkM1xyXG4gICAgLnJlbmRlclF1ZXVlKHBhdGhfZm9yZWdyb3VuZClcclxuICAgIC5yYXRlKDUwKVxyXG4gICAgLmNsZWFyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcclxuICAgICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgfSk7XHJcblxyXG4gIHBjLnJlbmRlci5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHBjLnJlbmRlckJydXNoZWQucXVldWUoKTtcclxuXHJcbiAgICBmb3JlZ3JvdW5kUXVldWUoX18uZGF0YSk7XHJcbiAgfTtcclxuXHJcbiAgcGMucmVuZGVyQnJ1c2hlZC5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcGMuY2xlYXIoJ2JydXNoZWQnKTtcclxuXHJcbiAgICBpZiAoaXNCcnVzaGVkKCkpIHtcclxuICAgICAgX18uYnJ1c2hlZC5mb3JFYWNoKHBhdGhfYnJ1c2hlZCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGJydXNoZWRRdWV1ZSA9IGQzXHJcbiAgICAucmVuZGVyUXVldWUocGF0aF9icnVzaGVkKVxyXG4gICAgLnJhdGUoNTApXHJcbiAgICAuY2xlYXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICBwYy5jbGVhcignYnJ1c2hlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gIHBjLnJlbmRlckJydXNoZWQucXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoaXNCcnVzaGVkKCkpIHtcclxuICAgICAgYnJ1c2hlZFF1ZXVlKF9fLmJydXNoZWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnJ1c2hlZFF1ZXVlKFtdKTsgLy8gVGhpcyBpcyBuZWVkZWQgdG8gY2xlYXIgdGhlIGN1cnJlbnRseSBicnVzaGVkIGl0ZW1zXHJcbiAgICB9XHJcbiAgfTtcclxuICBmdW5jdGlvbiBjb21wdXRlX2NsdXN0ZXJfY2VudHJvaWRzKGQpIHtcclxuICAgIHZhciBjbHVzdGVyQ2VudHJvaWRzID0gZDMubWFwKCk7XHJcbiAgICB2YXIgY2x1c3RlckNvdW50cyA9IGQzLm1hcCgpO1xyXG4gICAgLy8gZGV0ZXJtaW5lIGNsdXN0ZXJDb3VudHNcclxuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgIHZhciBzY2FsZWQgPSB5c2NhbGVbZF0ocm93W2RdKTtcclxuICAgICAgaWYgKCFjbHVzdGVyQ291bnRzLmhhcyhzY2FsZWQpKSB7XHJcbiAgICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCAwKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY291bnQgPSBjbHVzdGVyQ291bnRzLmdldChzY2FsZWQpO1xyXG4gICAgICBjbHVzdGVyQ291bnRzLnNldChzY2FsZWQsIGNvdW50ICsgMSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xyXG4gICAgICAgIHZhciBzY2FsZWQgPSB5c2NhbGVbZF0ocm93W2RdKTtcclxuICAgICAgICBpZiAoIWNsdXN0ZXJDZW50cm9pZHMuaGFzKHNjYWxlZCkpIHtcclxuICAgICAgICAgIHZhciBtYXAgPSBkMy5tYXAoKTtcclxuICAgICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuc2V0KHNjYWxlZCwgbWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLmhhcyhwKSkge1xyXG4gICAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5zZXQocCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuZ2V0KHApO1xyXG4gICAgICAgIHZhbHVlICs9IHlzY2FsZVtwXShyb3dbcF0pIC8gY2x1c3RlckNvdW50cy5nZXQoc2NhbGVkKTtcclxuICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCB2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNsdXN0ZXJDZW50cm9pZHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21wdXRlX2NlbnRyb2lkcyhyb3cpIHtcclxuICAgIHZhciBjZW50cm9pZHMgPSBbXTtcclxuXHJcbiAgICB2YXIgcCA9IF9fLmRpbWVuc2lvbnM7XHJcbiAgICB2YXIgY29scyA9IHAubGVuZ3RoO1xyXG4gICAgdmFyIGEgPSAwLjU7IC8vIGNlbnRlciBiZXR3ZWVuIGF4ZXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sczsgKytpKSB7XHJcbiAgICAgIC8vIGNlbnRyb2lkcyBvbiAncmVhbCcgYXhlc1xyXG4gICAgICB2YXIgeCA9IHBvc2l0aW9uKHBbaV0pO1xyXG4gICAgICB2YXIgeSA9IHlzY2FsZVtwW2ldXShyb3dbcFtpXV0pO1xyXG4gICAgICBjZW50cm9pZHMucHVzaCgkVihbeCwgeV0pKTtcclxuXHJcbiAgICAgIC8vIGNlbnRyb2lkcyBvbiAndmlydHVhbCcgYXhlc1xyXG4gICAgICBpZiAoaSA8IGNvbHMgLSAxKSB7XHJcbiAgICAgICAgdmFyIGN4ID0geCArIGEgKiAocG9zaXRpb24ocFtpICsgMV0pIC0geCk7XHJcbiAgICAgICAgdmFyIGN5ID0geSArIGEgKiAoeXNjYWxlW3BbaSArIDFdXShyb3dbcFtpICsgMV1dKSAtIHkpO1xyXG4gICAgICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwpIHtcclxuICAgICAgICAgIHZhciBsZWZ0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzXHJcbiAgICAgICAgICAgIC5nZXQoeXNjYWxlW19fLmJ1bmRsZURpbWVuc2lvbl0ocm93W19fLmJ1bmRsZURpbWVuc2lvbl0pKVxyXG4gICAgICAgICAgICAuZ2V0KHBbaV0pO1xyXG4gICAgICAgICAgdmFyIHJpZ2h0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzXHJcbiAgICAgICAgICAgIC5nZXQoeXNjYWxlW19fLmJ1bmRsZURpbWVuc2lvbl0ocm93W19fLmJ1bmRsZURpbWVuc2lvbl0pKVxyXG4gICAgICAgICAgICAuZ2V0KHBbaSArIDFdKTtcclxuICAgICAgICAgIHZhciBjZW50cm9pZCA9IDAuNSAqIChsZWZ0Q2VudHJvaWQgKyByaWdodENlbnRyb2lkKTtcclxuICAgICAgICAgIGN5ID0gY2VudHJvaWQgKyAoMSAtIF9fLmJ1bmRsaW5nU3RyZW5ndGgpICogKGN5IC0gY2VudHJvaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjZW50cm9pZHMucHVzaCgkVihbY3gsIGN5XSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNlbnRyb2lkcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXB1dGVfY29udHJvbF9wb2ludHMoY2VudHJvaWRzKSB7XHJcbiAgICB2YXIgY29scyA9IGNlbnRyb2lkcy5sZW5ndGg7XHJcbiAgICB2YXIgYSA9IF9fLnNtb290aG5lc3M7XHJcbiAgICB2YXIgY3BzID0gW107XHJcblxyXG4gICAgY3BzLnB1c2goY2VudHJvaWRzWzBdKTtcclxuICAgIGNwcy5wdXNoKFxyXG4gICAgICAkVihbXHJcbiAgICAgICAgY2VudHJvaWRzWzBdLmUoMSkgKyBhICogMiAqIChjZW50cm9pZHNbMV0uZSgxKSAtIGNlbnRyb2lkc1swXS5lKDEpKSxcclxuICAgICAgICBjZW50cm9pZHNbMF0uZSgyKSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gICAgZm9yICh2YXIgY29sID0gMTsgY29sIDwgY29scyAtIDE7ICsrY29sKSB7XHJcbiAgICAgIHZhciBtaWQgPSBjZW50cm9pZHNbY29sXTtcclxuICAgICAgdmFyIGxlZnQgPSBjZW50cm9pZHNbY29sIC0gMV07XHJcbiAgICAgIHZhciByaWdodCA9IGNlbnRyb2lkc1tjb2wgKyAxXTtcclxuXHJcbiAgICAgIHZhciBkaWZmID0gbGVmdC5zdWJ0cmFjdChyaWdodCk7XHJcbiAgICAgIGNwcy5wdXNoKG1pZC5hZGQoZGlmZi54KGEpKSk7XHJcbiAgICAgIGNwcy5wdXNoKG1pZCk7XHJcbiAgICAgIGNwcy5wdXNoKG1pZC5zdWJ0cmFjdChkaWZmLngoYSkpKTtcclxuICAgIH1cclxuICAgIGNwcy5wdXNoKFxyXG4gICAgICAkVihbXHJcbiAgICAgICAgY2VudHJvaWRzW2NvbHMgLSAxXS5lKDEpICtcclxuICAgICAgICAgIGEgKiAyICogKGNlbnRyb2lkc1tjb2xzIC0gMl0uZSgxKSAtIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSksXHJcbiAgICAgICAgY2VudHJvaWRzW2NvbHMgLSAxXS5lKDIpLFxyXG4gICAgICBdKSxcclxuICAgICk7XHJcbiAgICBjcHMucHVzaChjZW50cm9pZHNbY29scyAtIDFdKTtcclxuXHJcbiAgICByZXR1cm4gY3BzO1xyXG4gIH1cclxuXHJcbiAgcGMuc2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZsYWdzLnNoYWRvd3MgPSB0cnVlO1xyXG4gICAgcGMuYWxwaGFPbkJydXNoZWQoMC4xKTtcclxuICAgIHBjLnJlbmRlcigpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gZHJhdyBkb3RzIHdpdGggcmFkaXVzIHIgb24gdGhlIGF4aXMgbGluZSB3aGVyZSBkYXRhIGludGVyc2VjdHNcclxuICBwYy5heGlzRG90cyA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICB2YXIgciA9IHIgfHwgMC4xO1xyXG4gICAgdmFyIGN0eCA9IHBjLmN0eC5tYXJrcztcclxuICAgIHZhciBzdGFydEFuZ2xlID0gMDtcclxuICAgIHZhciBlbmRBbmdsZSA9IDIgKiBNYXRoLlBJO1xyXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gZDMubWluKFsxIC8gTWF0aC5wb3coX18uZGF0YS5sZW5ndGgsIDEgLyAyKSwgMV0pO1xyXG4gICAgX18uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmMocG9zaXRpb24ocCksIHlzY2FsZVtwXShkW3BdKSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gZHJhdyBzaW5nbGUgY3ViaWMgYmV6aWVyIGN1cnZlXHJcbiAgZnVuY3Rpb24gc2luZ2xlX2N1cnZlKGQsIGN0eCkge1xyXG4gICAgdmFyIGNlbnRyb2lkcyA9IGNvbXB1dGVfY2VudHJvaWRzKGQpO1xyXG4gICAgdmFyIGNwcyA9IGNvbXB1dGVfY29udHJvbF9wb2ludHMoY2VudHJvaWRzKTtcclxuXHJcbiAgICBjdHgubW92ZVRvKGNwc1swXS5lKDEpLCBjcHNbMF0uZSgyKSk7XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNwcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICBpZiAoX18uc2hvd0NvbnRyb2xQb2ludHMpIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGogKz0gMSkge1xyXG4gICAgICAgICAgY3R4LmZpbGxSZWN0KGNwc1tpICsgal0uZSgxKSwgY3BzW2kgKyBqXS5lKDIpLCAyLCAyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY3R4LmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgY3BzW2ldLmUoMSksXHJcbiAgICAgICAgY3BzW2ldLmUoMiksXHJcbiAgICAgICAgY3BzW2kgKyAxXS5lKDEpLFxyXG4gICAgICAgIGNwc1tpICsgMV0uZSgyKSxcclxuICAgICAgICBjcHNbaSArIDJdLmUoMSksXHJcbiAgICAgICAgY3BzW2kgKyAyXS5lKDIpLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZHJhdyBzaW5nbGUgcG9seWxpbmVcclxuICBmdW5jdGlvbiBjb2xvcl9wYXRoKGQsIGN0eCkge1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgaWYgKFxyXG4gICAgICAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsICYmIF9fLmJ1bmRsaW5nU3RyZW5ndGggPiAwKSB8fFxyXG4gICAgICBfXy5zbW9vdGhuZXNzID4gMFxyXG4gICAgKSB7XHJcbiAgICAgIHNpbmdsZV9jdXJ2ZShkLCBjdHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2luZ2xlX3BhdGgoZCwgY3R4KTtcclxuICAgIH1cclxuICAgIGN0eC5zdHJva2UoKTtcclxuICB9XHJcblxyXG4gIC8vIGRyYXcgbWFueSBwb2x5bGluZXMgb2YgdGhlIHNhbWUgY29sb3JcclxuICBmdW5jdGlvbiBwYXRocyhkYXRhLCBjdHgpIHtcclxuICAgIGN0eC5jbGVhclJlY3QoLTEsIC0xLCB3KCkgKyAyLCBoKCkgKyAyKTtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCAmJiBfXy5idW5kbGluZ1N0cmVuZ3RoID4gMCkgfHxcclxuICAgICAgICBfXy5zbW9vdGhuZXNzID4gMFxyXG4gICAgICApIHtcclxuICAgICAgICBzaW5nbGVfY3VydmUoZCwgY3R4KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybnMgdGhlIHktcG9zaXRpb24ganVzdCBiZXlvbmQgdGhlIHNlcGFyYXRpbmcgbnVsbCB2YWx1ZSBsaW5lXHJcbiAgZnVuY3Rpb24gZ2V0TnVsbFBvc2l0aW9uKCkge1xyXG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xyXG4gICAgICByZXR1cm4gaCgpICsgMTtcclxuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICd0b3AnKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCJBIHZhbHVlIGlzIE5VTEwsIGJ1dCBudWxsVmFsdWVTZXBhcmF0b3IgaXMgbm90IHNldDsgc2V0IGl0IHRvICdib3R0b20nIG9yICd0b3AnLlwiLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGgoKSArIDE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzaW5nbGVfcGF0aChkLCBjdHgpIHtcclxuICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XHJcbiAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICBjdHgubW92ZVRvKFxyXG4gICAgICAgICAgcG9zaXRpb24ocCksXHJcbiAgICAgICAgICB0eXBlb2YgZFtwXSA9PSAndW5kZWZpbmVkJyA/IGdldE51bGxQb3NpdGlvbigpIDogeXNjYWxlW3BdKGRbcF0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhcclxuICAgICAgICAgIHBvc2l0aW9uKHApLFxyXG4gICAgICAgICAgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhdGhfYnJ1c2hlZChkLCBpKSB7XHJcbiAgICBpZiAoX18uYnJ1c2hlZENvbG9yICE9PSBudWxsKSB7XHJcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5icnVzaGVkQ29sb3IpKGQsIGkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5icnVzaGVkKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhdGhfZm9yZWdyb3VuZChkLCBpKSB7XHJcbiAgICBjdHguZm9yZWdyb3VuZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xyXG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmZvcmVncm91bmQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGF0aF9oaWdobGlnaHQoZCwgaSkge1xyXG4gICAgY3R4LmhpZ2hsaWdodC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xyXG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmhpZ2hsaWdodCk7XHJcbiAgfVxyXG4gIHBjLmNsZWFyID0gZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICBjdHhbbGF5ZXJdLmNsZWFyUmVjdCgwLCAwLCB3KCkgKyAyLCBoKCkgKyAyKTtcclxuXHJcbiAgICAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGZvcmVncm91bmQgaXRlbXMgYXJlIHRyYW5zcGFyZW50XHJcbiAgICAvLyB3aXRob3V0IHRoZSBuZWVkIGZvciBjaGFuZ2luZyB0aGUgb3BhY2l0eSBzdHlsZSBvZiB0aGUgZm9yZWdyb3VuZCBjYW52YXNcclxuICAgIC8vIGFzIHRoaXMgd291bGQgc3RvcCB0aGUgY3NzIHN0eWxpbmcgZnJvbSB3b3JraW5nXHJcbiAgICBpZiAobGF5ZXIgPT09ICdicnVzaGVkJyAmJiBpc0JydXNoZWQoKSkge1xyXG4gICAgICBjdHguYnJ1c2hlZC5maWxsU3R5bGUgPSBwYy5zZWxlY3Rpb24uc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcclxuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSAxIC0gX18uYWxwaGFPbkJydXNoZWQ7XHJcbiAgICAgIGN0eC5icnVzaGVkLmZpbGxSZWN0KDAsIDAsIHcoKSArIDIsIGgoKSArIDIpO1xyXG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgZDMucmViaW5kKFxyXG4gICAgcGMsXHJcbiAgICBheGlzLFxyXG4gICAgJ3RpY2tzJyxcclxuICAgICdvcmllbnQnLFxyXG4gICAgJ3RpY2tWYWx1ZXMnLFxyXG4gICAgJ3RpY2tTdWJkaXZpZGUnLFxyXG4gICAgJ3RpY2tTaXplJyxcclxuICAgICd0aWNrUGFkZGluZycsXHJcbiAgICAndGlja0Zvcm1hdCcsXHJcbiAgKTtcclxuXHJcbiAgZnVuY3Rpb24gZmxpcEF4aXNBbmRVcGRhdGVQQ1AoZGltZW5zaW9uKSB7XHJcbiAgICB2YXIgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKTtcclxuXHJcbiAgICBwYy5mbGlwKGRpbWVuc2lvbik7XHJcblxyXG4gICAgZDMuc2VsZWN0KHRoaXMucGFyZW50RWxlbWVudClcclxuICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24oMTEwMClcclxuICAgICAgLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZGltZW5zaW9uXSkpO1xyXG5cclxuICAgIHBjLnJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcm90YXRlTGFiZWxzKCkge1xyXG4gICAgdmFyIGRlbHRhID0gZDMuZXZlbnQuZGVsdGFZO1xyXG4gICAgZGVsdGEgPSBkZWx0YSA8IDAgPyAtNSA6IGRlbHRhO1xyXG4gICAgZGVsdGEgPSBkZWx0YSA+IDAgPyA1IDogZGVsdGE7XHJcblxyXG4gICAgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArPSBkZWx0YTtcclxuICAgIHBjLnN2Z1xyXG4gICAgICAuc2VsZWN0QWxsKCd0ZXh0LmxhYmVsJylcclxuICAgICAgLmF0dHIoXHJcbiAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScsXHJcbiAgICAgICk7XHJcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGltZW5zaW9uTGFiZWxzKGQpIHtcclxuICAgIHJldHVybiBkIGluIF9fLmRpbWVuc2lvblRpdGxlcyA/IF9fLmRpbWVuc2lvblRpdGxlc1tkXSA6IGQ7IC8vIGRpbWVuc2lvbiBkaXNwbGF5IG5hbWVzXHJcbiAgfVxyXG5cclxuICBwYy5jcmVhdGVBeGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGcpIHBjLnJlbW92ZUF4ZXMoKTtcclxuXHJcbiAgICAvLyBBZGQgYSBncm91cCBlbGVtZW50IGZvciBlYWNoIGRpbWVuc2lvbi5cclxuICAgIGcgPSBwYy5zdmdcclxuICAgICAgLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpXHJcbiAgICAgIC5kYXRhKF9fLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKSc7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBhbiBheGlzIGFuZCB0aXRsZS5cclxuICAgIGcuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzJylcclxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpXHJcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcclxuICAgICAgfSlcclxuICAgICAgLmFwcGVuZCgnc3ZnOnRleHQnKVxyXG4gICAgICAuYXR0cih7XHJcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZScsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgY2xhc3M6ICdsYWJlbCcsXHJcbiAgICAgIH0pXHJcbiAgICAgIC50ZXh0KGRpbWVuc2lvbkxhYmVscylcclxuICAgICAgLm9uKCdkYmxjbGljaycsIGZsaXBBeGlzQW5kVXBkYXRlUENQKVxyXG4gICAgICAub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTtcclxuXHJcbiAgICBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICd0b3AnKSB7XHJcbiAgICAgIHBjLnN2Z1xyXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgLmF0dHIoJ3kxJywgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wKVxyXG4gICAgICAgIC5hdHRyKCd4MicsIHcoKSlcclxuICAgICAgICAuYXR0cigneTInLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3ApXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjNzc3JylcclxuICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcclxuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XHJcbiAgICAgIHBjLnN2Z1xyXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgLmF0dHIoJ3kxJywgaCgpICsgMSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tKVxyXG4gICAgICAgIC5hdHRyKCd4MicsIHcoKSlcclxuICAgICAgICAuYXR0cigneTInLCBoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20pXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjNzc3JylcclxuICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcclxuICAgIH1cclxuXHJcbiAgICBmbGFncy5heGVzID0gdHJ1ZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIHBjLnJlbW92ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBnLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgcGMudXBkYXRlQXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBnX2RhdGEgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJykuZGF0YShfXy5kaW1lbnNpb25zKTtcclxuXHJcbiAgICAvLyBFbnRlclxyXG4gICAgZ19kYXRhXHJcbiAgICAgIC5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3NpdGlvbihwKSArICcpJztcclxuICAgICAgfSlcclxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCAnYXhpcycpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxyXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hcHBlbmQoJ3N2Zzp0ZXh0JylcclxuICAgICAgLmF0dHIoe1xyXG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIGNsYXNzOiAnbGFiZWwnLFxyXG4gICAgICB9KVxyXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXHJcbiAgICAgIC5vbignZGJsY2xpY2snLCBmbGlwQXhpc0FuZFVwZGF0ZVBDUClcclxuICAgICAgLm9uKCd3aGVlbCcsIHJvdGF0ZUxhYmVscyk7XHJcblxyXG4gICAgLy8gVXBkYXRlXHJcbiAgICBnX2RhdGEuYXR0cignb3BhY2l0eScsIDApO1xyXG4gICAgZ19kYXRhXHJcbiAgICAgIC5zZWxlY3QoJy5heGlzJylcclxuICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24oMTEwMClcclxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xyXG4gICAgICB9KTtcclxuICAgIGdfZGF0YVxyXG4gICAgICAuc2VsZWN0KCcubGFiZWwnKVxyXG4gICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kdXJhdGlvbigxMTAwKVxyXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXHJcbiAgICAgIC5hdHRyKFxyXG4gICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxyXG4gICAgICApO1xyXG5cclxuICAgIC8vIEV4aXRcclxuICAgIGdfZGF0YS5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKTtcclxuICAgIGcudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kdXJhdGlvbigxMTAwKVxyXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgIHBjLnN2Z1xyXG4gICAgICAuc2VsZWN0QWxsKCcuYXhpcycpXHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKDExMDApXHJcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hhYmxlKCk7XHJcbiAgICBpZiAoZmxhZ3MucmVvcmRlcmFibGUpIHBjLnJlb3JkZXJhYmxlKCk7XHJcbiAgICBpZiAocGMuYnJ1c2hNb2RlKCkgIT09ICdOb25lJykge1xyXG4gICAgICB2YXIgbW9kZSA9IHBjLmJydXNoTW9kZSgpO1xyXG4gICAgICBwYy5icnVzaE1vZGUoJ05vbmUnKTtcclxuICAgICAgcGMuYnJ1c2hNb2RlKG1vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gSmFzb24gRGF2aWVzLCBodHRwOi8vYmwub2Nrcy5vcmcvMTM0MTI4MVxyXG4gIHBjLnJlb3JkZXJhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XHJcblxyXG4gICAgZy5zdHlsZSgnY3Vyc29yJywgJ21vdmUnKS5jYWxsKFxyXG4gICAgICBkMy5iZWhhdmlvclxyXG4gICAgICAgIC5kcmFnKClcclxuICAgICAgICAub24oJ2RyYWdzdGFydCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICBkcmFnZ2luZ1tkXSA9IHRoaXMuX19vcmlnaW5fXyA9IHhzY2FsZShkKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignZHJhZycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICBkcmFnZ2luZ1tkXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICB3KCksXHJcbiAgICAgICAgICAgIE1hdGgubWF4KDAsICh0aGlzLl9fb3JpZ2luX18gKz0gZDMuZXZlbnQuZHgpKSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBfXy5kaW1lbnNpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKGEpIC0gcG9zaXRpb24oYik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XHJcbiAgICAgICAgICBwYy5yZW5kZXIoKTtcclxuICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKGQpICsgJyknO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2RyYWdlbmQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgLy8gTGV0J3Mgc2VlIGlmIHRoZSBvcmRlciBoYXMgY2hhbmdlZCBhbmQgc2VuZCBvdXQgYW4gZXZlbnQgaWYgc28uXHJcbiAgICAgICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgICAgIGogPSBfXy5kaW1lbnNpb25zLmluZGV4T2YoZCksXHJcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLFxyXG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgd2hpbGUgKChlbGVtID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSAhPSBudWxsKSArK2k7XHJcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xyXG4gICAgICAgICAgICBldmVudHMuYXhlc3Jlb3JkZXIuY2FsbChwYywgX18uZGltZW5zaW9ucyk7XHJcbiAgICAgICAgICAgIC8vIFdlIG5vdyBhbHNvIHdhbnQgdG8gcmVvcmRlciB0aGUgYWN0dWFsIGRvbSBlbGVtZW50cyB0aGF0IHJlcHJlc2VudFxyXG4gICAgICAgICAgICAvLyB0aGUgYXhlcy4gVGhhdCBpcywgdGhlIGcuZGltZW5zaW9uIGVsZW1lbnRzLiBJZiB3ZSBkb24ndCBkbyB0aGlzLFxyXG4gICAgICAgICAgICAvLyB3ZSBnZXQgYSB3ZWlyZCBhbmQgY29uZnVzaW5nIHRyYW5zaXRpb24gd2hlbiB1cGRhdGVBeGVzIGlzIGNhbGxlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhhdCwgaW5pdGlhbGx5IHRoZSBudGggZy5kaW1lbnNpb24gZWxlbWVudFxyXG4gICAgICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBudGggYXhpcy4gSG93ZXZlciwgYWZ0ZXIgYSBtYW51YWwgcmVvcmRlcmluZyxcclxuICAgICAgICAgICAgLy8gd2l0aG91dCByZW9yZGVyaW5nIHRoZSBkb20gZWxlbWVudHMsIHRoZSBudGggZG9tIGVsZW1lbnRzIG5vIGxvbmdlclxyXG4gICAgICAgICAgICAvLyBuZWNlc3NhcmlseSByZXByZXNlbnRzIHRoZSBudGggYXhpcy5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gaSBpcyB0aGUgb3JpZ2luYWwgaW5kZXggb2YgdGhlIGRvbSBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIGogaXMgdGhlIG5ldyBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKGkgPiBqKSB7XHJcbiAgICAgICAgICAgICAgLy8gRWxlbWVudCBtb3ZlZCBsZWZ0XHJcbiAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBwYXJlbnQuY2hpbGRyZW5baiAtIDFdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBFbGVtZW50IG1vdmVkIHJpZ2h0XHJcbiAgICAgICAgICAgICAgaWYgKGogKyAxIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBwYXJlbnQuY2hpbGRyZW5baiArIDFdKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fb3JpZ2luX187XHJcbiAgICAgICAgICBkZWxldGUgZHJhZ2dpbmdbZF07XHJcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcylcclxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknKTtcclxuICAgICAgICAgIHBjLnJlbmRlcigpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgKTtcclxuICAgIGZsYWdzLnJlb3JkZXJhYmxlID0gdHJ1ZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIFJlb3JkZXIgZGltZW5zaW9ucywgc3VjaCB0aGF0IHRoZSBoaWdoZXN0IHZhbHVlICh2aXN1YWxseSkgaXMgb24gdGhlIGxlZnQgYW5kXHJcbiAgLy8gdGhlIGxvd2VzdCBvbiB0aGUgcmlnaHQuIFZpc3VhbCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGRhdGEgdmFsdWVzIGluXHJcbiAgLy8gdGhlIGdpdmVuIHJvdy5cclxuICBwYy5yZW9yZGVyID0gZnVuY3Rpb24gKHJvd2RhdGEpIHtcclxuICAgIHZhciBkaW1zID0gX18uZGltZW5zaW9ucy5zbGljZSgwKTtcclxuICAgIF9fLmRpbWVuc2lvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICB2YXIgcGl4ZWxEaWZmZXJlbmNlID0geXNjYWxlW2FdKHJvd2RhdGFbYV0pIC0geXNjYWxlW2JdKHJvd2RhdGFbYl0pO1xyXG5cclxuICAgICAgLy8gQXJyYXkuc29ydCBpcyBub3QgbmVjZXNzYXJpbHkgc3RhYmxlLCB0aGlzIG1lYW5zIHRoYXQgaWYgcGl4ZWxEaWZmZXJlbmNlIGlzIHplcm9cclxuICAgICAgLy8gdGhlIG9yZGVyaW5nIG9mIGRpbWVuc2lvbnMgbWlnaHQgY2hhbmdlIHVuZXhwZWN0ZWRseS4gVGhpcyBpcyBzb2x2ZWQgYnkgc29ydGluZyBvblxyXG4gICAgICAvLyB2YXJpYWJsZSBuYW1lIGluIHRoYXQgY2FzZS5cclxuICAgICAgaWYgKHBpeGVsRGlmZmVyZW5jZSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XHJcbiAgICAgIH0gLy8gZWxzZVxyXG4gICAgICByZXR1cm4gcGl4ZWxEaWZmZXJlbmNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTk9URTogdGhpcyBpcyByZWxhdGl2ZWx5IGNoZWFwIGdpdmVuIHRoYXQ6XHJcbiAgICAvLyBudW1iZXIgb2YgZGltZW5zaW9ucyA8IG51bWJlciBvZiBkYXRhIGl0ZW1zXHJcbiAgICAvLyBUaHVzIHdlIGNoZWNrIGVxdWFsaXR5IG9mIG9yZGVyIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgd2hlbiB0aGlzIGlzIHRoZSBjYXNlLlxyXG4gICAgdmFyIHJlb3JkZXJlZCA9IGZhbHNlO1xyXG4gICAgZGltcy5zb21lKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XHJcbiAgICAgIHJlb3JkZXJlZCA9IHZhbCAhPT0gX18uZGltZW5zaW9uc1tpbmRleF07XHJcbiAgICAgIHJldHVybiByZW9yZGVyZWQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAocmVvcmRlcmVkKSB7XHJcbiAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XHJcbiAgICAgIHZhciBoaWdobGlnaHRlZCA9IF9fLmhpZ2hsaWdodGVkLnNsaWNlKDApO1xyXG4gICAgICBwYy51bmhpZ2hsaWdodCgpO1xyXG5cclxuICAgICAgZy50cmFuc2l0aW9uKClcclxuICAgICAgICAuZHVyYXRpb24oMTUwMClcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKSc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIHBjLnJlbmRlcigpO1xyXG5cclxuICAgICAgLy8gcGMuaGlnaGxpZ2h0KCkgZG9lcyBub3QgY2hlY2sgd2hldGhlciBoaWdobGlnaHRlZCBpcyBsZW5ndGggemVybywgc28gd2UgZG8gdGhhdCBoZXJlLlxyXG4gICAgICBpZiAoaGlnaGxpZ2h0ZWQubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgcGMuaGlnaGxpZ2h0KGhpZ2hsaWdodGVkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIHBhaXJzIG9mIGFkamFjZW50IGRpbWVuc2lvbnNcclxuICBwYy5hZGphY2VudF9wYWlycyA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgIHZhciByZXQgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xyXG4gICAgICByZXQucHVzaChbYXJyW2ldLCBhcnJbaSArIDFdXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH07XHJcblxyXG4gIHZhciBicnVzaCA9IHtcclxuICAgIG1vZGVzOiB7XHJcbiAgICAgIE5vbmU6IHtcclxuICAgICAgICBpbnN0YWxsOiBmdW5jdGlvbiAocGMpIHt9LCAvLyBOb3RoaW5nIHRvIGJlIGRvbmUuXHJcbiAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAocGMpIHt9LCAvLyBOb3RoaW5nIHRvIGJlIGRvbmUuXHJcbiAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9LCAvLyBOb3RoaW5nIHRvIHJldHVyblxyXG4gICAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIG1vZGU6ICdOb25lJyxcclxuICAgIHByZWRpY2F0ZTogJ0FORCcsXHJcbiAgICBjdXJyZW50TW9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tb2Rlc1t0aGlzLm1vZGVdO1xyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGZvciAnbGl2ZScgdXBkYXRlcyBvZiBicnVzaGVzLiBUaGF0IGlzLCBkdXJpbmcgdGhlXHJcbiAgLy8gc3BlY2lmaWNhdGlvbiBvZiBhIGJydXNoLCB0aGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGUgdmlldy5cclxuICAvL1xyXG4gIC8vIEBwYXJhbSBuZXdTZWxlY3Rpb24gLSBUaGUgbmV3IHNldCBvZiBkYXRhIGl0ZW1zIHRoYXQgaXMgY3VycmVudGx5IGNvbnRhaW5lZFxyXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBieSB0aGUgYnJ1c2hlc1xyXG4gIGZ1bmN0aW9uIGJydXNoVXBkYXRlZChuZXdTZWxlY3Rpb24pIHtcclxuICAgIF9fLmJydXNoZWQgPSBuZXdTZWxlY3Rpb247XHJcbiAgICBldmVudHMuYnJ1c2guY2FsbChwYywgX18uYnJ1c2hlZCk7XHJcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBicnVzaFByZWRpY2F0ZShwcmVkaWNhdGUpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gYnJ1c2gucHJlZGljYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHByZWRpY2F0ZSA9IFN0cmluZyhwcmVkaWNhdGUpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBpZiAocHJlZGljYXRlICE9PSAnQU5EJyAmJiBwcmVkaWNhdGUgIT09ICdPUicpIHtcclxuICAgICAgdGhyb3cgJ0ludmFsaWQgcHJlZGljYXRlICcgKyBwcmVkaWNhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgYnJ1c2gucHJlZGljYXRlID0gcHJlZGljYXRlO1xyXG4gICAgX18uYnJ1c2hlZCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuc2VsZWN0ZWQoKTtcclxuICAgIHBjLnJlbmRlckJydXNoZWQoKTtcclxuICAgIHJldHVybiBwYztcclxuICB9XHJcblxyXG4gIHBjLmJydXNoTW9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYnJ1c2gubW9kZXMpO1xyXG4gIH07XHJcblxyXG4gIHBjLmJydXNoTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gYnJ1c2gubW9kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGMuYnJ1c2hNb2RlcygpLmluZGV4T2YobW9kZSkgPT09IC0xKSB7XHJcbiAgICAgIHRocm93ICdwYy5icnVzaG1vZGU6IFVuc3VwcG9ydGVkIGJydXNoIG1vZGU6ICcgKyBtb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IHRyaWdnZXIgdW5uZWNlc3NhcnkgZXZlbnRzIGJ5IGNoZWNraW5nIGlmIHRoZSBtb2RlXHJcbiAgICAvLyBhY3R1YWxseSBjaGFuZ2VzLlxyXG4gICAgaWYgKG1vZGUgIT09IGJydXNoLm1vZGUpIHtcclxuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBicnVzaCBtb2RlcywgdGhlIGZpcnN0IHRoaW5nIHdlIG5lZWQgdG8gZG8gaXMgY2xlYXJpbmcgYW55XHJcbiAgICAgIC8vIGJydXNoZXMgZnJvbSB0aGUgY3VycmVudCBtb2RlLCBpZiBhbnkuXHJcbiAgICAgIGlmIChicnVzaC5tb2RlICE9PSAnTm9uZScpIHtcclxuICAgICAgICBwYy5icnVzaFJlc2V0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5leHQsIHdlIG5lZWQgdG8gJ3VuaW5zdGFsbCcgdGhlIGN1cnJlbnQgYnJ1c2hNb2RlLlxyXG4gICAgICBicnVzaC5tb2Rlc1ticnVzaC5tb2RlXS51bmluc3RhbGwocGMpO1xyXG4gICAgICAvLyBGaW5hbGx5LCB3ZSBjYW4gaW5zdGFsbCB0aGUgcmVxdWVzdGVkIG9uZS5cclxuICAgICAgYnJ1c2gubW9kZSA9IG1vZGU7XHJcbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLmluc3RhbGwoKTtcclxuICAgICAgaWYgKG1vZGUgPT09ICdOb25lJykge1xyXG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFByZWRpY2F0ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYy5icnVzaFByZWRpY2F0ZSA9IGJydXNoUHJlZGljYXRlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBjO1xyXG4gIH07XHJcblxyXG4gIC8vIGJydXNoIG1vZGU6IDFELUF4ZXNcclxuXHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBicnVzaGVzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gaXNfYnJ1c2hlZChwKSB7XHJcbiAgICAgIHJldHVybiAhYnJ1c2hlc1twXS5lbXB0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRhdGEgd2l0aGluIGV4dGVudHNcclxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xyXG4gICAgICB2YXIgYWN0aXZlcyA9IF9fLmRpbWVuc2lvbnMuZmlsdGVyKGlzX2JydXNoZWQpLFxyXG4gICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgcmV0dXJuIGJydXNoZXNbcF0uZXh0ZW50KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXHJcbiAgICAgIC8vIEFjdHVhbGx5LCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQsIGJ5IGRlZmluaXRpb24sIG5vIGl0ZW1zIGFyZVxyXG4gICAgICAvLyBzZWxlY3RlZC4gU28sIGxldCdzIGF2b2lkIHRoZSBmaWx0ZXJpbmcgYW5kIGp1c3QgcmV0dXJuIGZhbHNlLlxyXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXHJcbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF9fLmRhdGE7XHJcblxyXG4gICAgICAvLyB0ZXN0IGlmIHdpdGhpbiByYW5nZVxyXG4gICAgICB2YXIgd2l0aGluID0ge1xyXG4gICAgICAgIGRhdGU6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24pIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmXHJcbiAgICAgICAgICAgICAgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJlxyXG4gICAgICAgICAgICAgIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xyXG4gICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJlxyXG4gICAgICAgICAgICB5c2NhbGVbcF0oZFtwXSkgPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xyXG4gICAgICAgICAgY2FzZSAnQU5EJzpcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xyXG4gICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY2FzZSAnT1InOlxyXG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5zb21lKGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBicnVzaEV4dGVudHMoZXh0ZW50cykge1xyXG4gICAgICBpZiAodHlwZW9mIGV4dGVudHMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdmFyIGV4dGVudHMgPSB7fTtcclxuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XHJcbiAgICAgICAgICBpZiAoYnJ1c2ggIT09IHVuZGVmaW5lZCAmJiAhYnJ1c2guZW1wdHkoKSkge1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZXh0ZW50KCk7XHJcbiAgICAgICAgICAgIGV4dGVudC5zb3J0KGQzLmFzY2VuZGluZyk7XHJcbiAgICAgICAgICAgIGV4dGVudHNbZF0gPSBleHRlbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVudHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9maXJzdCBnZXQgYWxsIHRoZSBicnVzaCBzZWxlY3Rpb25zXHJcbiAgICAgICAgdmFyIGJydXNoU2VsZWN0aW9ucyA9IHt9O1xyXG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICBicnVzaFNlbGVjdGlvbnNbZF0gPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGxvb3Agb3ZlciBlYWNoIGRpbWVuc2lvbiBhbmQgdXBkYXRlIGFwcHJvcHJpYXRlbHkgKGlmIGl0IHdhcyBwYXNzZWQgaW4gdGhyb3VnaCBleHRlbnRzKVxyXG4gICAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgaWYgKGV4dGVudHNbZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcclxuICAgICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBleHRlbnRcclxuICAgICAgICAgICAgYnJ1c2guZXh0ZW50KGV4dGVudHNbZF0pO1xyXG5cclxuICAgICAgICAgICAgLy9yZWRyYXcgdGhlIGJydXNoXHJcbiAgICAgICAgICAgIGJydXNoKGJydXNoU2VsZWN0aW9uc1tkXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpcmUgc29tZSBldmVudHNcclxuICAgICAgICAgICAgYnJ1c2guZXZlbnQoYnJ1c2hTZWxlY3Rpb25zW2RdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9yZWRyYXcgdGhlIGNoYXJ0XHJcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBicnVzaEZvcihheGlzKSB7XHJcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpO1xyXG5cclxuICAgICAgYnJ1c2hcclxuICAgICAgICAueSh5c2NhbGVbYXhpc10pXHJcbiAgICAgICAgLm9uKCdicnVzaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdicnVzaCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICBicnVzaGVzW2F4aXNdID0gYnJ1c2g7XHJcbiAgICAgIHJldHVybiBicnVzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoZGltZW5zaW9uKSB7XHJcbiAgICAgIF9fLmJydXNoZWQgPSBmYWxzZTtcclxuICAgICAgaWYgKGcpIHtcclxuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hlc1tkXS5jbGVhcigpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcclxuICAgICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XHJcblxyXG4gICAgICAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cclxuICAgICAgZy5hcHBlbmQoJ3N2ZzpnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYnJ1c2gnKVxyXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaEZvcihkKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcclxuICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKVxyXG4gICAgICAgIC5hdHRyKCd4JywgLTE1KVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIDMwKTtcclxuXHJcbiAgICAgIHBjLmJydXNoRXh0ZW50cyA9IGJydXNoRXh0ZW50cztcclxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQ7XHJcbiAgICAgIHJldHVybiBwYztcclxuICAgIH1cclxuXHJcbiAgICBicnVzaC5tb2Rlc1snMUQtYXhlcyddID0ge1xyXG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxyXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykucmVtb3ZlKCk7XHJcbiAgICAgICAgYnJ1c2hlcyA9IHt9O1xyXG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaEV4dGVudHM7XHJcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcclxuICAgICAgYnJ1c2hTdGF0ZTogYnJ1c2hFeHRlbnRzLFxyXG4gICAgfTtcclxuICB9KSgpO1xyXG4gIC8vIGJydXNoIG1vZGU6IDJELXN0cnVtc1xyXG4gIC8vIGJsLm9ja3Mub3JnL3N5bnRhZ21hdGljLzU0NDEwMjJcclxuXHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzdHJ1bXMgPSB7fSxcclxuICAgICAgc3RydW1SZWN0O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTdHJ1bShzdHJ1bSwgYWN0aXZlUG9pbnQpIHtcclxuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKSxcclxuICAgICAgICBpZCA9IHN0cnVtLmRpbXMuaSxcclxuICAgICAgICBwb2ludHMgPSBbc3RydW0ucDEsIHN0cnVtLnAyXSxcclxuICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgaWQpLmRhdGEoW3N0cnVtXSksXHJcbiAgICAgICAgY2lyY2xlcyA9IHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNzdHJ1bS0nICsgaWQpLmRhdGEocG9pbnRzKSxcclxuICAgICAgICBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xyXG5cclxuICAgICAgbGluZVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0cnVtLScgKyBpZClcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnc3RydW0nKTtcclxuXHJcbiAgICAgIGxpbmVcclxuICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGQucDFbMF07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGQucDFbMV07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGQucDJbMF07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGQucDJbMV07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XHJcblxyXG4gICAgICBkcmFnXHJcbiAgICAgICAgLm9uKCdkcmFnJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgIHZhciBldiA9IGQzLmV2ZW50O1xyXG4gICAgICAgICAgaSA9IGkgKyAxO1xyXG4gICAgICAgICAgc3RydW1bJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgTWF0aC5tYXgoc3RydW0ubWluWCArIDEsIGV2LngpLFxyXG4gICAgICAgICAgICBzdHJ1bS5tYXhYLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHN0cnVtWydwJyArIGldWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWSwgZXYueSksIHN0cnVtLm1heFkpO1xyXG4gICAgICAgICAgZHJhd1N0cnVtKHN0cnVtLCBpIC0gMSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoKSk7XHJcblxyXG4gICAgICBjaXJjbGVzXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS0nICsgaWQpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3N0cnVtJyk7XHJcblxyXG4gICAgICBjaXJjbGVzXHJcbiAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkWzBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkWzFdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDAuOCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2FsbChkcmFnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaW1lbnNpb25zRm9yUG9pbnQocCkge1xyXG4gICAgICB2YXIgZGltcyA9IHsgaTogLTEsIGxlZnQ6IHVuZGVmaW5lZCwgcmlnaHQ6IHVuZGVmaW5lZCB9O1xyXG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xyXG4gICAgICAgIGlmICh4c2NhbGUoZGltKSA8IHBbMF0pIHtcclxuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XHJcbiAgICAgICAgICBkaW1zLmkgPSBpO1xyXG4gICAgICAgICAgZGltcy5sZWZ0ID0gZGltO1xyXG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChkaW1zLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXHJcbiAgICAgICAgZGltcy5pID0gMDtcclxuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zWzBdO1xyXG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xyXG4gICAgICB9IGVsc2UgaWYgKGRpbXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBsYXN0IGF4aXNcclxuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgZGltcy5yaWdodCA9IGRpbXMubGVmdDtcclxuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zW19fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMl07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkaW1zO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge1xyXG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBzdHVybSB3YXMgc3RhcnRlZC5cclxuICAgICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgZnJlZWRvbSBvZiBtb3ZlbWVudCwgYmVjYXVzZSBhIHN0cnVtIGNhblxyXG4gICAgICAvLyBsb2dpY2FsbHkgb25seSBoYXBwZW4gYmV0d2VlbiB0d28gYXhlcywgc28gbm8gbW92ZW1lbnQgb3V0c2lkZSB0aGVzZSBheGVzXHJcbiAgICAgIC8vIHNob3VsZCBiZSBhbGxvd2VkLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwID0gZDMubW91c2Uoc3RydW1SZWN0WzBdWzBdKSxcclxuICAgICAgICAgIGRpbXMsXHJcbiAgICAgICAgICBzdHJ1bTtcclxuXHJcbiAgICAgICAgcFswXSA9IHBbMF0gLSBfXy5tYXJnaW4ubGVmdDtcclxuICAgICAgICBwWzFdID0gcFsxXSAtIF9fLm1hcmdpbi50b3A7XHJcblxyXG4gICAgICAgIChkaW1zID0gZGltZW5zaW9uc0ZvclBvaW50KHApKSxcclxuICAgICAgICAgIChzdHJ1bSA9IHtcclxuICAgICAgICAgICAgcDE6IHAsXHJcbiAgICAgICAgICAgIGRpbXM6IGRpbXMsXHJcbiAgICAgICAgICAgIG1pblg6IHhzY2FsZShkaW1zLmxlZnQpLFxyXG4gICAgICAgICAgICBtYXhYOiB4c2NhbGUoZGltcy5yaWdodCksXHJcbiAgICAgICAgICAgIG1pblk6IDAsXHJcbiAgICAgICAgICAgIG1heFk6IGgoKSxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzdHJ1bXNbZGltcy5pXSA9IHN0cnVtO1xyXG4gICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkaW1zLmk7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICAgIHN0cnVtLnAxWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCwgcFswXSksIHN0cnVtLm1heFgpO1xyXG4gICAgICAgIHN0cnVtLnAyID0gc3RydW0ucDEuc2xpY2UoKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkRyYWcoKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQsXHJcbiAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgc3RydW0ucDJbMF0gPSBNYXRoLm1pbihcclxuICAgICAgICAgIE1hdGgubWF4KHN0cnVtLm1pblggKyAxLCBldi54IC0gX18ubWFyZ2luLmxlZnQpLFxyXG4gICAgICAgICAgc3RydW0ubWF4WCxcclxuICAgICAgICApO1xyXG4gICAgICAgIHN0cnVtLnAyWzFdID0gTWF0aC5taW4oXHJcbiAgICAgICAgICBNYXRoLm1heChzdHJ1bS5taW5ZLCBldi55IC0gX18ubWFyZ2luLnRvcCksXHJcbiAgICAgICAgICBzdHJ1bS5tYXhZLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZHJhd1N0cnVtKHN0cnVtLCAxKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb250YWlubWVudFRlc3Qoc3RydW0sIHdpZHRoKSB7XHJcbiAgICAgIHZhciBwMSA9IFtzdHJ1bS5wMVswXSAtIHN0cnVtLm1pblgsIHN0cnVtLnAxWzFdIC0gc3RydW0ubWluWF0sXHJcbiAgICAgICAgcDIgPSBbc3RydW0ucDJbMF0gLSBzdHJ1bS5taW5YLCBzdHJ1bS5wMlsxXSAtIHN0cnVtLm1pblhdLFxyXG4gICAgICAgIG0xID0gMSAtIHdpZHRoIC8gcDFbMF0sXHJcbiAgICAgICAgYjEgPSBwMVsxXSAqICgxIC0gbTEpLFxyXG4gICAgICAgIG0yID0gMSAtIHdpZHRoIC8gcDJbMF0sXHJcbiAgICAgICAgYjIgPSBwMlsxXSAqICgxIC0gbTIpO1xyXG5cclxuICAgICAgLy8gdGVzdCBpZiBwb2ludCBmYWxscyBiZXR3ZWVuIGxpbmVzXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHZhciB4ID0gcFswXSxcclxuICAgICAgICAgIHkgPSBwWzFdLFxyXG4gICAgICAgICAgeTEgPSBtMSAqIHggKyBiMSxcclxuICAgICAgICAgIHkyID0gbTIgKiB4ICsgYjI7XHJcblxyXG4gICAgICAgIGlmICh5ID4gTWF0aC5taW4oeTEsIHkyKSAmJiB5IDwgTWF0aC5tYXgoeTEsIHkyKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XHJcbiAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdHJ1bXMpLFxyXG4gICAgICAgIGJydXNoZWQgPSBfXy5kYXRhO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBpZHMgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc3RydW1zLlxyXG4gICAgICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuICFpc05hTihkKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBjcm9zc2VzU3RydW0oZCwgaWQpIHtcclxuICAgICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbaWRdLFxyXG4gICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgc3RydW1zLndpZHRoKGlkKSksXHJcbiAgICAgICAgICBkMSA9IHN0cnVtLmRpbXMubGVmdCxcclxuICAgICAgICAgIGQyID0gc3RydW0uZGltcy5yaWdodCxcclxuICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcclxuICAgICAgICAgIHkyID0geXNjYWxlW2QyXSxcclxuICAgICAgICAgIHBvaW50ID0gW3kxKGRbZDFdKSAtIHN0cnVtLm1pblgsIHkyKGRbZDJdKSAtIHN0cnVtLm1pblhdO1xyXG4gICAgICAgIHJldHVybiB0ZXN0KHBvaW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gYnJ1c2hlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGJydXNoZWQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcclxuICAgICAgICAgIGNhc2UgJ0FORCc6XHJcbiAgICAgICAgICAgIHJldHVybiBpZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY2FzZSAnT1InOlxyXG4gICAgICAgICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cnVtKCkge1xyXG4gICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV0sXHJcbiAgICAgICAgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpO1xyXG5cclxuICAgICAgZGVsZXRlIHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcclxuICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgc3RydW0uZGltcy5pKS5yZW1vdmUoKTtcclxuICAgICAgc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI3N0cnVtLScgKyBzdHJ1bS5kaW1zLmkpLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYnJ1c2hlZCA9IF9fLmRhdGEsXHJcbiAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcclxuXHJcbiAgICAgICAgLy8gT2theSwgc29tZXdoYXQgdW5leHBlY3RlZCwgYnV0IG5vdCB0b3RhbGx5IHVuc3VycHJpc2luZywgYSBtb3VzY2xpY2sgaXNcclxuICAgICAgICAvLyBjb25zaWRlcmVkIGEgZHJhZyB3aXRob3V0IG1vdmUuIFNvIHdlIGhhdmUgdG8gZGVhbCB3aXRoIHRoYXQgY2FzZVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHN0cnVtICYmXHJcbiAgICAgICAgICBzdHJ1bS5wMVswXSA9PT0gc3RydW0ucDJbMF0gJiZcclxuICAgICAgICAgIHN0cnVtLnAxWzFdID09PSBzdHJ1bS5wMlsxXVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJydXNoZWQgPSBzZWxlY3RlZChzdHJ1bXMpO1xyXG4gICAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgX18uYnJ1c2hlZCA9IGJydXNoZWQ7XHJcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xyXG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KHN0cnVtcykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdHJ1bXMpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkO1xyXG4gICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XHJcbiAgICAgIHZhciBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xyXG5cclxuICAgICAgLy8gTWFwIG9mIGN1cnJlbnQgc3RydW1zLiBTdHJ1bXMgYXJlIHN0b3JlZCBwZXIgc2VnbWVudCBvZiB0aGUgUEMuIEEgc2VnbWVudCxcclxuICAgICAgLy8gYmVpbmcgdGhlIGFyZWEgYmV0d2VlbiB0d28gYXhlcy4gVGhlIGxlZnQgbW9zdCBhcmVhIGlzIGluZGV4ZWQgYXQgMC5cclxuICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIFBDIHNlZ21lbnQgd2hlcmUgY3VycmVudGx5IGEgc3RydW0gaXMgYmVpbmdcclxuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XHJcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXHJcbiAgICAgIC8vIHdlbGwuXHJcbiAgICAgIHN0cnVtcy53aWR0aCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF07XHJcblxyXG4gICAgICAgIGlmIChzdHJ1bSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cnVtLm1heFggLSBzdHJ1bS5taW5YO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXHJcbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xyXG4gICAgICAgICAgdmFyIGxlbmd0aCA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgcmV0dXJuIF9fLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3RcclxuICAgICAgICAgICAgICA/IGkgKyBpIDwgbGVuZ3RoICYmIF9fLmRpbWVuc2lvbnNbaSArIDFdID09PSBzZWNvbmRcclxuICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIC8vIFdlIGhhdmUgc29tZSBzdHJ1bXMsIHdoaWNoIG1pZ2h0IG5lZWQgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBkaW1zID0gc3RydW1zW2RdLmRpbXM7XHJcbiAgICAgICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgdHdvIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgc3RydW0gYXJlIG5vdCBuZXh0IHRvIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgLy8gYW55IG1vcmUsIHRoYW4gd2UnbGwgbmVlZCB0byByZW1vdmUgdGhlIHN0cnVtLiBPdGhlcndpc2Ugd2Uga2VlcCBpdC5cclxuICAgICAgICAgICAgaWYgKCFjb25zZWN1dGl2ZShkaW1zLmxlZnQsIGRpbXMucmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBZGQgYSBuZXcgc3ZnIGdyb3VwIGluIHdoaWNoIHdlIGRyYXcgdGhlIHN0cnVtcy5cclxuICAgICAgcGMuc2VsZWN0aW9uXHJcbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignaWQnLCAnc3RydW1zJylcclxuICAgICAgICAuYXR0cihcclxuICAgICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAvLyBJbnN0YWxsIHRoZSByZXF1aXJlZCBicnVzaFJlc2V0IGZ1bmN0aW9uXHJcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0KHN0cnVtcyk7XHJcblxyXG4gICAgICBkcmFnXHJcbiAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydChzdHJ1bXMpKVxyXG4gICAgICAgIC5vbignZHJhZycsIG9uRHJhZyhzdHJ1bXMpKVxyXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZChzdHJ1bXMpKTtcclxuXHJcbiAgICAgIC8vIE5PVEU6IFRoZSBzdHlsaW5nIG5lZWRzIHRvIGJlIGRvbmUgaGVyZSBhbmQgbm90IGluIHRoZSBjc3MuIFRoaXMgaXMgYmVjYXVzZVxyXG4gICAgICAvLyAgICAgICBmb3IgMUQgYnJ1c2hpbmcsIHRoZSBjYW52YXMgbGF5ZXJzIHNob3VsZCBub3QgbGlzdGVuIHRvXHJcbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxyXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb25cclxuICAgICAgICAuc2VsZWN0KCdzdmcnKVxyXG4gICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAnZyNzdHJ1bXMnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS1ldmVudHMnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBfXy5tYXJnaW4udG9wKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSlcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaCgpICsgMilcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgIC5jYWxsKGRyYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGJydXNoLm1vZGVzWycyRC1zdHJ1bXMnXSA9IHtcclxuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcclxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpLnJlbW92ZSgpO1xyXG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgncmVjdCNzdHJ1bS1ldmVudHMnKS5yZW1vdmUoKTtcclxuICAgICAgICBwYy5vbignYXhlc3Jlb3JkZXIuc3RydW1zJywgdW5kZWZpbmVkKTtcclxuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcclxuXHJcbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB9LFxyXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXHJcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc3RydW1zO1xyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuICAvLyBicnVzaCBtb2RlOiAxRC1BeGVzIHdpdGggbXVsdGlwbGUgZXh0ZW50c1xyXG4gIC8vIHJlcXVpcmVzIGQzLnN2Zy5tdWx0aWJydXNoXHJcblxyXG4gIChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGQzLnN2Zy5tdWx0aWJydXNoICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBicnVzaGVzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gaXNfYnJ1c2hlZChwKSB7XHJcbiAgICAgIHJldHVybiAhYnJ1c2hlc1twXS5lbXB0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRhdGEgd2l0aGluIGV4dGVudHNcclxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xyXG4gICAgICB2YXIgYWN0aXZlcyA9IF9fLmRpbWVuc2lvbnMuZmlsdGVyKGlzX2JydXNoZWQpLFxyXG4gICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgcmV0dXJuIGJydXNoZXNbcF0uZXh0ZW50KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXHJcbiAgICAgIC8vIEFjdHVhbGx5LCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQsIGJ5IGRlZmluaXRpb24sIG5vIGl0ZW1zIGFyZVxyXG4gICAgICAvLyBzZWxlY3RlZC4gU28sIGxldCdzIGF2b2lkIHRoZSBmaWx0ZXJpbmcgYW5kIGp1c3QgcmV0dXJuIGZhbHNlLlxyXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXHJcbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF9fLmRhdGE7XHJcblxyXG4gICAgICAvLyB0ZXN0IGlmIHdpdGhpbiByYW5nZVxyXG4gICAgICB2YXIgd2l0aGluID0ge1xyXG4gICAgICAgIGRhdGU6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcclxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBiWzFdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGJbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBudW1iZXI6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcclxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBiWzFdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGJbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcclxuICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIF9fLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcclxuICAgICAgICAgIGNhc2UgJ0FORCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLmV2ZXJ5KGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbiwgYik7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY2FzZSAnT1InOlxyXG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5zb21lKGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbiwgYik7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJydXNoRXh0ZW50cygpIHtcclxuICAgICAgdmFyIGV4dGVudHMgPSB7fTtcclxuICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcclxuICAgICAgICBpZiAoYnJ1c2ggIT09IHVuZGVmaW5lZCAmJiAhYnJ1c2guZW1wdHkoKSkge1xyXG4gICAgICAgICAgdmFyIGV4dGVudCA9IGJydXNoLmV4dGVudCgpO1xyXG4gICAgICAgICAgZXh0ZW50c1tkXSA9IGV4dGVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gZXh0ZW50cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBicnVzaEZvcihheGlzKSB7XHJcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5tdWx0aWJydXNoKCk7XHJcblxyXG4gICAgICBicnVzaFxyXG4gICAgICAgIC55KHlzY2FsZVtheGlzXSlcclxuICAgICAgICAub24oJ2JydXNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2JydXNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdicnVzaGVuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIC8vIGQzLnN2Zy5tdWx0aWJydXNoIGNsZWFycyBleHRlbnRzIGp1c3QgYmVmb3JlIGNhbGxpbmcgJ2JydXNoZW5kJ1xyXG4gICAgICAgICAgLy8gc28gd2UgaGF2ZSB0byB1cGRhdGUgaGVyZSBhZ2Fpbi5cclxuICAgICAgICAgIC8vIFRoaXMgZml4ZXMgaXNzdWUgIzEwMyBmb3Igbm93LCBidXQgc2hvdWxkIGJlIGNoYW5nZWQgaW4gZDMuc3ZnLm11bHRpYnJ1c2hcclxuICAgICAgICAgIC8vIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uLlxyXG4gICAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xyXG4gICAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmV4dGVudEFkYXB0aW9uKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcclxuICAgICAgICAgIHNlbGVjdGlvbi5zdHlsZSgndmlzaWJpbGl0eScsIG51bGwpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlc2l6ZUFkYXB0aW9uKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcclxuICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJ3JlY3QnKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIGJydXNoZXNbYXhpc10gPSBicnVzaDtcclxuICAgICAgcmV0dXJuIGJydXNoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoZGltZW5zaW9uKSB7XHJcbiAgICAgIF9fLmJydXNoZWQgPSBmYWxzZTtcclxuICAgICAgaWYgKGcpIHtcclxuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hlc1tkXS5jbGVhcigpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcclxuICAgICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XHJcblxyXG4gICAgICAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cclxuICAgICAgZy5hcHBlbmQoJ3N2ZzpnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYnJ1c2gnKVxyXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaEZvcihkKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcclxuICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKVxyXG4gICAgICAgIC5hdHRyKCd4JywgLTE1KVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIDMwKTtcclxuXHJcbiAgICAgIHBjLmJydXNoRXh0ZW50cyA9IGJydXNoRXh0ZW50cztcclxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQ7XHJcbiAgICAgIHJldHVybiBwYztcclxuICAgIH1cclxuXHJcbiAgICBicnVzaC5tb2Rlc1snMUQtYXhlcy1tdWx0aSddID0ge1xyXG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxyXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykucmVtb3ZlKCk7XHJcbiAgICAgICAgYnJ1c2hlcyA9IHt9O1xyXG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaEV4dGVudHM7XHJcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcclxuICAgICAgYnJ1c2hTdGF0ZTogYnJ1c2hFeHRlbnRzLFxyXG4gICAgfTtcclxuICB9KSgpO1xyXG4gIC8vIGJydXNoIG1vZGU6IGFuZ3VsYXJcclxuICAvLyBjb2RlIGJhc2VkIG9uIDJELnN0cnVtcy5qc1xyXG5cclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyY3MgPSB7fSxcclxuICAgICAgc3RydW1SZWN0O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTdHJ1bShhcmMsIGFjdGl2ZVBvaW50KSB7XHJcbiAgICAgIHZhciBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjYXJjcycpLFxyXG4gICAgICAgIGlkID0gYXJjLmRpbXMuaSxcclxuICAgICAgICBwb2ludHMgPSBbYXJjLnAyLCBhcmMucDNdLFxyXG4gICAgICAgIGxpbmUgPSBzdmcuc2VsZWN0QWxsKCdsaW5lI2FyYy0nICsgaWQpLmRhdGEoW1xyXG4gICAgICAgICAgeyBwMTogYXJjLnAxLCBwMjogYXJjLnAyIH0sXHJcbiAgICAgICAgICB7IHAxOiBhcmMucDEsIHAyOiBhcmMucDMgfSxcclxuICAgICAgICBdKSxcclxuICAgICAgICBjaXJjbGVzID0gc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI2FyYy0nICsgaWQpLmRhdGEocG9pbnRzKSxcclxuICAgICAgICBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpLFxyXG4gICAgICAgIHBhdGggPSBzdmcuc2VsZWN0QWxsKCdwYXRoI2FyYy0nICsgaWQpLmRhdGEoW2FyY10pO1xyXG5cclxuICAgICAgcGF0aFxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy0nICsgaWQpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2FyYycpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ29yYW5nZScpXHJcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMC41KTtcclxuXHJcbiAgICAgIHBhdGhcclxuICAgICAgICAuYXR0cignZCcsIGFyYy5hcmMpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGFyYy5wMVswXSArICcsJyArIGFyYy5wMVsxXSArICcpJyk7XHJcblxyXG4gICAgICBsaW5lXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLScgKyBpZClcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJyk7XHJcblxyXG4gICAgICBsaW5lXHJcbiAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAxWzBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAxWzFdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAyWzBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAyWzFdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xyXG5cclxuICAgICAgZHJhZ1xyXG4gICAgICAgIC5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICB2YXIgZXYgPSBkMy5ldmVudCxcclxuICAgICAgICAgICAgYW5nbGUgPSAwO1xyXG5cclxuICAgICAgICAgIGkgPSBpICsgMjtcclxuXHJcbiAgICAgICAgICBhcmNbJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCArIDEsIGV2LngpLCBhcmMubWF4WCk7XHJcbiAgICAgICAgICBhcmNbJ3AnICsgaV1bMV0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWSwgZXYueSksIGFyYy5tYXhZKTtcclxuXHJcbiAgICAgICAgICBhbmdsZSA9IGkgPT09IDMgPyBhcmNzLnN0YXJ0QW5nbGUoaWQpIDogYXJjcy5lbmRBbmdsZShpZCk7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAoYXJjLnN0YXJ0QW5nbGUgPCBNYXRoLlBJICYmXHJcbiAgICAgICAgICAgICAgYXJjLmVuZEFuZ2xlIDwgTWF0aC5QSSAmJlxyXG4gICAgICAgICAgICAgIGFuZ2xlIDwgTWF0aC5QSSkgfHxcclxuICAgICAgICAgICAgKGFyYy5zdGFydEFuZ2xlID49IE1hdGguUEkgJiZcclxuICAgICAgICAgICAgICBhcmMuZW5kQW5nbGUgPj0gTWF0aC5QSSAmJlxyXG4gICAgICAgICAgICAgIGFuZ2xlID49IE1hdGguUEkpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDIpIHtcclxuICAgICAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcclxuICAgICAgICAgICAgICBhcmMuYXJjLmVuZEFuZ2xlKGFuZ2xlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBhbmdsZTtcclxuICAgICAgICAgICAgICBhcmMuYXJjLnN0YXJ0QW5nbGUoYW5nbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZHJhd1N0cnVtKGFyYywgaSAtIDIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKCkpO1xyXG5cclxuICAgICAgY2lyY2xlc1xyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLScgKyBpZClcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJyk7XHJcblxyXG4gICAgICBjaXJjbGVzXHJcbiAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkWzBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkWzFdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDAuOCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2FsbChkcmFnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaW1lbnNpb25zRm9yUG9pbnQocCkge1xyXG4gICAgICB2YXIgZGltcyA9IHsgaTogLTEsIGxlZnQ6IHVuZGVmaW5lZCwgcmlnaHQ6IHVuZGVmaW5lZCB9O1xyXG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xyXG4gICAgICAgIGlmICh4c2NhbGUoZGltKSA8IHBbMF0pIHtcclxuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XHJcbiAgICAgICAgICBkaW1zLmkgPSBpO1xyXG4gICAgICAgICAgZGltcy5sZWZ0ID0gZGltO1xyXG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChkaW1zLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXHJcbiAgICAgICAgZGltcy5pID0gMDtcclxuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zWzBdO1xyXG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xyXG4gICAgICB9IGVsc2UgaWYgKGRpbXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBsYXN0IGF4aXNcclxuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgZGltcy5yaWdodCA9IGRpbXMubGVmdDtcclxuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zW19fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMl07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkaW1zO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge1xyXG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBhcmMgd2FzIHN0YXJ0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlIGZyZWVkb20gb2YgbW92ZW1lbnQsIGJlY2F1c2UgYSBhcmMgY2FuXHJcbiAgICAgIC8vIGxvZ2ljYWxseSBvbmx5IGhhcHBlbiBiZXR3ZWVuIHR3byBheGVzLCBzbyBubyBtb3ZlbWVudCBvdXRzaWRlIHRoZXNlIGF4ZXNcclxuICAgICAgLy8gc2hvdWxkIGJlIGFsbG93ZWQuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAgPSBkMy5tb3VzZShzdHJ1bVJlY3RbMF1bMF0pLFxyXG4gICAgICAgICAgZGltcyxcclxuICAgICAgICAgIGFyYztcclxuXHJcbiAgICAgICAgcFswXSA9IHBbMF0gLSBfXy5tYXJnaW4ubGVmdDtcclxuICAgICAgICBwWzFdID0gcFsxXSAtIF9fLm1hcmdpbi50b3A7XHJcblxyXG4gICAgICAgIChkaW1zID0gZGltZW5zaW9uc0ZvclBvaW50KHApKSxcclxuICAgICAgICAgIChhcmMgPSB7XHJcbiAgICAgICAgICAgIHAxOiBwLFxyXG4gICAgICAgICAgICBkaW1zOiBkaW1zLFxyXG4gICAgICAgICAgICBtaW5YOiB4c2NhbGUoZGltcy5sZWZ0KSxcclxuICAgICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxyXG4gICAgICAgICAgICBtaW5ZOiAwLFxyXG4gICAgICAgICAgICBtYXhZOiBoKCksXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYXJjOiBkMy5zdmcuYXJjKCkuaW5uZXJSYWRpdXMoMCksXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYXJjc1tkaW1zLmldID0gYXJjO1xyXG4gICAgICAgIGFyY3MuYWN0aXZlID0gZGltcy5pO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcclxuICAgICAgICBhcmMucDFbMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCwgcFswXSksIGFyYy5tYXhYKTtcclxuICAgICAgICBhcmMucDIgPSBhcmMucDEuc2xpY2UoKTtcclxuICAgICAgICBhcmMucDMgPSBhcmMucDEuc2xpY2UoKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkRyYWcoKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQsXHJcbiAgICAgICAgICBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgYXJjLnAyWzBdID0gTWF0aC5taW4oXHJcbiAgICAgICAgICBNYXRoLm1heChhcmMubWluWCArIDEsIGV2LnggLSBfXy5tYXJnaW4ubGVmdCksXHJcbiAgICAgICAgICBhcmMubWF4WCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGFyYy5wMlsxXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgTWF0aC5tYXgoYXJjLm1pblksIGV2LnkgLSBfXy5tYXJnaW4udG9wKSxcclxuICAgICAgICAgIGFyYy5tYXhZLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXJjLnAzID0gYXJjLnAyLnNsaWNlKCk7XHJcbiAgICAgICAgZHJhd1N0cnVtKGFyYywgMSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc29tZSBoZWxwZXIgZnVuY3Rpb25zXHJcbiAgICBmdW5jdGlvbiBoeXBvdGhlbnVzZShhLCBiKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJhZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBjID0gTWF0aC5QSSAvIDE4MDtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmdsZSkge1xyXG4gICAgICAgIHJldHVybiBhbmdsZSAqIGM7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHZhciBkZWcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYyA9IDE4MCAvIE1hdGguUEk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5nbGUpIHtcclxuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBbMCwgMipQSV0gLT4gWy1QSS8yLCBQSS8yXVxyXG4gICAgdmFyIHNpZ25lZEFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgIHZhciByZXQgPSBhbmdsZTtcclxuICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSkge1xyXG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMS41ICogTWF0aC5QSTtcclxuICAgICAgICByZXQgPSBhbmdsZSAtIDEuNSAqIE1hdGguUEk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAwLjUgKiBNYXRoLlBJO1xyXG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMC41ICogTWF0aC5QSTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLXJldDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBhbmdsZXMgYXJlIHN0b3JlZCBpbiByYWRpYW5zIGZyb20gaW4gWzAsIDIqUEldLCB3aGVyZSAwIGluIDEyIG8nY2xvY2suXHJcbiAgICAgKiBIb3dldmVyLCBvbmUgY2FuIG9ubHkgc2VsZWN0IGxpbmVzIGZyb20gMCB0byBQSSwgc28gd2UgY29tcHV0ZSB0aGVcclxuICAgICAqICdzaWduZWQnIGFuZ2xlLCB3aGVyZSAwIGlzIHRoZSBob3Jpem9udGFsIGxpbmUgKDMgbydjbG9jayksIGFuZCArLy0gUEkvMlxyXG4gICAgICogYXJlIDEyIGFuZCA2IG8nY2xvY2sgcmVzcGVjdGl2ZWx5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb250YWlubWVudFRlc3QoYXJjKSB7XHJcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gc2lnbmVkQW5nbGUoYXJjLnN0YXJ0QW5nbGUpO1xyXG4gICAgICB2YXIgZW5kQW5nbGUgPSBzaWduZWRBbmdsZShhcmMuZW5kQW5nbGUpO1xyXG5cclxuICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xyXG4gICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xyXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcclxuICAgICAgICBlbmRBbmdsZSA9IHRtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdGVzdCBpZiBzZWdtZW50IGFuZ2xlIGlzIGNvbnRhaW5lZCBpbiBhbmdsZSBpbnRlcnZhbFxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBpZiAoYSA+PSBzdGFydEFuZ2xlICYmIGEgPD0gZW5kQW5nbGUpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xyXG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcyksXHJcbiAgICAgICAgYnJ1c2hlZCA9IF9fLmRhdGE7XHJcblxyXG4gICAgICAvLyBHZXQgdGhlIGlkcyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBhcmNzLlxyXG4gICAgICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuICFpc05hTihkKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBjcm9zc2VzU3RydW0oZCwgaWQpIHtcclxuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF0sXHJcbiAgICAgICAgICB0ZXN0ID0gY29udGFpbm1lbnRUZXN0KGFyYyksXHJcbiAgICAgICAgICBkMSA9IGFyYy5kaW1zLmxlZnQsXHJcbiAgICAgICAgICBkMiA9IGFyYy5kaW1zLnJpZ2h0LFxyXG4gICAgICAgICAgeTEgPSB5c2NhbGVbZDFdLFxyXG4gICAgICAgICAgeTIgPSB5c2NhbGVbZDJdLFxyXG4gICAgICAgICAgYSA9IGFyY3Mud2lkdGgoaWQpLFxyXG4gICAgICAgICAgYiA9IHkxKGRbZDFdKSAtIHkyKGRbZDJdKSxcclxuICAgICAgICAgIGMgPSBoeXBvdGhlbnVzZShhLCBiKSxcclxuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hc2luKGIgLyBjKTsgLy8gcmFkIGluIFstUEkvMiwgUEkvMl1cclxuICAgICAgICByZXR1cm4gdGVzdChhbmdsZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGJydXNoZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBicnVzaGVkLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XHJcbiAgICAgICAgICBjYXNlICdBTkQnOlxyXG4gICAgICAgICAgICByZXR1cm4gaWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNhc2UgJ09SJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcclxuICAgICAgdmFyIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdLFxyXG4gICAgICAgIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJyk7XHJcblxyXG4gICAgICBkZWxldGUgYXJjc1thcmNzLmFjdGl2ZV07XHJcbiAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xyXG4gICAgICBzdmcuc2VsZWN0QWxsKCdsaW5lI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XHJcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xyXG4gICAgICBzdmcuc2VsZWN0QWxsKCdwYXRoI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25EcmFnRW5kKCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBicnVzaGVkID0gX18uZGF0YSxcclxuICAgICAgICAgIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdO1xyXG5cclxuICAgICAgICAvLyBPa2F5LCBzb21ld2hhdCB1bmV4cGVjdGVkLCBidXQgbm90IHRvdGFsbHkgdW5zdXJwcmlzaW5nLCBhIG1vdXNjbGljayBpc1xyXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgYSBkcmFnIHdpdGhvdXQgbW92ZS4gU28gd2UgaGF2ZSB0byBkZWFsIHdpdGggdGhhdCBjYXNlXHJcbiAgICAgICAgaWYgKGFyYyAmJiBhcmMucDFbMF0gPT09IGFyYy5wMlswXSAmJiBhcmMucDFbMV0gPT09IGFyYy5wMlsxXSkge1xyXG4gICAgICAgICAgcmVtb3ZlU3RydW0oYXJjcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXJjKSB7XHJcbiAgICAgICAgICB2YXIgYW5nbGUgPSBhcmNzLnN0YXJ0QW5nbGUoYXJjcy5hY3RpdmUpO1xyXG5cclxuICAgICAgICAgIGFyYy5zdGFydEFuZ2xlID0gYW5nbGU7XHJcbiAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcclxuICAgICAgICAgIGFyYy5hcmNcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKGFyY3MubGVuZ3RoKGFyY3MuYWN0aXZlKSlcclxuICAgICAgICAgICAgLnN0YXJ0QW5nbGUoYW5nbGUpXHJcbiAgICAgICAgICAgIC5lbmRBbmdsZShhbmdsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoYXJjcyk7XHJcbiAgICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgX18uYnJ1c2hlZCA9IGJydXNoZWQ7XHJcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xyXG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGFyY3MpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgYXJjcy5hY3RpdmUgPSBkO1xyXG4gICAgICAgICAgcmVtb3ZlU3RydW0oYXJjcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb25EcmFnRW5kKGFyY3MpKCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcclxuICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7XHJcblxyXG4gICAgICAvLyBNYXAgb2YgY3VycmVudCBhcmNzLiBhcmNzIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXHJcbiAgICAgIC8vIGJlaW5nIHRoZSBhcmVhIGJldHdlZW4gdHdvIGF4ZXMuIFRoZSBsZWZ0IG1vc3QgYXJlYSBpcyBpbmRleGVkIGF0IDAuXHJcbiAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgUEMgc2VnbWVudCB3aGVyZSBjdXJyZW50bHkgYSBhcmMgaXMgYmVpbmdcclxuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XHJcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXHJcbiAgICAgIC8vIHdlbGwuXHJcbiAgICAgIGFyY3Mud2lkdGggPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XHJcblxyXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcmMubWF4WCAtIGFyYy5taW5YO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gcmV0dXJucyBhbmdsZXMgaW4gWy1QSS8yLCBQSS8yXVxyXG4gICAgICBhbmdsZSA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcclxuICAgICAgICB2YXIgYSA9IHAxWzBdIC0gcDJbMF0sXHJcbiAgICAgICAgICBiID0gcDFbMV0gLSBwMlsxXSxcclxuICAgICAgICAgIGMgPSBoeXBvdGhlbnVzZShhLCBiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYXNpbihiIC8gYyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyByZXR1cm5zIGFuZ2xlcyBpbiBbMCwgMiAqIFBJXVxyXG4gICAgICBhcmNzLmVuZEFuZ2xlID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xyXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNBbmdsZSA9IGFuZ2xlKGFyYy5wMSwgYXJjLnAyKSxcclxuICAgICAgICAgIHVBbmdsZSA9IC1zQW5nbGUgKyBNYXRoLlBJIC8gMjtcclxuXHJcbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wMlswXSkge1xyXG4gICAgICAgICAgdUFuZ2xlID0gMiAqIE1hdGguUEkgLSB1QW5nbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdUFuZ2xlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgYXJjcy5zdGFydEFuZ2xlID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xyXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMyksXHJcbiAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XHJcblxyXG4gICAgICAgIGlmIChhcmMucDFbMF0gPiBhcmMucDNbMF0pIHtcclxuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGFyY3MubGVuZ3RoID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xyXG5cclxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYSA9IGFyYy5wMVswXSAtIGFyYy5wMlswXSxcclxuICAgICAgICAgIGIgPSBhcmMucDFbMV0gLSBhcmMucDJbMV0sXHJcbiAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYik7XHJcblxyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLmFyY3MnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBmaXJzdCBkaW1lbnNpb24gaXMgZGlyZWN0bHkgbGVmdCBvZiB0aGUgc2Vjb25kIGRpbWVuc2lvbi5cclxuICAgICAgICBmdW5jdGlvbiBjb25zZWN1dGl2ZShmaXJzdCwgc2Vjb25kKSB7XHJcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gX18uZGltZW5zaW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkID09PSBmaXJzdFxyXG4gICAgICAgICAgICAgID8gaSArIGkgPCBsZW5ndGggJiYgX18uZGltZW5zaW9uc1tpICsgMV0gPT09IHNlY29uZFxyXG4gICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgLy8gV2UgaGF2ZSBzb21lIGFyY3MsIHdoaWNoIG1pZ2h0IG5lZWQgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBkaW1zID0gYXJjc1tkXS5kaW1zO1xyXG4gICAgICAgICAgICBhcmNzLmFjdGl2ZSA9IGQ7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB0d28gZGltZW5zaW9ucyBvZiB0aGUgY3VycmVudCBhcmMgYXJlIG5vdCBuZXh0IHRvIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgLy8gYW55IG1vcmUsIHRoYW4gd2UnbGwgbmVlZCB0byByZW1vdmUgdGhlIGFyYy4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXHJcbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIG9uRHJhZ0VuZChhcmNzKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBZGQgYSBuZXcgc3ZnIGdyb3VwIGluIHdoaWNoIHdlIGRyYXcgdGhlIGFyY3MuXHJcbiAgICAgIHBjLnNlbGVjdGlvblxyXG4gICAgICAgIC5zZWxlY3QoJ3N2ZycpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyY3MnKVxyXG4gICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEluc3RhbGwgdGhlIHJlcXVpcmVkIGJydXNoUmVzZXQgZnVuY3Rpb25cclxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoYXJjcyk7XHJcblxyXG4gICAgICBkcmFnXHJcbiAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydChhcmNzKSlcclxuICAgICAgICAub24oJ2RyYWcnLCBvbkRyYWcoYXJjcykpXHJcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKGFyY3MpKTtcclxuXHJcbiAgICAgIC8vIE5PVEU6IFRoZSBzdHlsaW5nIG5lZWRzIHRvIGJlIGRvbmUgaGVyZSBhbmQgbm90IGluIHRoZSBjc3MuIFRoaXMgaXMgYmVjYXVzZVxyXG4gICAgICAvLyAgICAgICBmb3IgMUQgYnJ1c2hpbmcsIHRoZSBjYW52YXMgbGF5ZXJzIHNob3VsZCBub3QgbGlzdGVuIHRvXHJcbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxyXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb25cclxuICAgICAgICAuc2VsZWN0KCdzdmcnKVxyXG4gICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAnZyNhcmNzJylcclxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLWV2ZW50cycpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCBfXy5tYXJnaW4ubGVmdClcclxuICAgICAgICAuYXR0cigneScsIF9fLm1hcmdpbi50b3ApXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgdygpKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoKCkgKyAyKVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICAgICAgLmNhbGwoZHJhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgYnJ1c2gubW9kZXNbJ2FuZ3VsYXInXSA9IHtcclxuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcclxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKS5yZW1vdmUoKTtcclxuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ3JlY3QjYXJjLWV2ZW50cycpLnJlbW92ZSgpO1xyXG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgdW5kZWZpbmVkKTtcclxuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcclxuXHJcbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB9LFxyXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXHJcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gYXJjcztcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcbiAgcGMuaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBmbGFncy5pbnRlcmFjdGl2ZSA9IHRydWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBleHBvc2UgYSBmZXcgb2JqZWN0c1xyXG4gIHBjLnhzY2FsZSA9IHhzY2FsZTtcclxuICBwYy55c2NhbGUgPSB5c2NhbGU7XHJcbiAgcGMuY3R4ID0gY3R4O1xyXG4gIHBjLmNhbnZhcyA9IGNhbnZhcztcclxuICBwYy5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGc7XHJcbiAgfTtcclxuXHJcbiAgLy8gcmVzY2FsZSBmb3IgaGVpZ2h0LCB3aWR0aCBhbmQgbWFyZ2luc1xyXG4gIC8vIFRPRE8gY3VycmVudGx5IGFzc3VtZXMgY2hhcnQgaXMgYnJ1c2hhYmxlLCBhbmQgZGVzdHJveXMgb2xkIGJydXNoZXNcclxuICBwYy5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBzZWxlY3Rpb24gc2l6ZVxyXG4gICAgcGMuc2VsZWN0aW9uXHJcbiAgICAgIC5zZWxlY3QoJ3N2ZycpXHJcbiAgICAgIC5hdHRyKCd3aWR0aCcsIF9fLndpZHRoKVxyXG4gICAgICAuYXR0cignaGVpZ2h0JywgX18uaGVpZ2h0KTtcclxuICAgIHBjLnN2Zy5hdHRyKFxyXG4gICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBGSVhNRTogdGhlIGN1cnJlbnQgYnJ1c2ggc3RhdGUgc2hvdWxkIHBhc3MgdGhyb3VnaFxyXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hSZXNldCgpO1xyXG5cclxuICAgIC8vIHNjYWxlc1xyXG4gICAgcGMuYXV0b3NjYWxlKCk7XHJcblxyXG4gICAgLy8gYXhlcywgZGVzdHJveXMgb2xkIGJydXNoZXMuXHJcbiAgICBpZiAoZykgcGMuY3JlYXRlQXhlcygpO1xyXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hhYmxlKCk7XHJcbiAgICBpZiAoZmxhZ3MucmVvcmRlcmFibGUpIHBjLnJlb3JkZXJhYmxlKCk7XHJcblxyXG4gICAgZXZlbnRzLnJlc2l6ZS5jYWxsKHRoaXMsIHtcclxuICAgICAgd2lkdGg6IF9fLndpZHRoLFxyXG4gICAgICBoZWlnaHQ6IF9fLmhlaWdodCxcclxuICAgICAgbWFyZ2luOiBfXy5tYXJnaW4sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIGhpZ2hsaWdodCBhbiBhcnJheSBvZiBkYXRhXHJcbiAgcGMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBfXy5oaWdobGlnaHRlZDtcclxuICAgIH1cclxuXHJcbiAgICBfXy5oaWdobGlnaHRlZCA9IGRhdGE7XHJcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XHJcbiAgICBkMy5zZWxlY3RBbGwoW2NhbnZhcy5mb3JlZ3JvdW5kLCBjYW52YXMuYnJ1c2hlZF0pLmNsYXNzZWQoJ2ZhZGVkJywgdHJ1ZSk7XHJcbiAgICBkYXRhLmZvckVhY2gocGF0aF9oaWdobGlnaHQpO1xyXG4gICAgZXZlbnRzLmhpZ2hsaWdodC5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gY2xlYXIgaGlnaGxpZ2h0aW5nXHJcbiAgcGMudW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBfXy5oaWdobGlnaHRlZCA9IFtdO1xyXG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgZDMuc2VsZWN0QWxsKFtjYW52YXMuZm9yZWdyb3VuZCwgY2FudmFzLmJydXNoZWRdKS5jbGFzc2VkKCdmYWRlZCcsIGZhbHNlKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIGNhbGN1bGF0ZSAyZCBpbnRlcnNlY3Rpb24gb2YgbGluZSBhLT5iIHdpdGggbGluZSBjLT5kXHJcbiAgLy8gcG9pbnRzIGFyZSBvYmplY3RzIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXHJcbiAgcGMuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6XHJcbiAgICAgICAgKChhLnggKiBiLnkgLSBhLnkgKiBiLngpICogKGMueCAtIGQueCkgLVxyXG4gICAgICAgICAgKGEueCAtIGIueCkgKiAoYy54ICogZC55IC0gYy55ICogZC54KSkgL1xyXG4gICAgICAgICgoYS54IC0gYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gZC54KSksXHJcbiAgICAgIHk6XHJcbiAgICAgICAgKChhLnggKiBiLnkgLSBhLnkgKiBiLngpICogKGMueSAtIGQueSkgLVxyXG4gICAgICAgICAgKGEueSAtIGIueSkgKiAoYy54ICogZC55IC0gYy55ICogZC54KSkgL1xyXG4gICAgICAgICgoYS54IC0gYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gZC54KSksXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHBvc2l0aW9uKGQpIHtcclxuICAgIHZhciB2ID0gZHJhZ2dpbmdbZF07XHJcbiAgICByZXR1cm4gdiA9PSBudWxsID8geHNjYWxlKGQpIDogdjtcclxuICB9XHJcbiAgcGMudmVyc2lvbiA9ICcwLjcuMCc7XHJcbiAgLy8gdGhpcyBkZXNjcmlwdGl2ZSB0ZXh0IHNob3VsZCBsaXZlIHdpdGggb3RoZXIgaW50cm9zcGVjdGl2ZSBtZXRob2RzXHJcbiAgcGMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAnUGFyYWxsZWwgQ29vcmRpbmF0ZXM6ICcgK1xyXG4gICAgICBfXy5kaW1lbnNpb25zLmxlbmd0aCArXHJcbiAgICAgICcgZGltZW5zaW9ucyAoJyArXHJcbiAgICAgIGQzLmtleXMoX18uZGF0YVswXSkubGVuZ3RoICtcclxuICAgICAgJyB0b3RhbCkgLCAnICtcclxuICAgICAgX18uZGF0YS5sZW5ndGggK1xyXG4gICAgICAnIHJvd3MnXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBwYztcclxufVxyXG5cclxuZDMucmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gIHZhciBfcXVldWUgPSBbXSwgLy8gZGF0YSB0byBiZSByZW5kZXJlZFxyXG4gICAgX3JhdGUgPSAxMCwgLy8gbnVtYmVyIG9mIGNhbGxzIHBlciBmcmFtZVxyXG4gICAgX2NsZWFyID0gZnVuY3Rpb24gKCkge30sIC8vIGNsZWFyaW5nIGZ1bmN0aW9uXHJcbiAgICBfaSA9IDA7IC8vIGN1cnJlbnQgaXRlcmF0aW9uXHJcblxyXG4gIHZhciBycSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSkgcnEuZGF0YShkYXRhKTtcclxuICAgIHJxLmludmFsaWRhdGUoKTtcclxuICAgIF9jbGVhcigpO1xyXG4gICAgcnEucmVuZGVyKCk7XHJcbiAgfTtcclxuXHJcbiAgcnEucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX2kgPSAwO1xyXG4gICAgdmFyIHZhbGlkID0gdHJ1ZTtcclxuICAgIHJxLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRvRnJhbWUoKSB7XHJcbiAgICAgIGlmICghdmFsaWQpIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAoX2kgPiBfcXVldWUubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIC8vIFR5cGljYWwgZDMgYmVoYXZpb3IgaXMgdG8gcGFzcyBhIGRhdGEgaXRlbSAqYW5kKiBpdHMgaW5kZXguIEFzIHRoZVxyXG4gICAgICAvLyByZW5kZXIgcXVldWUgc3BsaXRzIHRoZSBvcmlnaW5hbCBkYXRhIHNldCwgd2UnbGwgaGF2ZSB0byBiZSBzbGlnaHRseVxyXG4gICAgICAvLyBtb3JlIGNhcmVmdWxsIGFib3V0IHBhc3NpbmcgdGhlIGNvcnJlY3QgaW5kZXggd2l0aCB0aGUgZGF0YSBpdGVtLlxyXG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oX2kgKyBfcmF0ZSwgX3F1ZXVlLmxlbmd0aCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSBfaTsgaSA8IGVuZDsgaSArPSAxKSB7XHJcbiAgICAgICAgZnVuYyhfcXVldWVbaV0sIGkpO1xyXG4gICAgICB9XHJcbiAgICAgIF9pICs9IF9yYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGQzLnRpbWVyKGRvRnJhbWUpO1xyXG4gIH07XHJcblxyXG4gIHJxLmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgcnEuaW52YWxpZGF0ZSgpO1xyXG4gICAgX3F1ZXVlID0gZGF0YS5zbGljZSgwKTtcclxuICAgIHJldHVybiBycTtcclxuICB9O1xyXG5cclxuICBycS5yYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBfcmF0ZTtcclxuICAgIF9yYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gcnE7XHJcbiAgfTtcclxuXHJcbiAgcnEucmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9xdWV1ZS5sZW5ndGggLSBfaTtcclxuICB9O1xyXG5cclxuICAvLyBjbGVhciB0aGUgY2FudmFzXHJcbiAgcnEuY2xlYXIgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIF9jbGVhcigpO1xyXG4gICAgICByZXR1cm4gcnE7XHJcbiAgICB9XHJcbiAgICBfY2xlYXIgPSBmdW5jO1xyXG4gICAgcmV0dXJuIHJxO1xyXG4gIH07XHJcblxyXG4gIHJxLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgcmV0dXJuIHJxO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js":
/*!******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\n\nfunction (config) {\n  var columns = [];\n\n  var dg = function (selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]);\n\n    // header\n    selection.\n    selectAll('.header').\n    data([true]).\n    enter().\n    append('div').\n    attr('class', 'header');\n\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n\n    header.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n\n    header.exit().remove();\n\n    // rows\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n\n    rows.enter().append('div').attr('class', 'row');\n\n    rows.exit().remove();\n\n    var cells = selection.\n    selectAll('.row').\n    selectAll('.cell').\n    data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    });\n\n    // cells\n    cells.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    cells.exit().remove();\n\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n}; /* [LICENSE TBD] */ /* eslint-disable */ // from http://bl.ocks.org/3687826\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBekVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcz80MDQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuLy8gZnJvbSBodHRwOi8vYmwub2Nrcy5vcmcvMzY4NzgyNlxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgdmFyIGNvbHVtbnMgPSBbXTtcclxuXHJcbiAgdmFyIGRnID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xyXG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoID09IDApIGNvbHVtbnMgPSBkMy5rZXlzKHNlbGVjdGlvbi5kYXRhKClbMF1bMF0pO1xyXG5cclxuICAgIC8vIGhlYWRlclxyXG4gICAgc2VsZWN0aW9uXHJcbiAgICAgIC5zZWxlY3RBbGwoJy5oZWFkZXInKVxyXG4gICAgICAuZGF0YShbdHJ1ZV0pXHJcbiAgICAgIC5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdoZWFkZXInKTtcclxuXHJcbiAgICB2YXIgaGVhZGVyID0gc2VsZWN0aW9uLnNlbGVjdCgnLmhlYWRlcicpLnNlbGVjdEFsbCgnLmNlbGwnKS5kYXRhKGNvbHVtbnMpO1xyXG5cclxuICAgIGhlYWRlclxyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgIHJldHVybiAnY29sLScgKyBpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2xhc3NlZCgnY2VsbCcsIHRydWUpO1xyXG5cclxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5oZWFkZXIgLmNlbGwnKS50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIHJldHVybiBkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaGVhZGVyLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICAvLyByb3dzXHJcbiAgICB2YXIgcm93cyA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5yb3cnKS5kYXRhKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIHJldHVybiBkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcm93cy5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAncm93Jyk7XHJcblxyXG4gICAgcm93cy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgdmFyIGNlbGxzID0gc2VsZWN0aW9uXHJcbiAgICAgIC5zZWxlY3RBbGwoJy5yb3cnKVxyXG4gICAgICAuc2VsZWN0QWxsKCcuY2VsbCcpXHJcbiAgICAgIC5kYXRhKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgICAgIHJldHVybiBkW2NvbF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIGNlbGxzXHJcbiAgICBjZWxsc1xyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgIHJldHVybiAnY29sLScgKyBpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2xhc3NlZCgnY2VsbCcsIHRydWUpO1xyXG5cclxuICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuY2VsbCcpLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGc7XHJcbiAgfTtcclxuXHJcbiAgZGcuY29sdW1ucyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2x1bW5zO1xyXG4gICAgY29sdW1ucyA9IF87XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICByZXR1cm4gZGc7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\n");

/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ \"./node_modules/core-js/internals/make-built-in.js\");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n\nmodule.exports = function (target, name, descriptor) {\n  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });\n  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });\n  return defineProperty.f(target, name, descriptor);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanM/ZWRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFrZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmdldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5nZXQsIG5hbWUsIHsgZ2V0dGVyOiB0cnVlIH0pO1xuICBpZiAoZGVzY3JpcHRvci5zZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/core-js/internals/define-built-in-accessor.js\n");

/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qcz9hZDZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuaGFzSW5kaWNlcykgcmVzdWx0ICs9ICdkJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQudW5pY29kZVNldHMpIHJlc3VsdCArPSAndic7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/core-js/internals/regexp-flags.js\n");

/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.flags.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.flags.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ \"./node_modules/core-js/internals/define-built-in-accessor.js\");\nvar regExpFlags = __webpack_require__(/*! ../internals/regexp-flags */ \"./node_modules/core-js/internals/regexp-flags.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 'd') -> /./d and it causes SyntaxError\nvar RegExp = global.RegExp;\nvar RegExpPrototype = RegExp.prototype;\n\nvar FORCED = DESCRIPTORS && fails(function () {\n  var INDICES_SUPPORT = true;\n  try {\n    RegExp('.', 'd');\n  } catch (error) {\n    INDICES_SUPPORT = false;\n  }\n\n  var O = {};\n  // modern V8 bug\n  var calls = '';\n  var expected = INDICES_SUPPORT ? 'dgimsy' : 'gimsy';\n\n  var addGetter = function (key, chr) {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- safe\n    Object.defineProperty(O, key, { get: function () {\n      calls += chr;\n      return true;\n    } });\n  };\n\n  var pairs = {\n    dotAll: 's',\n    global: 'g',\n    ignoreCase: 'i',\n    multiline: 'm',\n    sticky: 'y'\n  };\n\n  if (INDICES_SUPPORT) pairs.hasIndices = 'd';\n\n  for (var key in pairs) addGetter(key, pairs[key]);\n\n  // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n  var result = Object.getOwnPropertyDescriptor(RegExpPrototype, 'flags').get.call(O);\n\n  return result !== expected || calls !== expected;\n});\n\n// `RegExp.prototype.flags` getter\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nif (FORCED) defineBuiltInAccessor(RegExpPrototype, 'flags', {\n  configurable: true,\n  get: regExpFlags\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5mbGFncy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZmxhZ3MuanM/NTM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3NvcicpO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnLicsICdkJykgLT4gLy4vZCBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgRk9SQ0VEID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgSU5ESUNFU19TVVBQT1JUID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBSZWdFeHAoJy4nLCAnZCcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIElORElDRVNfU1VQUE9SVCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIE8gPSB7fTtcbiAgLy8gbW9kZXJuIFY4IGJ1Z1xuICB2YXIgY2FsbHMgPSAnJztcbiAgdmFyIGV4cGVjdGVkID0gSU5ESUNFU19TVVBQT1JUID8gJ2RnaW1zeScgOiAnZ2ltc3knO1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoa2V5LCBjaHIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxscyArPSBjaHI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IH0pO1xuICB9O1xuXG4gIHZhciBwYWlycyA9IHtcbiAgICBkb3RBbGw6ICdzJyxcbiAgICBnbG9iYWw6ICdnJyxcbiAgICBpZ25vcmVDYXNlOiAnaScsXG4gICAgbXVsdGlsaW5lOiAnbScsXG4gICAgc3RpY2t5OiAneSdcbiAgfTtcblxuICBpZiAoSU5ESUNFU19TVVBQT1JUKSBwYWlycy5oYXNJbmRpY2VzID0gJ2QnO1xuXG4gIGZvciAodmFyIGtleSBpbiBwYWlycykgYWRkR2V0dGVyKGtleSwgcGFpcnNba2V5XSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJlZ0V4cFByb3RvdHlwZSwgJ2ZsYWdzJykuZ2V0LmNhbGwoTyk7XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gZXhwZWN0ZWQgfHwgY2FsbHMgIT09IGV4cGVjdGVkO1xufSk7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbmlmIChGT1JDRUQpIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihSZWdFeHBQcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlZ0V4cEZsYWdzXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/core-js/modules/es.regexp.flags.js\n");

/***/ }),

/***/ "./packages/superset-ui-core/src/chart/components/reactify.tsx":
/*!*********************************************************************!*\
  !*** ./packages/superset-ui-core/src/chart/components/reactify.tsx ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reactify)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction reactify(renderFn, callbacks) {\n  class ReactifiedComponent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n\n    constructor(props) {\n      super(props);this.container = void 0;\n      this.setContainerRef = this.setContainerRef.bind(this);\n    }\n    componentDidMount() {\n      this.execute();\n    }\n    componentDidUpdate() {\n      this.execute();\n    }\n    componentWillUnmount() {\n      this.container = undefined;\n      if (callbacks != null && callbacks.componentWillUnmount) {\n        callbacks.componentWillUnmount.bind(this)();\n      }\n    }\n    setContainerRef(ref) {\n      this.container = ref;\n    }\n    execute() {\n      if (this.container) {\n        renderFn(this.container, this.props);\n      }\n    }\n    render() {\n      const { id, className } = this.props;\n      return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: this.setContainerRef, id: id, className: className });\n    } // @ts-ignore\n    __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n      this[key] = eval(code);}}const ReactifiedClass = ReactifiedComponent;\n  if (renderFn.displayName) {\n    ReactifiedClass.displayName = renderFn.displayName;\n  }\n  // eslint-disable-next-line react/forbid-foreign-prop-types\n  if (renderFn.propTypes) {\n    ReactifiedClass.propTypes = {\n      ...ReactifiedClass.propTypes,\n      ...renderFn.propTypes };\n\n  }\n  if (renderFn.defaultProps) {\n    ReactifiedClass.defaultProps = renderFn.defaultProps;\n  }\n  return ReactifiedComponent;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(reactify, \"reactify\", \"/app/superset-frontend/packages/superset-ui-core/src/chart/components/reactify.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlcy9zdXBlcnNldC11aS1jb3JlL3NyYy9jaGFydC9jb21wb25lbnRzL3JlYWN0aWZ5LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBK0JBO0FBSUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFyQ0E7QUFBQTtBQTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGFja2FnZXMvc3VwZXJzZXQtdWktY29yZS9zcmMvY2hhcnQvY29tcG9uZW50cy9yZWFjdGlmeS50c3g/ZWNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuLy8gVE9ETzogTm90ZSB0aGF0IGlkIGFuZCBjbGFzc05hbWUgY2FuIGNvbGxpZGUgYmV0d2VlbiBQcm9wcyBhbmQgUmVhY3RpZnlQcm9wc1xyXG4vLyBsZWFkaW5nIHRvIChsaWtlbHkpIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLiBXZSBzaG91bGQgZWl0aGVyIHJlcXVpcmUgUHJvcHMgdG8gbm90XHJcbi8vIGNvbnRhaW4gYW4gaWQvY2xhc3NOYW1lLCBvciBub3QgY29tYmluZSB0aGVtICh2aWEgaW50ZXJzZWN0aW9uKSwgaW5zdGVhZCBwcmVmZXJyaW5nXHJcbi8vIHdyYXBwaW5nIChjb21wb3NpdGlvbikuIEFzIGFuIGV4YW1wbGU6XHJcbi8vIGludGVyZmFjZSBNeVByb3BzIHtcclxuLy8gICBpZDogbnVtYmVyO1xyXG4vLyB9XHJcbi8vIGZ1bmN0aW9uIG15UmVuZGVyKGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIHByb3BzOiBSZWFkb25seTxNeVByb3BzPik6IHZvaWQge1xyXG4vLyAgIHByb3BzLmlkIC8vIHVudXNhYmxlOiBpZCBpcyBzdHJpbmcgJiBudW1iZXJcclxuLy8gfVxyXG4vLyBuZXcgKHJlYWN0aWZ5KG15UmVuZGVyKSkoeyBpZDogNSB9KTsgLy8gZXJyb3I6IGlkIGhhcyB0byBiZSBzdHJpbmcgJiBudW1iZXJcclxuXHJcbmV4cG9ydCB0eXBlIFJlYWN0aWZ5UHJvcHMgPSB7XHJcbiAgaWQ/OiBzdHJpbmc7XHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xyXG59O1xyXG5cclxuLy8gVE9ETzogYWRkIG1vcmUgUmVhY3QgbGlmZWN5Y2xlIGNhbGxiYWNrcyBhcyBuZWVkZWRcclxuZXhwb3J0IHR5cGUgTGlmZUN5Y2xlQ2FsbGJhY2tzID0ge1xyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50PzogKCkgPT4gdm9pZDtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyRnVuY1R5cGU8UHJvcHM+IHtcclxuICAoY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgcHJvcHM6IFJlYWRvbmx5PFByb3BzICYgUmVhY3RpZnlQcm9wcz4pOiB2b2lkO1xyXG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xyXG4gIGRlZmF1bHRQcm9wcz86IFBhcnRpYWw8UHJvcHMgJiBSZWFjdGlmeVByb3BzPjtcclxuICBwcm9wVHlwZXM/OiBSZWFjdC5XZWFrVmFsaWRhdGlvbk1hcDxQcm9wcyAmIFJlYWN0aWZ5UHJvcHM+O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFjdGlmeTxQcm9wcyBleHRlbmRzIG9iamVjdD4oXHJcbiAgcmVuZGVyRm46IFJlbmRlckZ1bmNUeXBlPFByb3BzPixcclxuICBjYWxsYmFja3M/OiBMaWZlQ3ljbGVDYWxsYmFja3MsXHJcbik6IFJlYWN0LkNvbXBvbmVudENsYXNzPFByb3BzICYgUmVhY3RpZnlQcm9wcz4ge1xyXG4gIGNsYXNzIFJlYWN0aWZpZWRDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiB7XHJcbiAgICBjb250YWluZXI/OiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMgJiBSZWFjdGlmeVByb3BzKSB7XHJcbiAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgdGhpcy5zZXRDb250YWluZXJSZWYgPSB0aGlzLnNldENvbnRhaW5lclJlZi5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICAgIHRoaXMuZXhlY3V0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgaWYgKGNhbGxiYWNrcz8uY29tcG9uZW50V2lsbFVubW91bnQpIHtcclxuICAgICAgICBjYWxsYmFja3MuY29tcG9uZW50V2lsbFVubW91bnQuYmluZCh0aGlzKSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q29udGFpbmVyUmVmKHJlZjogSFRNTERpdkVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5jb250YWluZXIgPSByZWY7XHJcbiAgICB9XHJcblxyXG4gICAgZXhlY3V0ZSgpIHtcclxuICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XHJcbiAgICAgICAgcmVuZGVyRm4odGhpcy5jb250YWluZXIsIHRoaXMucHJvcHMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICBjb25zdCB7IGlkLCBjbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICByZXR1cm4gPGRpdiByZWY9e3RoaXMuc2V0Q29udGFpbmVyUmVmfSBpZD17aWR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSAvPjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IFJlYWN0aWZpZWRDbGFzczogUmVhY3QuQ29tcG9uZW50Q2xhc3M8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiA9XHJcbiAgICBSZWFjdGlmaWVkQ29tcG9uZW50O1xyXG5cclxuICBpZiAocmVuZGVyRm4uZGlzcGxheU5hbWUpIHtcclxuICAgIFJlYWN0aWZpZWRDbGFzcy5kaXNwbGF5TmFtZSA9IHJlbmRlckZuLmRpc3BsYXlOYW1lO1xyXG4gIH1cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZm9yYmlkLWZvcmVpZ24tcHJvcC10eXBlc1xyXG4gIGlmIChyZW5kZXJGbi5wcm9wVHlwZXMpIHtcclxuICAgIFJlYWN0aWZpZWRDbGFzcy5wcm9wVHlwZXMgPSB7XHJcbiAgICAgIC4uLlJlYWN0aWZpZWRDbGFzcy5wcm9wVHlwZXMsXHJcbiAgICAgIC4uLnJlbmRlckZuLnByb3BUeXBlcyxcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmIChyZW5kZXJGbi5kZWZhdWx0UHJvcHMpIHtcclxuICAgIFJlYWN0aWZpZWRDbGFzcy5kZWZhdWx0UHJvcHMgPSByZW5kZXJGbi5kZWZhdWx0UHJvcHM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gUmVhY3RpZmllZENvbXBvbmVudDtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./packages/superset-ui-core/src/chart/components/reactify.tsx\n");

/***/ })

}]);