"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["plugins_plugin-chart-pivot-table_src_PivotTableChart_tsx"],{

/***/ "./node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _ant_design_icons_svg_es_asn_MinusSquareOutlined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons-svg/es/asn/MinusSquareOutlined */ \"./node_modules/@ant-design/icons-svg/es/asn/MinusSquareOutlined.js\");\n/* harmony import */ var _components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/AntdIcon */ \"./node_modules/@ant-design/icons/es/components/AntdIcon.js\");\n// GENERATE BY ./scripts/generate.ts\n// DON NOT EDIT IT MANUALLY\n\n\n\n\nvar MinusSquareOutlined = function MinusSquareOutlined(props, ref) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__[\"default\"], Object.assign({}, props, {\n    ref: ref,\n    icon: _ant_design_icons_svg_es_asn_MinusSquareOutlined__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n  }));\n};\n\nMinusSquareOutlined.displayName = 'MinusSquareOutlined';\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(MinusSquareOutlined));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvTWludXNTcXVhcmVPdXRsaW5lZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9AYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9NaW51c1NxdWFyZU91dGxpbmVkLmpzPzgxNDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR0VORVJBVEUgQlkgLi9zY3JpcHRzL2dlbmVyYXRlLnRzXG4vLyBET04gTk9UIEVESVQgSVQgTUFOVUFMTFlcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBNaW51c1NxdWFyZU91dGxpbmVkU3ZnIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy1zdmcvZXMvYXNuL01pbnVzU3F1YXJlT3V0bGluZWRcIjtcbmltcG9ydCBBbnRkSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0FudGRJY29uJztcblxudmFyIE1pbnVzU3F1YXJlT3V0bGluZWQgPSBmdW5jdGlvbiBNaW51c1NxdWFyZU91dGxpbmVkKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgcmVmOiByZWYsXG4gICAgaWNvbjogTWludXNTcXVhcmVPdXRsaW5lZFN2Z1xuICB9KSk7XG59O1xuXG5NaW51c1NxdWFyZU91dGxpbmVkLmRpc3BsYXlOYW1lID0gJ01pbnVzU3F1YXJlT3V0bGluZWQnO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QuZm9yd2FyZFJlZihNaW51c1NxdWFyZU91dGxpbmVkKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js\n");

/***/ }),

/***/ "./node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _ant_design_icons_svg_es_asn_PlusSquareOutlined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons-svg/es/asn/PlusSquareOutlined */ \"./node_modules/@ant-design/icons-svg/es/asn/PlusSquareOutlined.js\");\n/* harmony import */ var _components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/AntdIcon */ \"./node_modules/@ant-design/icons/es/components/AntdIcon.js\");\n// GENERATE BY ./scripts/generate.ts\n// DON NOT EDIT IT MANUALLY\n\n\n\n\nvar PlusSquareOutlined = function PlusSquareOutlined(props, ref) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__[\"default\"], Object.assign({}, props, {\n    ref: ref,\n    icon: _ant_design_icons_svg_es_asn_PlusSquareOutlined__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n  }));\n};\n\nPlusSquareOutlined.displayName = 'PlusSquareOutlined';\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(PlusSquareOutlined));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvUGx1c1NxdWFyZU91dGxpbmVkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL0BhbnQtZGVzaWduL2ljb25zL2VzL2ljb25zL1BsdXNTcXVhcmVPdXRsaW5lZC5qcz9jNDY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdFTkVSQVRFIEJZIC4vc2NyaXB0cy9nZW5lcmF0ZS50c1xuLy8gRE9OIE5PVCBFRElUIElUIE1BTlVBTExZXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUGx1c1NxdWFyZU91dGxpbmVkU3ZnIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy1zdmcvZXMvYXNuL1BsdXNTcXVhcmVPdXRsaW5lZFwiO1xuaW1wb3J0IEFudGRJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvQW50ZEljb24nO1xuXG52YXIgUGx1c1NxdWFyZU91dGxpbmVkID0gZnVuY3Rpb24gUGx1c1NxdWFyZU91dGxpbmVkKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgcmVmOiByZWYsXG4gICAgaWNvbjogUGx1c1NxdWFyZU91dGxpbmVkU3ZnXG4gIH0pKTtcbn07XG5cblBsdXNTcXVhcmVPdXRsaW5lZC5kaXNwbGF5TmFtZSA9ICdQbHVzU3F1YXJlT3V0bGluZWQnO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QuZm9yd2FyZFJlZihQbHVzU3F1YXJlT3V0bGluZWQpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js\n");

/***/ }),

/***/ "./plugins/plugin-chart-pivot-table/src/react-pivottable/PivotTable.jsx":
/*!******************************************************************************!*\
  !*** ./plugins/plugin-chart-pivot-table/src/react-pivottable/PivotTable.jsx ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _TableRenderers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TableRenderers */ \"./plugins/plugin-chart-pivot-table/src/react-pivottable/TableRenderers.jsx\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\n\nclass PivotTable extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n  render() {\n    return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_1__.jsx)(_TableRenderers__WEBPACK_IMPORTED_MODULE_2__.TableRenderer, this.props);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\nPivotTable.propTypes = _TableRenderers__WEBPACK_IMPORTED_MODULE_2__.TableRenderer.propTypes;\nPivotTable.defaultProps = _TableRenderers__WEBPACK_IMPORTED_MODULE_2__.TableRenderer.defaultProps;const _default =\n\nPivotTable;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(PivotTable, \"PivotTable\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/PivotTable.jsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/PivotTable.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9zcmMvcmVhY3QtcGl2b3R0YWJsZS9QaXZvdFRhYmxlLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBTUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGx1Z2lucy9wbHVnaW4tY2hhcnQtcGl2b3QtdGFibGUvc3JjL3JlYWN0LXBpdm90dGFibGUvUGl2b3RUYWJsZS5qc3g/OWY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgVGFibGVSZW5kZXJlciB9IGZyb20gJy4vVGFibGVSZW5kZXJlcnMnO1xyXG5cclxuY2xhc3MgUGl2b3RUYWJsZSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xyXG4gIHJlbmRlcigpIHtcclxuICAgIHJldHVybiA8VGFibGVSZW5kZXJlciB7Li4udGhpcy5wcm9wc30gLz47XHJcbiAgfVxyXG59XHJcblxyXG5QaXZvdFRhYmxlLnByb3BUeXBlcyA9IFRhYmxlUmVuZGVyZXIucHJvcFR5cGVzO1xyXG5QaXZvdFRhYmxlLmRlZmF1bHRQcm9wcyA9IFRhYmxlUmVuZGVyZXIuZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGl2b3RUYWJsZTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/plugin-chart-pivot-table/src/react-pivottable/PivotTable.jsx\n");

/***/ }),

/***/ "./plugins/plugin-chart-pivot-table/src/react-pivottable/Styles.js":
/*!*************************************************************************!*\
  !*** ./plugins/plugin-chart-pivot-table/src/react-pivottable/Styles.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Styles\": () => (/* binding */ Styles)\n/* harmony export */ });\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\nconst Styles = _superset_ui_core__WEBPACK_IMPORTED_MODULE_0__.styled.div`\n  ${(_ref) => {let { theme, isDashboardEditMode } = _ref;return _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__.css`\n    table.pvtTable {\n      position: ${isDashboardEditMode ? 'inherit' : 'relative'};\n      font-size: ${theme.typography.sizes.s}px;\n      text-align: left;\n      margin: ${theme.gridUnit}px;\n      border-collapse: separate;\n      font-family: ${theme.typography.families.sansSerif};\n      line-height: 1.4;\n    }\n\n    table thead {\n      position: ${isDashboardEditMode ? 'inherit' : 'sticky'};\n      top: 0;\n    }\n\n    table tbody tr {\n      font-feature-settings: 'tnum' 1;\n    }\n\n    table.pvtTable thead tr th,\n    table.pvtTable tbody tr th {\n      background-color: ${theme.colors.grayscale.light5};\n      border-top: 1px solid ${theme.colors.grayscale.light2};\n      border-left: 1px solid ${theme.colors.grayscale.light2};\n      font-size: ${theme.typography.sizes.s}px;\n      padding: ${theme.gridUnit}px;\n      font-weight: ${theme.typography.weights.normal};\n    }\n\n    table.pvtTable tbody tr.pvtRowTotals {\n      position: ${isDashboardEditMode ? 'inherit' : 'sticky'};\n      bottom: 0;\n    }\n\n    table.pvtTable thead tr:last-of-type th,\n    table.pvtTable thead tr:first-of-type th.pvtTotalLabel,\n    table.pvtTable thead tr:nth-last-of-type(2) th.pvtColLabel,\n    table.pvtTable thead th.pvtSubtotalLabel,\n    table.pvtTable tbody tr:last-of-type th,\n    table.pvtTable tbody tr:last-of-type td {\n      border-bottom: 1px solid ${theme.colors.grayscale.light2};\n    }\n\n    table.pvtTable\n      thead\n      tr:last-of-type:not(:only-child)\n      th.pvtAxisLabel\n      ~ th.pvtColLabel,\n    table.pvtTable tbody tr:first-of-type th,\n    table.pvtTable tbody tr:first-of-type td {\n      border-top: none;\n    }\n\n    table.pvtTable tbody tr td:last-of-type,\n    table.pvtTable thead tr th:last-of-type:not(.pvtSubtotalLabel) {\n      border-right: 1px solid ${theme.colors.grayscale.light2};\n    }\n\n    table.pvtTable\n      thead\n      tr:last-of-type:not(:only-child)\n      th.pvtAxisLabel\n      + .pvtTotalLabel {\n      border-right: none;\n    }\n\n    table.pvtTable tr th.active {\n      background-color: ${theme.colors.primary.light3};\n    }\n\n    table.pvtTable .pvtTotalLabel {\n      text-align: right;\n      font-weight: ${theme.typography.weights.bold};\n    }\n\n    table.pvtTable .pvtSubtotalLabel {\n      font-weight: ${theme.typography.weights.bold};\n    }\n\n    table.pvtTable tbody tr td {\n      color: ${theme.colors.primary.dark2};\n      padding: ${theme.gridUnit}px;\n      background-color: ${theme.colors.grayscale.light5};\n      border-top: 1px solid ${theme.colors.grayscale.light2};\n      border-left: 1px solid ${theme.colors.grayscale.light2};\n      vertical-align: top;\n      text-align: right;\n    }\n\n    table.pvtTable tbody tr th.pvtRowLabel {\n      vertical-align: baseline;\n    }\n\n    .pvtTotal,\n    .pvtGrandTotal {\n      font-weight: ${theme.typography.weights.bold};\n    }\n\n    table.pvtTable tbody tr td.pvtRowTotal {\n      vertical-align: middle;\n    }\n\n    .toggle-wrapper {\n      white-space: nowrap;\n    }\n\n    .toggle-wrapper > .toggle-val {\n      white-space: normal;\n    }\n\n    .toggle {\n      padding-right: ${theme.gridUnit}px;\n      cursor: pointer;\n    }\n\n    .hoverable:hover {\n      background-color: ${theme.colors.primary.light4};\n      cursor: pointer;\n    }\n  `;}}\n`;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Styles, \"Styles\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/Styles.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9zcmMvcmVhY3QtcGl2b3R0YWJsZS9TdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGx1Z2lucy9wbHVnaW4tY2hhcnQtcGl2b3QtdGFibGUvc3JjL3JlYWN0LXBpdm90dGFibGUvU3R5bGVzLmpzPzA4YWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGNzcywgc3R5bGVkIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFN0eWxlcyA9IHN0eWxlZC5kaXZgXHJcbiAgJHsoeyB0aGVtZSwgaXNEYXNoYm9hcmRFZGl0TW9kZSB9KSA9PiBjc3NgXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB7XHJcbiAgICAgIHBvc2l0aW9uOiAke2lzRGFzaGJvYXJkRWRpdE1vZGUgPyAnaW5oZXJpdCcgOiAncmVsYXRpdmUnfTtcclxuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcclxuICAgICAgdGV4dC1hbGlnbjogbGVmdDtcclxuICAgICAgbWFyZ2luOiAke3RoZW1lLmdyaWRVbml0fXB4O1xyXG4gICAgICBib3JkZXItY29sbGFwc2U6IHNlcGFyYXRlO1xyXG4gICAgICBmb250LWZhbWlseTogJHt0aGVtZS50eXBvZ3JhcGh5LmZhbWlsaWVzLnNhbnNTZXJpZn07XHJcbiAgICAgIGxpbmUtaGVpZ2h0OiAxLjQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGFibGUgdGhlYWQge1xyXG4gICAgICBwb3NpdGlvbjogJHtpc0Rhc2hib2FyZEVkaXRNb2RlID8gJ2luaGVyaXQnIDogJ3N0aWNreSd9O1xyXG4gICAgICB0b3A6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGFibGUgdGJvZHkgdHIge1xyXG4gICAgICBmb250LWZlYXR1cmUtc2V0dGluZ3M6ICd0bnVtJyAxO1xyXG4gICAgfVxyXG5cclxuICAgIHRhYmxlLnB2dFRhYmxlIHRoZWFkIHRyIHRoLFxyXG4gICAgdGFibGUucHZ0VGFibGUgdGJvZHkgdHIgdGgge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1fTtcclxuICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDJ9O1xyXG4gICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDJ9O1xyXG4gICAgICBmb250LXNpemU6ICR7dGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xyXG4gICAgICBwYWRkaW5nOiAke3RoZW1lLmdyaWRVbml0fXB4O1xyXG4gICAgICBmb250LXdlaWdodDogJHt0aGVtZS50eXBvZ3JhcGh5LndlaWdodHMubm9ybWFsfTtcclxuICAgIH1cclxuXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB0Ym9keSB0ci5wdnRSb3dUb3RhbHMge1xyXG4gICAgICBwb3NpdGlvbjogJHtpc0Rhc2hib2FyZEVkaXRNb2RlID8gJ2luaGVyaXQnIDogJ3N0aWNreSd9O1xyXG4gICAgICBib3R0b206IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGFibGUucHZ0VGFibGUgdGhlYWQgdHI6bGFzdC1vZi10eXBlIHRoLFxyXG4gICAgdGFibGUucHZ0VGFibGUgdGhlYWQgdHI6Zmlyc3Qtb2YtdHlwZSB0aC5wdnRUb3RhbExhYmVsLFxyXG4gICAgdGFibGUucHZ0VGFibGUgdGhlYWQgdHI6bnRoLWxhc3Qtb2YtdHlwZSgyKSB0aC5wdnRDb2xMYWJlbCxcclxuICAgIHRhYmxlLnB2dFRhYmxlIHRoZWFkIHRoLnB2dFN1YnRvdGFsTGFiZWwsXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB0Ym9keSB0cjpsYXN0LW9mLXR5cGUgdGgsXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB0Ym9keSB0cjpsYXN0LW9mLXR5cGUgdGQge1xyXG4gICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0Mn07XHJcbiAgICB9XHJcblxyXG4gICAgdGFibGUucHZ0VGFibGVcclxuICAgICAgdGhlYWRcclxuICAgICAgdHI6bGFzdC1vZi10eXBlOm5vdCg6b25seS1jaGlsZClcclxuICAgICAgdGgucHZ0QXhpc0xhYmVsXHJcbiAgICAgIH4gdGgucHZ0Q29sTGFiZWwsXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB0Ym9keSB0cjpmaXJzdC1vZi10eXBlIHRoLFxyXG4gICAgdGFibGUucHZ0VGFibGUgdGJvZHkgdHI6Zmlyc3Qtb2YtdHlwZSB0ZCB7XHJcbiAgICAgIGJvcmRlci10b3A6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgdGFibGUucHZ0VGFibGUgdGJvZHkgdHIgdGQ6bGFzdC1vZi10eXBlLFxyXG4gICAgdGFibGUucHZ0VGFibGUgdGhlYWQgdHIgdGg6bGFzdC1vZi10eXBlOm5vdCgucHZ0U3VidG90YWxMYWJlbCkge1xyXG4gICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQyfTtcclxuICAgIH1cclxuXHJcbiAgICB0YWJsZS5wdnRUYWJsZVxyXG4gICAgICB0aGVhZFxyXG4gICAgICB0cjpsYXN0LW9mLXR5cGU6bm90KDpvbmx5LWNoaWxkKVxyXG4gICAgICB0aC5wdnRBeGlzTGFiZWxcclxuICAgICAgKyAucHZ0VG90YWxMYWJlbCB7XHJcbiAgICAgIGJvcmRlci1yaWdodDogbm9uZTtcclxuICAgIH1cclxuXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB0ciB0aC5hY3RpdmUge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5wcmltYXJ5LmxpZ2h0M307XHJcbiAgICB9XHJcblxyXG4gICAgdGFibGUucHZ0VGFibGUgLnB2dFRvdGFsTGFiZWwge1xyXG4gICAgICB0ZXh0LWFsaWduOiByaWdodDtcclxuICAgICAgZm9udC13ZWlnaHQ6ICR7dGhlbWUudHlwb2dyYXBoeS53ZWlnaHRzLmJvbGR9O1xyXG4gICAgfVxyXG5cclxuICAgIHRhYmxlLnB2dFRhYmxlIC5wdnRTdWJ0b3RhbExhYmVsIHtcclxuICAgICAgZm9udC13ZWlnaHQ6ICR7dGhlbWUudHlwb2dyYXBoeS53ZWlnaHRzLmJvbGR9O1xyXG4gICAgfVxyXG5cclxuICAgIHRhYmxlLnB2dFRhYmxlIHRib2R5IHRyIHRkIHtcclxuICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnByaW1hcnkuZGFyazJ9O1xyXG4gICAgICBwYWRkaW5nOiAke3RoZW1lLmdyaWRVbml0fXB4O1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1fTtcclxuICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDJ9O1xyXG4gICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDJ9O1xyXG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xyXG4gICAgICB0ZXh0LWFsaWduOiByaWdodDtcclxuICAgIH1cclxuXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB0Ym9keSB0ciB0aC5wdnRSb3dMYWJlbCB7XHJcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcclxuICAgIH1cclxuXHJcbiAgICAucHZ0VG90YWwsXHJcbiAgICAucHZ0R3JhbmRUb3RhbCB7XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiAke3RoZW1lLnR5cG9ncmFwaHkud2VpZ2h0cy5ib2xkfTtcclxuICAgIH1cclxuXHJcbiAgICB0YWJsZS5wdnRUYWJsZSB0Ym9keSB0ciB0ZC5wdnRSb3dUb3RhbCB7XHJcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLnRvZ2dsZS13cmFwcGVyIHtcclxuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICAgIH1cclxuXHJcbiAgICAudG9nZ2xlLXdyYXBwZXIgPiAudG9nZ2xlLXZhbCB7XHJcbiAgICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLnRvZ2dsZSB7XHJcbiAgICAgIHBhZGRpbmctcmlnaHQ6ICR7dGhlbWUuZ3JpZFVuaXR9cHg7XHJcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICAuaG92ZXJhYmxlOmhvdmVyIHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMucHJpbWFyeS5saWdodDR9O1xyXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB9XHJcbiAgYH1cclxuYDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/plugin-chart-pivot-table/src/react-pivottable/Styles.js\n");

/***/ }),

/***/ "./plugins/plugin-chart-pivot-table/src/react-pivottable/TableRenderers.jsx":
/*!**********************************************************************************!*\
  !*** ./plugins/plugin-chart-pivot-table/src/react-pivottable/TableRenderers.jsx ***!
  \**********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TableRenderer\": () => (/* binding */ TableRenderer)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/includes */ \"./node_modules/@babel/runtime-corejs3/core-js-stable/instance/includes.js\");\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilities */ \"./plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");\n/* harmony import */ var _Styles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Styles */ \"./plugins/plugin-chart-pivot-table/src/react-pivottable/Styles.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\n\n\n\nconst parseLabel = (value) => {\n  if (typeof value === 'number' || typeof value === 'string') {\n    return value;\n  }\n  return String(value);\n};\n\nfunction displayHeaderCell(\nneedToggle,\nArrowIcon,\nonArrowClick,\nvalue,\nnamesMapping)\n{\n  const name = namesMapping[value] || value;\n  return needToggle ?\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"span\", { className: \"toggle-wrapper\" },\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"span\", {\n    role: \"button\",\n    tabIndex: \"0\",\n    className: \"toggle\",\n    onClick: onArrowClick },\n\n  ArrowIcon),\n\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"span\", { className: \"toggle-val\" }, parseLabel(name))) :\n\n\n  parseLabel(name);\n\n}\n\nclass TableRenderer extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(props) {\n    super(props);\n\n    // We need state to record which entries are collapsed and which aren't.\n    // This is an object with flat-keys indicating if the corresponding rows\n    // should be collapsed.\n    this.state = { collapsedRows: {}, collapsedCols: {} };\n\n    this.clickHeaderHandler = this.clickHeaderHandler.bind(this);\n    this.clickHandler = this.clickHandler.bind(this);\n  }\n\n  getBasePivotSettings() {\n    // One-time extraction of pivot settings that we'll use throughout the render.\n\n    const { props } = this;\n    const colAttrs = props.cols;\n    const rowAttrs = props.rows;\n\n    const tableOptions = {\n      rowTotals: true,\n      colTotals: true,\n      ...props.tableOptions };\n\n    const rowTotals = tableOptions.rowTotals || colAttrs.length === 0;\n    const colTotals = tableOptions.colTotals || rowAttrs.length === 0;\n\n    const namesMapping = props.namesMapping || {};\n    const subtotalOptions = {\n      arrowCollapsed: '\\u25B2',\n      arrowExpanded: '\\u25BC',\n      ...props.subtotalOptions };\n\n\n    const colSubtotalDisplay = {\n      displayOnTop: false,\n      enabled: rowTotals,\n      hideOnExpand: false,\n      ...subtotalOptions.colSubtotalDisplay };\n\n\n    const rowSubtotalDisplay = {\n      displayOnTop: false,\n      enabled: colTotals,\n      hideOnExpand: false,\n      ...subtotalOptions.rowSubtotalDisplay };\n\n\n    const pivotData = new _utilities__WEBPACK_IMPORTED_MODULE_4__.PivotData(props, {\n      rowEnabled: rowSubtotalDisplay.enabled,\n      colEnabled: colSubtotalDisplay.enabled,\n      rowPartialOnTop: rowSubtotalDisplay.displayOnTop,\n      colPartialOnTop: colSubtotalDisplay.displayOnTop });\n\n    const rowKeys = pivotData.getRowKeys();\n    const colKeys = pivotData.getColKeys();\n\n    // Also pre-calculate all the callbacks for cells, etc... This is nice to have to\n    // avoid re-calculations of the call-backs on cell expansions, etc...\n    const cellCallbacks = {};\n    const rowTotalCallbacks = {};\n    const colTotalCallbacks = {};\n    let grandTotalCallback = null;\n    if (tableOptions.clickCallback) {\n      rowKeys.forEach((rowKey) => {\n        const flatRowKey = (0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(rowKey);\n        if (!(flatRowKey in cellCallbacks)) {\n          cellCallbacks[flatRowKey] = {};\n        }\n        colKeys.forEach((colKey) => {\n          cellCallbacks[flatRowKey][(0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(colKey)] = this.clickHandler(\n          pivotData,\n          rowKey,\n          colKey);\n\n        });\n      });\n\n      // Add in totals as well.\n      if (rowTotals) {\n        rowKeys.forEach((rowKey) => {\n          rowTotalCallbacks[(0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(rowKey)] = this.clickHandler(\n          pivotData,\n          rowKey,\n          []);\n\n        });\n      }\n      if (colTotals) {\n        colKeys.forEach((colKey) => {\n          colTotalCallbacks[(0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(colKey)] = this.clickHandler(\n          pivotData,\n          [],\n          colKey);\n\n        });\n      }\n      if (rowTotals && colTotals) {\n        grandTotalCallback = this.clickHandler(pivotData, [], []);\n      }\n    }\n\n    return {\n      pivotData,\n      colAttrs,\n      rowAttrs,\n      colKeys,\n      rowKeys,\n      rowTotals,\n      colTotals,\n      arrowCollapsed: subtotalOptions.arrowCollapsed,\n      arrowExpanded: subtotalOptions.arrowExpanded,\n      colSubtotalDisplay,\n      rowSubtotalDisplay,\n      cellCallbacks,\n      rowTotalCallbacks,\n      colTotalCallbacks,\n      grandTotalCallback,\n      namesMapping };\n\n  }\n\n  clickHandler(pivotData, rowValues, colValues) {\n    const colAttrs = this.props.cols;\n    const rowAttrs = this.props.rows;\n    const value = pivotData.getAggregator(rowValues, colValues).value();\n    const filters = {};\n    const colLimit = Math.min(colAttrs.length, colValues.length);\n    for (let i = 0; i < colLimit; i += 1) {\n      const attr = colAttrs[i];\n      if (colValues[i] !== null) {\n        filters[attr] = colValues[i];\n      }\n    }\n    const rowLimit = Math.min(rowAttrs.length, rowValues.length);\n    for (let i = 0; i < rowLimit; i += 1) {\n      const attr = rowAttrs[i];\n      if (rowValues[i] !== null) {\n        filters[attr] = rowValues[i];\n      }\n    }\n    return (e) =>\n    this.props.tableOptions.clickCallback(e, value, filters, pivotData);\n  }\n\n  clickHeaderHandler(\n  pivotData,\n  values,\n  attrs,\n  attrIdx,\n  callback,\n  isSubtotal,\n  isGrandTotal)\n  {if (isSubtotal === void 0) {isSubtotal = false;}if (isGrandTotal === void 0) {isGrandTotal = false;}\n    const filters = {};\n    for (let i = 0; i <= attrIdx; i += 1) {\n      const attr = attrs[i];\n      filters[attr] = values[i];\n    }\n    return (e) =>\n    callback(\n    e,\n    values[attrIdx],\n    filters,\n    pivotData,\n    isSubtotal,\n    isGrandTotal);\n\n  }\n\n  collapseAttr(rowOrCol, attrIdx, allKeys) {\n    return (e) => {\n      // Collapse an entire attribute.\n      e.stopPropagation();\n      const keyLen = attrIdx + 1;\n      const collapsed = allKeys.filter((k) => k.length === keyLen).map(_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey);\n\n      const updates = {};\n      collapsed.forEach((k) => {\n        updates[k] = true;\n      });\n\n      if (rowOrCol) {\n        this.setState((state) => ({\n          collapsedRows: { ...state.collapsedRows, ...updates } }));\n\n      } else {\n        this.setState((state) => ({\n          collapsedCols: { ...state.collapsedCols, ...updates } }));\n\n      }\n    };\n  }\n\n  expandAttr(rowOrCol, attrIdx, allKeys) {\n    return (e) => {\n      // Expand an entire attribute. This implicitly implies expanding all of the\n      // parents as well. It's a bit inefficient but ah well...\n      e.stopPropagation();\n      const updates = {};\n      allKeys.forEach((k) => {\n        for (let i = 0; i <= attrIdx; i += 1) {\n          updates[(0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(k.slice(0, i + 1))] = false;\n        }\n      });\n\n      if (rowOrCol) {\n        this.setState((state) => ({\n          collapsedRows: { ...state.collapsedRows, ...updates } }));\n\n      } else {\n        this.setState((state) => ({\n          collapsedCols: { ...state.collapsedCols, ...updates } }));\n\n      }\n    };\n  }\n\n  toggleRowKey(flatRowKey) {\n    return (e) => {\n      e.stopPropagation();\n      this.setState((state) => ({\n        collapsedRows: {\n          ...state.collapsedRows,\n          [flatRowKey]: !state.collapsedRows[flatRowKey] } }));\n\n\n    };\n  }\n\n  toggleColKey(flatColKey) {\n    return (e) => {\n      e.stopPropagation();\n      this.setState((state) => ({\n        collapsedCols: {\n          ...state.collapsedCols,\n          [flatColKey]: !state.collapsedCols[flatColKey] } }));\n\n\n    };\n  }\n\n  calcAttrSpans(attrArr, numAttrs) {\n    // Given an array of attribute values (i.e. each element is another array with\n    // the value at every level), compute the spans for every attribute value at\n    // every level. The return value is a nested array of the same shape. It has\n    // -1's for repeated values and the span number otherwise.\n\n    const spans = [];\n    // Index of the last new value\n    const li = Array(numAttrs).map(() => 0);\n    let lv = Array(numAttrs).map(() => null);\n    for (let i = 0; i < attrArr.length; i += 1) {\n      // Keep increasing span values as long as the last keys are the same. For\n      // the rest, record spans of 1. Update the indices too.\n      const cv = attrArr[i];\n      const ent = [];\n      let depth = 0;\n      const limit = Math.min(lv.length, cv.length);\n      while (depth < limit && lv[depth] === cv[depth]) {\n        ent.push(-1);\n        spans[li[depth]][depth] += 1;\n        depth += 1;\n      }\n      while (depth < cv.length) {\n        li[depth] = i;\n        ent.push(1);\n        depth += 1;\n      }\n      spans.push(ent);\n      lv = cv;\n    }\n    return spans;\n  }\n\n  renderColHeaderRow(attrName, attrIdx, pivotSettings) {\n    // Render a single row in the column header at the top of the pivot table.\n\n    const {\n      rowAttrs,\n      colAttrs,\n      colKeys,\n      visibleColKeys,\n      colAttrSpans,\n      rowTotals,\n      arrowExpanded,\n      arrowCollapsed,\n      colSubtotalDisplay,\n      maxColVisible,\n      pivotData,\n      namesMapping } =\n    pivotSettings;\n    const {\n      highlightHeaderCellsOnHover,\n      omittedHighlightHeaderGroups = [],\n      highlightedHeaderCells,\n      dateFormatters } =\n    this.props.tableOptions;\n\n    const spaceCell =\n    attrIdx === 0 && rowAttrs.length !== 0 ?\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n      key: \"padding\",\n      colSpan: rowAttrs.length,\n      rowSpan: colAttrs.length,\n      \"aria-hidden\": \"true\" }) :\n\n    null;\n\n    const needToggle =\n    colSubtotalDisplay.enabled && attrIdx !== colAttrs.length - 1;\n    let arrowClickHandle = null;\n    let subArrow = null;\n    if (needToggle) {\n      arrowClickHandle =\n      attrIdx + 1 < maxColVisible ?\n      this.collapseAttr(false, attrIdx, colKeys) :\n      this.expandAttr(false, attrIdx, colKeys);\n      subArrow = attrIdx + 1 < maxColVisible ? arrowExpanded : arrowCollapsed;\n    }\n    const attrNameCell =\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", { key: \"label\", className: \"pvtAxisLabel\" },\n    displayHeaderCell(\n    needToggle,\n    subArrow,\n    arrowClickHandle,\n    attrName,\n    namesMapping));\n\n\n\n\n    const attrValueCells = [];\n    const rowIncrSpan = rowAttrs.length !== 0 ? 1 : 0;\n    // Iterate through columns. Jump over duplicate values.\n    let i = 0;\n    while (i < visibleColKeys.length) {\n      const colKey = visibleColKeys[i];\n      const colSpan = attrIdx < colKey.length ? colAttrSpans[i][attrIdx] : 1;\n      let colLabelClass = 'pvtColLabel';\n      if (attrIdx < colKey.length) {var _context;\n        if (\n        highlightHeaderCellsOnHover &&\n        !_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(omittedHighlightHeaderGroups).call(omittedHighlightHeaderGroups, colAttrs[attrIdx]))\n        {\n          colLabelClass += ' hoverable';\n        }\n        if (\n        highlightedHeaderCells &&\n        Array.isArray(highlightedHeaderCells[colAttrs[attrIdx]]) &&\n        _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(_context = highlightedHeaderCells[colAttrs[attrIdx]]).call(_context, colKey[attrIdx]))\n        {\n          colLabelClass += ' active';\n        }\n\n        const rowSpan = 1 + (attrIdx === colAttrs.length - 1 ? rowIncrSpan : 0);\n        const flatColKey = (0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(colKey.slice(0, attrIdx + 1));\n        const onArrowClick = needToggle ? this.toggleColKey(flatColKey) : null;\n\n        const headerCellFormattedValue =\n        dateFormatters &&\n        dateFormatters[attrName] &&\n        typeof dateFormatters[attrName] === 'function' ?\n        dateFormatters[attrName](colKey[attrIdx]) :\n        colKey[attrIdx];\n        attrValueCells.push(\n        (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n          className: colLabelClass,\n          key: `colKey-${flatColKey}`,\n          colSpan: colSpan,\n          rowSpan: rowSpan,\n          onClick: this.clickHeaderHandler(\n          pivotData,\n          colKey,\n          this.props.cols,\n          attrIdx,\n          this.props.tableOptions.clickColumnHeaderCallback) },\n\n\n        displayHeaderCell(\n        needToggle,\n        this.state.collapsedCols[flatColKey] ?\n        arrowCollapsed :\n        arrowExpanded,\n        onArrowClick,\n        headerCellFormattedValue,\n        namesMapping)));\n\n\n\n      } else if (attrIdx === colKey.length) {\n        const rowSpan = colAttrs.length - colKey.length + rowIncrSpan;\n        attrValueCells.push(\n        (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n          className: `${colLabelClass} pvtSubtotalLabel`,\n          key: `colKeyBuffer-${(0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(colKey)}`,\n          colSpan: colSpan,\n          rowSpan: rowSpan,\n          onClick: this.clickHeaderHandler(\n          pivotData,\n          colKey,\n          this.props.cols,\n          attrIdx,\n          this.props.tableOptions.clickColumnHeaderCallback,\n          true) }, \"Subtotal\"));\n\n\n\n\n\n      }\n      // The next colSpan columns will have the same value anyway...\n      i += colSpan;\n    }\n\n    const totalCell =\n    attrIdx === 0 && rowTotals ?\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n      key: \"total\",\n      className: \"pvtTotalLabel\",\n      rowSpan: colAttrs.length + Math.min(rowAttrs.length, 1),\n      onClick: this.clickHeaderHandler(\n      pivotData,\n      [],\n      this.props.cols,\n      attrIdx,\n      this.props.tableOptions.clickColumnHeaderCallback,\n      false,\n      true) },\n\n\n    `Total (${this.props.aggregatorName})`) :\n\n    null;\n\n    const cells = [spaceCell, attrNameCell, ...attrValueCells, totalCell];\n    return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"tr\", { key: `colAttr-${attrIdx}` }, cells);\n  }\n\n  renderRowHeaderRow(pivotSettings) {\n    // Render just the attribute names of the rows (the actual attribute values\n    // will show up in the individual rows).\n\n    const {\n      rowAttrs,\n      colAttrs,\n      rowKeys,\n      arrowCollapsed,\n      arrowExpanded,\n      rowSubtotalDisplay,\n      maxRowVisible,\n      pivotData,\n      namesMapping } =\n    pivotSettings;\n    return (\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"tr\", { key: \"rowHdr\" },\n      rowAttrs.map((r, i) => {\n        const needLabelToggle =\n        rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;\n        let arrowClickHandle = null;\n        let subArrow = null;\n        if (needLabelToggle) {\n          arrowClickHandle =\n          i + 1 < maxRowVisible ?\n          this.collapseAttr(true, i, rowKeys) :\n          this.expandAttr(true, i, rowKeys);\n          subArrow = i + 1 < maxRowVisible ? arrowExpanded : arrowCollapsed;\n        }\n        return (\n          (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", { className: \"pvtAxisLabel\", key: `rowAttr-${i}` },\n          displayHeaderCell(\n          needLabelToggle,\n          subArrow,\n          arrowClickHandle,\n          r,\n          namesMapping)));\n\n\n\n      }),\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n        className: \"pvtTotalLabel\",\n        key: \"padding\",\n        onClick: this.clickHeaderHandler(\n        pivotData,\n        [],\n        this.props.rows,\n        0,\n        this.props.tableOptions.clickRowHeaderCallback,\n        false,\n        true) },\n\n\n      colAttrs.length === 0 ?\n      `Total (${this.props.aggregatorName})` :\n      null)));\n\n\n\n  }\n\n  renderTableRow(rowKey, rowIdx, pivotSettings) {\n    // Render a single row in the pivot table.\n\n    const {\n      rowAttrs,\n      colAttrs,\n      rowAttrSpans,\n      visibleColKeys,\n      pivotData,\n      rowTotals,\n      rowSubtotalDisplay,\n      arrowExpanded,\n      arrowCollapsed,\n      cellCallbacks,\n      rowTotalCallbacks,\n      namesMapping } =\n    pivotSettings;\n\n    const {\n      highlightHeaderCellsOnHover,\n      omittedHighlightHeaderGroups = [],\n      highlightedHeaderCells,\n      cellColorFormatters,\n      dateFormatters } =\n    this.props.tableOptions;\n    const flatRowKey = (0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(rowKey);\n\n    const colIncrSpan = colAttrs.length !== 0 ? 1 : 0;\n    const attrValueCells = rowKey.map((r, i) => {var _context2;\n      let valueCellClassName = 'pvtRowLabel';\n      if (\n      highlightHeaderCellsOnHover &&\n      !_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(omittedHighlightHeaderGroups).call(omittedHighlightHeaderGroups, rowAttrs[i]))\n      {\n        valueCellClassName += ' hoverable';\n      }\n      if (\n      highlightedHeaderCells &&\n      Array.isArray(highlightedHeaderCells[rowAttrs[i]]) &&\n      _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(_context2 = highlightedHeaderCells[rowAttrs[i]]).call(_context2, r))\n      {\n        valueCellClassName += ' active';\n      }\n      const rowSpan = rowAttrSpans[rowIdx][i];\n      if (rowSpan > 0) {\n        const flatRowKey = (0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(rowKey.slice(0, i + 1));\n        const colSpan = 1 + (i === rowAttrs.length - 1 ? colIncrSpan : 0);\n        const needRowToggle =\n        rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;\n        const onArrowClick = needRowToggle ?\n        this.toggleRowKey(flatRowKey) :\n        null;\n\n        const headerCellFormattedValue =\n        dateFormatters && dateFormatters[rowAttrs[i]] ?\n        dateFormatters[rowAttrs[i]](r) :\n        r;\n        return (\n          (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n            key: `rowKeyLabel-${i}`,\n            className: valueCellClassName,\n            rowSpan: rowSpan,\n            colSpan: colSpan,\n            onClick: this.clickHeaderHandler(\n            pivotData,\n            rowKey,\n            this.props.rows,\n            i,\n            this.props.tableOptions.clickRowHeaderCallback) },\n\n\n          displayHeaderCell(\n          needRowToggle,\n          this.state.collapsedRows[flatRowKey] ?\n          arrowCollapsed :\n          arrowExpanded,\n          onArrowClick,\n          headerCellFormattedValue,\n          namesMapping)));\n\n\n\n      }\n      return null;\n    });\n\n    const attrValuePaddingCell =\n    rowKey.length < rowAttrs.length ?\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n      className: \"pvtRowLabel pvtSubtotalLabel\",\n      key: \"rowKeyBuffer\",\n      colSpan: rowAttrs.length - rowKey.length + colIncrSpan,\n      rowSpan: 1,\n      onClick: this.clickHeaderHandler(\n      pivotData,\n      rowKey,\n      this.props.rows,\n      rowKey.length,\n      this.props.tableOptions.clickRowHeaderCallback,\n      true) }, \"Subtotal\") :\n\n\n\n\n    null;\n\n    const rowClickHandlers = cellCallbacks[flatRowKey] || {};\n    const valueCells = visibleColKeys.map((colKey) => {\n      const flatColKey = (0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(colKey);\n      const agg = pivotData.getAggregator(rowKey, colKey);\n      const aggValue = agg.value();\n\n      const keys = [...rowKey, ...colKey];\n      let backgroundColor;\n      if (cellColorFormatters) {\n        Object.values(cellColorFormatters).forEach((cellColorFormatter) => {\n          if (Array.isArray(cellColorFormatter)) {\n            keys.forEach((key) => {\n              if (backgroundColor) {\n                return;\n              }\n              cellColorFormatter.\n              filter((formatter) => formatter.column === key).\n              forEach((formatter) => {\n                const formatterResult = formatter.getColorFromValue(aggValue);\n                if (formatterResult) {\n                  backgroundColor = formatterResult;\n                }\n              });\n            });\n          }\n        });\n      }\n\n      const style = agg.isSubtotal ?\n      { fontWeight: 'bold' } :\n      { backgroundColor };\n\n      return (\n        (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n          role: \"gridcell\",\n          className: \"pvtVal\",\n          key: `pvtVal-${flatColKey}`,\n          onClick: rowClickHandlers[flatColKey],\n          onContextMenu: (e) => this.props.onContextMenu(e, colKey, rowKey),\n          style: style },\n\n        agg.format(aggValue)));\n\n\n    });\n\n    let totalCell = null;\n    if (rowTotals) {\n      const agg = pivotData.getAggregator(rowKey, []);\n      const aggValue = agg.value();\n      totalCell =\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n        role: \"gridcell\",\n        key: \"total\",\n        className: \"pvtTotal\",\n        onClick: rowTotalCallbacks[flatRowKey],\n        onContextMenu: (e) => this.props.onContextMenu(e, undefined, rowKey) },\n\n      agg.format(aggValue));\n\n\n    }\n\n    const rowCells = [\n    ...attrValueCells,\n    attrValuePaddingCell,\n    ...valueCells,\n    totalCell];\n\n\n    return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"tr\", { key: `keyRow-${flatRowKey}` }, rowCells);\n  }\n\n  renderTotalsRow(pivotSettings) {\n    // Render the final totals rows that has the totals for all the columns.\n\n    const {\n      rowAttrs,\n      colAttrs,\n      visibleColKeys,\n      rowTotals,\n      pivotData,\n      colTotalCallbacks,\n      grandTotalCallback } =\n    pivotSettings;\n\n    const totalLabelCell =\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"th\", {\n      key: \"label\",\n      className: \"pvtTotalLabel pvtRowTotalLabel\",\n      colSpan: rowAttrs.length + Math.min(colAttrs.length, 1),\n      onClick: this.clickHeaderHandler(\n      pivotData,\n      [],\n      this.props.rows,\n      0,\n      this.props.tableOptions.clickRowHeaderCallback,\n      false,\n      true) },\n\n\n    `Total (${this.props.aggregatorName})`);\n\n\n\n    const totalValueCells = visibleColKeys.map((colKey) => {\n      const flatColKey = (0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(colKey);\n      const agg = pivotData.getAggregator([], colKey);\n      const aggValue = agg.value();\n\n      return (\n        (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n          role: \"gridcell\",\n          className: \"pvtTotal pvtRowTotal\",\n          key: `total-${flatColKey}`,\n          onClick: colTotalCallbacks[flatColKey],\n          onContextMenu: (e) => this.props.onContextMenu(e, colKey, undefined),\n          style: { padding: '5px' } },\n\n        agg.format(aggValue)));\n\n\n    });\n\n    let grandTotalCell = null;\n    if (rowTotals) {\n      const agg = pivotData.getAggregator([], []);\n      const aggValue = agg.value();\n      grandTotalCell =\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"td\", {\n        role: \"gridcell\",\n        key: \"total\",\n        className: \"pvtGrandTotal pvtRowTotal\",\n        onClick: grandTotalCallback,\n        onContextMenu: (e) => this.props.onContextMenu(e, undefined, undefined) },\n\n      agg.format(aggValue));\n\n\n    }\n\n    const totalCells = [totalLabelCell, ...totalValueCells, grandTotalCell];\n\n    return (\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"tr\", { key: \"total\", className: \"pvtRowTotals\" },\n      totalCells));\n\n\n  }\n\n  visibleKeys(keys, collapsed, numAttrs, subtotalDisplay) {\n    return keys.filter(\n    (key) =>\n    // Is the key hidden by one of its parents?\n    !key.some((k, j) => collapsed[(0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(key.slice(0, j))]) && (\n    // Leaf key.\n    key.length === numAttrs ||\n    // Children hidden. Must show total.\n    (0,_utilities__WEBPACK_IMPORTED_MODULE_4__.flatKey)(key) in collapsed ||\n    // Don't hide totals.\n    !subtotalDisplay.hideOnExpand));\n\n  }\n\n  isDashboardEditMode() {\n    return document.contains(document.querySelector('.dashboard--editing'));\n  }\n\n  render() {\n    if (this.cachedProps !== this.props) {\n      this.cachedProps = this.props;\n      this.cachedBasePivotSettings = this.getBasePivotSettings();\n    }\n    const {\n      colAttrs,\n      rowAttrs,\n      rowKeys,\n      colKeys,\n      colTotals,\n      rowSubtotalDisplay,\n      colSubtotalDisplay } =\n    this.cachedBasePivotSettings;\n\n    // Need to account for exclusions to compute the effective row\n    // and column keys.\n    const visibleRowKeys = this.visibleKeys(\n    rowKeys,\n    this.state.collapsedRows,\n    rowAttrs.length,\n    rowSubtotalDisplay);\n\n    const visibleColKeys = this.visibleKeys(\n    colKeys,\n    this.state.collapsedCols,\n    colAttrs.length,\n    colSubtotalDisplay);\n\n\n    const pivotSettings = {\n      visibleRowKeys,\n      maxRowVisible: Math.max(...visibleRowKeys.map((k) => k.length)),\n      visibleColKeys,\n      maxColVisible: Math.max(...visibleColKeys.map((k) => k.length)),\n      rowAttrSpans: this.calcAttrSpans(visibleRowKeys, rowAttrs.length),\n      colAttrSpans: this.calcAttrSpans(visibleColKeys, colAttrs.length),\n      ...this.cachedBasePivotSettings };\n\n\n    return (\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(_Styles__WEBPACK_IMPORTED_MODULE_5__.Styles, { isDashboardEditMode: this.isDashboardEditMode() },\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"table\", { className: \"pvtTable\", role: \"grid\" },\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"thead\", null,\n      colAttrs.map((c, j) =>\n      this.renderColHeaderRow(c, j, pivotSettings)),\n\n      rowAttrs.length !== 0 && this.renderRowHeaderRow(pivotSettings)),\n\n      (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"tbody\", null,\n      visibleRowKeys.map((r, i) =>\n      this.renderTableRow(r, i, pivotSettings)),\n\n      colTotals && this.renderTotalsRow(pivotSettings)))));\n\n\n\n\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\nTableRenderer.propTypes = {\n  ..._utilities__WEBPACK_IMPORTED_MODULE_4__.PivotData.propTypes,\n  tableOptions: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object),\n  onContextMenu: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func) };\n\nTableRenderer.defaultProps = { ..._utilities__WEBPACK_IMPORTED_MODULE_4__.PivotData.defaultProps, tableOptions: {} };;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(parseLabel, \"parseLabel\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/TableRenderers.jsx\");reactHotLoader.register(displayHeaderCell, \"displayHeaderCell\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/TableRenderers.jsx\");reactHotLoader.register(TableRenderer, \"TableRenderer\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/TableRenderers.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9zcmMvcmVhY3QtcGl2b3R0YWJsZS9UYWJsZVJlbmRlcmVycy5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQWwwQkE7QUFBQTtBQXEwQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXBpdm90LXRhYmxlL3NyYy9yZWFjdC1waXZvdHRhYmxlL1RhYmxlUmVuZGVyZXJzLmpzeD80NzZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgeyBQaXZvdERhdGEsIGZsYXRLZXkgfSBmcm9tICcuL3V0aWxpdGllcyc7XHJcbmltcG9ydCB7IFN0eWxlcyB9IGZyb20gJy4vU3R5bGVzJztcclxuXHJcbmNvbnN0IHBhcnNlTGFiZWwgPSB2YWx1ZSA9PiB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGRpc3BsYXlIZWFkZXJDZWxsKFxyXG4gIG5lZWRUb2dnbGUsXHJcbiAgQXJyb3dJY29uLFxyXG4gIG9uQXJyb3dDbGljayxcclxuICB2YWx1ZSxcclxuICBuYW1lc01hcHBpbmcsXHJcbikge1xyXG4gIGNvbnN0IG5hbWUgPSBuYW1lc01hcHBpbmdbdmFsdWVdIHx8IHZhbHVlO1xyXG4gIHJldHVybiBuZWVkVG9nZ2xlID8gKFxyXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwidG9nZ2xlLXdyYXBwZXJcIj5cclxuICAgICAgPHNwYW5cclxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcclxuICAgICAgICB0YWJJbmRleD1cIjBcIlxyXG4gICAgICAgIGNsYXNzTmFtZT1cInRvZ2dsZVwiXHJcbiAgICAgICAgb25DbGljaz17b25BcnJvd0NsaWNrfVxyXG4gICAgICA+XHJcbiAgICAgICAge0Fycm93SWNvbn1cclxuICAgICAgPC9zcGFuPlxyXG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0b2dnbGUtdmFsXCI+e3BhcnNlTGFiZWwobmFtZSl9PC9zcGFuPlxyXG4gICAgPC9zcGFuPlxyXG4gICkgOiAoXHJcbiAgICBwYXJzZUxhYmVsKG5hbWUpXHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRhYmxlUmVuZGVyZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgLy8gV2UgbmVlZCBzdGF0ZSB0byByZWNvcmQgd2hpY2ggZW50cmllcyBhcmUgY29sbGFwc2VkIGFuZCB3aGljaCBhcmVuJ3QuXHJcbiAgICAvLyBUaGlzIGlzIGFuIG9iamVjdCB3aXRoIGZsYXQta2V5cyBpbmRpY2F0aW5nIGlmIHRoZSBjb3JyZXNwb25kaW5nIHJvd3NcclxuICAgIC8vIHNob3VsZCBiZSBjb2xsYXBzZWQuXHJcbiAgICB0aGlzLnN0YXRlID0geyBjb2xsYXBzZWRSb3dzOiB7fSwgY29sbGFwc2VkQ29sczoge30gfTtcclxuXHJcbiAgICB0aGlzLmNsaWNrSGVhZGVySGFuZGxlciA9IHRoaXMuY2xpY2tIZWFkZXJIYW5kbGVyLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmNsaWNrSGFuZGxlciA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBnZXRCYXNlUGl2b3RTZXR0aW5ncygpIHtcclxuICAgIC8vIE9uZS10aW1lIGV4dHJhY3Rpb24gb2YgcGl2b3Qgc2V0dGluZ3MgdGhhdCB3ZSdsbCB1c2UgdGhyb3VnaG91dCB0aGUgcmVuZGVyLlxyXG5cclxuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBjb2xBdHRycyA9IHByb3BzLmNvbHM7XHJcbiAgICBjb25zdCByb3dBdHRycyA9IHByb3BzLnJvd3M7XHJcblxyXG4gICAgY29uc3QgdGFibGVPcHRpb25zID0ge1xyXG4gICAgICByb3dUb3RhbHM6IHRydWUsXHJcbiAgICAgIGNvbFRvdGFsczogdHJ1ZSxcclxuICAgICAgLi4ucHJvcHMudGFibGVPcHRpb25zLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJvd1RvdGFscyA9IHRhYmxlT3B0aW9ucy5yb3dUb3RhbHMgfHwgY29sQXR0cnMubGVuZ3RoID09PSAwO1xyXG4gICAgY29uc3QgY29sVG90YWxzID0gdGFibGVPcHRpb25zLmNvbFRvdGFscyB8fCByb3dBdHRycy5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgY29uc3QgbmFtZXNNYXBwaW5nID0gcHJvcHMubmFtZXNNYXBwaW5nIHx8IHt9O1xyXG4gICAgY29uc3Qgc3VidG90YWxPcHRpb25zID0ge1xyXG4gICAgICBhcnJvd0NvbGxhcHNlZDogJ1xcdTI1QjInLFxyXG4gICAgICBhcnJvd0V4cGFuZGVkOiAnXFx1MjVCQycsXHJcbiAgICAgIC4uLnByb3BzLnN1YnRvdGFsT3B0aW9ucyxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY29sU3VidG90YWxEaXNwbGF5ID0ge1xyXG4gICAgICBkaXNwbGF5T25Ub3A6IGZhbHNlLFxyXG4gICAgICBlbmFibGVkOiByb3dUb3RhbHMsXHJcbiAgICAgIGhpZGVPbkV4cGFuZDogZmFsc2UsXHJcbiAgICAgIC4uLnN1YnRvdGFsT3B0aW9ucy5jb2xTdWJ0b3RhbERpc3BsYXksXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHJvd1N1YnRvdGFsRGlzcGxheSA9IHtcclxuICAgICAgZGlzcGxheU9uVG9wOiBmYWxzZSxcclxuICAgICAgZW5hYmxlZDogY29sVG90YWxzLFxyXG4gICAgICBoaWRlT25FeHBhbmQ6IGZhbHNlLFxyXG4gICAgICAuLi5zdWJ0b3RhbE9wdGlvbnMucm93U3VidG90YWxEaXNwbGF5LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBwaXZvdERhdGEgPSBuZXcgUGl2b3REYXRhKHByb3BzLCB7XHJcbiAgICAgIHJvd0VuYWJsZWQ6IHJvd1N1YnRvdGFsRGlzcGxheS5lbmFibGVkLFxyXG4gICAgICBjb2xFbmFibGVkOiBjb2xTdWJ0b3RhbERpc3BsYXkuZW5hYmxlZCxcclxuICAgICAgcm93UGFydGlhbE9uVG9wOiByb3dTdWJ0b3RhbERpc3BsYXkuZGlzcGxheU9uVG9wLFxyXG4gICAgICBjb2xQYXJ0aWFsT25Ub3A6IGNvbFN1YnRvdGFsRGlzcGxheS5kaXNwbGF5T25Ub3AsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJvd0tleXMgPSBwaXZvdERhdGEuZ2V0Um93S2V5cygpO1xyXG4gICAgY29uc3QgY29sS2V5cyA9IHBpdm90RGF0YS5nZXRDb2xLZXlzKCk7XHJcblxyXG4gICAgLy8gQWxzbyBwcmUtY2FsY3VsYXRlIGFsbCB0aGUgY2FsbGJhY2tzIGZvciBjZWxscywgZXRjLi4uIFRoaXMgaXMgbmljZSB0byBoYXZlIHRvXHJcbiAgICAvLyBhdm9pZCByZS1jYWxjdWxhdGlvbnMgb2YgdGhlIGNhbGwtYmFja3Mgb24gY2VsbCBleHBhbnNpb25zLCBldGMuLi5cclxuICAgIGNvbnN0IGNlbGxDYWxsYmFja3MgPSB7fTtcclxuICAgIGNvbnN0IHJvd1RvdGFsQ2FsbGJhY2tzID0ge307XHJcbiAgICBjb25zdCBjb2xUb3RhbENhbGxiYWNrcyA9IHt9O1xyXG4gICAgbGV0IGdyYW5kVG90YWxDYWxsYmFjayA9IG51bGw7XHJcbiAgICBpZiAodGFibGVPcHRpb25zLmNsaWNrQ2FsbGJhY2spIHtcclxuICAgICAgcm93S2V5cy5mb3JFYWNoKHJvd0tleSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmxhdFJvd0tleSA9IGZsYXRLZXkocm93S2V5KTtcclxuICAgICAgICBpZiAoIShmbGF0Um93S2V5IGluIGNlbGxDYWxsYmFja3MpKSB7XHJcbiAgICAgICAgICBjZWxsQ2FsbGJhY2tzW2ZsYXRSb3dLZXldID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbEtleXMuZm9yRWFjaChjb2xLZXkgPT4ge1xyXG4gICAgICAgICAgY2VsbENhbGxiYWNrc1tmbGF0Um93S2V5XVtmbGF0S2V5KGNvbEtleSldID0gdGhpcy5jbGlja0hhbmRsZXIoXHJcbiAgICAgICAgICAgIHBpdm90RGF0YSxcclxuICAgICAgICAgICAgcm93S2V5LFxyXG4gICAgICAgICAgICBjb2xLZXksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFkZCBpbiB0b3RhbHMgYXMgd2VsbC5cclxuICAgICAgaWYgKHJvd1RvdGFscykge1xyXG4gICAgICAgIHJvd0tleXMuZm9yRWFjaChyb3dLZXkgPT4ge1xyXG4gICAgICAgICAgcm93VG90YWxDYWxsYmFja3NbZmxhdEtleShyb3dLZXkpXSA9IHRoaXMuY2xpY2tIYW5kbGVyKFxyXG4gICAgICAgICAgICBwaXZvdERhdGEsXHJcbiAgICAgICAgICAgIHJvd0tleSxcclxuICAgICAgICAgICAgW10sXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb2xUb3RhbHMpIHtcclxuICAgICAgICBjb2xLZXlzLmZvckVhY2goY29sS2V5ID0+IHtcclxuICAgICAgICAgIGNvbFRvdGFsQ2FsbGJhY2tzW2ZsYXRLZXkoY29sS2V5KV0gPSB0aGlzLmNsaWNrSGFuZGxlcihcclxuICAgICAgICAgICAgcGl2b3REYXRhLFxyXG4gICAgICAgICAgICBbXSxcclxuICAgICAgICAgICAgY29sS2V5LFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocm93VG90YWxzICYmIGNvbFRvdGFscykge1xyXG4gICAgICAgIGdyYW5kVG90YWxDYWxsYmFjayA9IHRoaXMuY2xpY2tIYW5kbGVyKHBpdm90RGF0YSwgW10sIFtdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBpdm90RGF0YSxcclxuICAgICAgY29sQXR0cnMsXHJcbiAgICAgIHJvd0F0dHJzLFxyXG4gICAgICBjb2xLZXlzLFxyXG4gICAgICByb3dLZXlzLFxyXG4gICAgICByb3dUb3RhbHMsXHJcbiAgICAgIGNvbFRvdGFscyxcclxuICAgICAgYXJyb3dDb2xsYXBzZWQ6IHN1YnRvdGFsT3B0aW9ucy5hcnJvd0NvbGxhcHNlZCxcclxuICAgICAgYXJyb3dFeHBhbmRlZDogc3VidG90YWxPcHRpb25zLmFycm93RXhwYW5kZWQsXHJcbiAgICAgIGNvbFN1YnRvdGFsRGlzcGxheSxcclxuICAgICAgcm93U3VidG90YWxEaXNwbGF5LFxyXG4gICAgICBjZWxsQ2FsbGJhY2tzLFxyXG4gICAgICByb3dUb3RhbENhbGxiYWNrcyxcclxuICAgICAgY29sVG90YWxDYWxsYmFja3MsXHJcbiAgICAgIGdyYW5kVG90YWxDYWxsYmFjayxcclxuICAgICAgbmFtZXNNYXBwaW5nLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNsaWNrSGFuZGxlcihwaXZvdERhdGEsIHJvd1ZhbHVlcywgY29sVmFsdWVzKSB7XHJcbiAgICBjb25zdCBjb2xBdHRycyA9IHRoaXMucHJvcHMuY29scztcclxuICAgIGNvbnN0IHJvd0F0dHJzID0gdGhpcy5wcm9wcy5yb3dzO1xyXG4gICAgY29uc3QgdmFsdWUgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihyb3dWYWx1ZXMsIGNvbFZhbHVlcykudmFsdWUoKTtcclxuICAgIGNvbnN0IGZpbHRlcnMgPSB7fTtcclxuICAgIGNvbnN0IGNvbExpbWl0ID0gTWF0aC5taW4oY29sQXR0cnMubGVuZ3RoLCBjb2xWYWx1ZXMubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sTGltaXQ7IGkgKz0gMSkge1xyXG4gICAgICBjb25zdCBhdHRyID0gY29sQXR0cnNbaV07XHJcbiAgICAgIGlmIChjb2xWYWx1ZXNbaV0gIT09IG51bGwpIHtcclxuICAgICAgICBmaWx0ZXJzW2F0dHJdID0gY29sVmFsdWVzW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByb3dMaW1pdCA9IE1hdGgubWluKHJvd0F0dHJzLmxlbmd0aCwgcm93VmFsdWVzLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0xpbWl0OyBpICs9IDEpIHtcclxuICAgICAgY29uc3QgYXR0ciA9IHJvd0F0dHJzW2ldO1xyXG4gICAgICBpZiAocm93VmFsdWVzW2ldICE9PSBudWxsKSB7XHJcbiAgICAgICAgZmlsdGVyc1thdHRyXSA9IHJvd1ZhbHVlc1tpXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGUgPT5cclxuICAgICAgdGhpcy5wcm9wcy50YWJsZU9wdGlvbnMuY2xpY2tDYWxsYmFjayhlLCB2YWx1ZSwgZmlsdGVycywgcGl2b3REYXRhKTtcclxuICB9XHJcblxyXG4gIGNsaWNrSGVhZGVySGFuZGxlcihcclxuICAgIHBpdm90RGF0YSxcclxuICAgIHZhbHVlcyxcclxuICAgIGF0dHJzLFxyXG4gICAgYXR0cklkeCxcclxuICAgIGNhbGxiYWNrLFxyXG4gICAgaXNTdWJ0b3RhbCA9IGZhbHNlLFxyXG4gICAgaXNHcmFuZFRvdGFsID0gZmFsc2UsXHJcbiAgKSB7XHJcbiAgICBjb25zdCBmaWx0ZXJzID0ge307XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBhdHRySWR4OyBpICs9IDEpIHtcclxuICAgICAgY29uc3QgYXR0ciA9IGF0dHJzW2ldO1xyXG4gICAgICBmaWx0ZXJzW2F0dHJdID0gdmFsdWVzW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGUgPT5cclxuICAgICAgY2FsbGJhY2soXHJcbiAgICAgICAgZSxcclxuICAgICAgICB2YWx1ZXNbYXR0cklkeF0sXHJcbiAgICAgICAgZmlsdGVycyxcclxuICAgICAgICBwaXZvdERhdGEsXHJcbiAgICAgICAgaXNTdWJ0b3RhbCxcclxuICAgICAgICBpc0dyYW5kVG90YWwsXHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICBjb2xsYXBzZUF0dHIocm93T3JDb2wsIGF0dHJJZHgsIGFsbEtleXMpIHtcclxuICAgIHJldHVybiBlID0+IHtcclxuICAgICAgLy8gQ29sbGFwc2UgYW4gZW50aXJlIGF0dHJpYnV0ZS5cclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgY29uc3Qga2V5TGVuID0gYXR0cklkeCArIDE7XHJcbiAgICAgIGNvbnN0IGNvbGxhcHNlZCA9IGFsbEtleXMuZmlsdGVyKGsgPT4gay5sZW5ndGggPT09IGtleUxlbikubWFwKGZsYXRLZXkpO1xyXG5cclxuICAgICAgY29uc3QgdXBkYXRlcyA9IHt9O1xyXG4gICAgICBjb2xsYXBzZWQuZm9yRWFjaChrID0+IHtcclxuICAgICAgICB1cGRhdGVzW2tdID0gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocm93T3JDb2wpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlID0+ICh7XHJcbiAgICAgICAgICBjb2xsYXBzZWRSb3dzOiB7IC4uLnN0YXRlLmNvbGxhcHNlZFJvd3MsIC4uLnVwZGF0ZXMgfSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgY29sbGFwc2VkQ29sczogeyAuLi5zdGF0ZS5jb2xsYXBzZWRDb2xzLCAuLi51cGRhdGVzIH0sXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXhwYW5kQXR0cihyb3dPckNvbCwgYXR0cklkeCwgYWxsS2V5cykge1xyXG4gICAgcmV0dXJuIGUgPT4ge1xyXG4gICAgICAvLyBFeHBhbmQgYW4gZW50aXJlIGF0dHJpYnV0ZS4gVGhpcyBpbXBsaWNpdGx5IGltcGxpZXMgZXhwYW5kaW5nIGFsbCBvZiB0aGVcclxuICAgICAgLy8gcGFyZW50cyBhcyB3ZWxsLiBJdCdzIGEgYml0IGluZWZmaWNpZW50IGJ1dCBhaCB3ZWxsLi4uXHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSB7fTtcclxuICAgICAgYWxsS2V5cy5mb3JFYWNoKGsgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGF0dHJJZHg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgdXBkYXRlc1tmbGF0S2V5KGsuc2xpY2UoMCwgaSArIDEpKV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHJvd09yQ29sKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgY29sbGFwc2VkUm93czogeyAuLi5zdGF0ZS5jb2xsYXBzZWRSb3dzLCAuLi51cGRhdGVzIH0sXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICAgICAgICAgIGNvbGxhcHNlZENvbHM6IHsgLi4uc3RhdGUuY29sbGFwc2VkQ29scywgLi4udXBkYXRlcyB9LFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHRvZ2dsZVJvd0tleShmbGF0Um93S2V5KSB7XHJcbiAgICByZXR1cm4gZSA9PiB7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICAgICAgICBjb2xsYXBzZWRSb3dzOiB7XHJcbiAgICAgICAgICAuLi5zdGF0ZS5jb2xsYXBzZWRSb3dzLFxyXG4gICAgICAgICAgW2ZsYXRSb3dLZXldOiAhc3RhdGUuY29sbGFwc2VkUm93c1tmbGF0Um93S2V5XSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdG9nZ2xlQ29sS2V5KGZsYXRDb2xLZXkpIHtcclxuICAgIHJldHVybiBlID0+IHtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgIGNvbGxhcHNlZENvbHM6IHtcclxuICAgICAgICAgIC4uLnN0YXRlLmNvbGxhcHNlZENvbHMsXHJcbiAgICAgICAgICBbZmxhdENvbEtleV06ICFzdGF0ZS5jb2xsYXBzZWRDb2xzW2ZsYXRDb2xLZXldLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjYWxjQXR0clNwYW5zKGF0dHJBcnIsIG51bUF0dHJzKSB7XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgdmFsdWVzIChpLmUuIGVhY2ggZWxlbWVudCBpcyBhbm90aGVyIGFycmF5IHdpdGhcclxuICAgIC8vIHRoZSB2YWx1ZSBhdCBldmVyeSBsZXZlbCksIGNvbXB1dGUgdGhlIHNwYW5zIGZvciBldmVyeSBhdHRyaWJ1dGUgdmFsdWUgYXRcclxuICAgIC8vIGV2ZXJ5IGxldmVsLiBUaGUgcmV0dXJuIHZhbHVlIGlzIGEgbmVzdGVkIGFycmF5IG9mIHRoZSBzYW1lIHNoYXBlLiBJdCBoYXNcclxuICAgIC8vIC0xJ3MgZm9yIHJlcGVhdGVkIHZhbHVlcyBhbmQgdGhlIHNwYW4gbnVtYmVyIG90aGVyd2lzZS5cclxuXHJcbiAgICBjb25zdCBzcGFucyA9IFtdO1xyXG4gICAgLy8gSW5kZXggb2YgdGhlIGxhc3QgbmV3IHZhbHVlXHJcbiAgICBjb25zdCBsaSA9IEFycmF5KG51bUF0dHJzKS5tYXAoKCkgPT4gMCk7XHJcbiAgICBsZXQgbHYgPSBBcnJheShudW1BdHRycykubWFwKCgpID0+IG51bGwpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyQXJyLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgIC8vIEtlZXAgaW5jcmVhc2luZyBzcGFuIHZhbHVlcyBhcyBsb25nIGFzIHRoZSBsYXN0IGtleXMgYXJlIHRoZSBzYW1lLiBGb3JcclxuICAgICAgLy8gdGhlIHJlc3QsIHJlY29yZCBzcGFucyBvZiAxLiBVcGRhdGUgdGhlIGluZGljZXMgdG9vLlxyXG4gICAgICBjb25zdCBjdiA9IGF0dHJBcnJbaV07XHJcbiAgICAgIGNvbnN0IGVudCA9IFtdO1xyXG4gICAgICBsZXQgZGVwdGggPSAwO1xyXG4gICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKGx2Lmxlbmd0aCwgY3YubGVuZ3RoKTtcclxuICAgICAgd2hpbGUgKGRlcHRoIDwgbGltaXQgJiYgbHZbZGVwdGhdID09PSBjdltkZXB0aF0pIHtcclxuICAgICAgICBlbnQucHVzaCgtMSk7XHJcbiAgICAgICAgc3BhbnNbbGlbZGVwdGhdXVtkZXB0aF0gKz0gMTtcclxuICAgICAgICBkZXB0aCArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChkZXB0aCA8IGN2Lmxlbmd0aCkge1xyXG4gICAgICAgIGxpW2RlcHRoXSA9IGk7XHJcbiAgICAgICAgZW50LnB1c2goMSk7XHJcbiAgICAgICAgZGVwdGggKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBzcGFucy5wdXNoKGVudCk7XHJcbiAgICAgIGx2ID0gY3Y7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3BhbnM7XHJcbiAgfVxyXG5cclxuICByZW5kZXJDb2xIZWFkZXJSb3coYXR0ck5hbWUsIGF0dHJJZHgsIHBpdm90U2V0dGluZ3MpIHtcclxuICAgIC8vIFJlbmRlciBhIHNpbmdsZSByb3cgaW4gdGhlIGNvbHVtbiBoZWFkZXIgYXQgdGhlIHRvcCBvZiB0aGUgcGl2b3QgdGFibGUuXHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICByb3dBdHRycyxcclxuICAgICAgY29sQXR0cnMsXHJcbiAgICAgIGNvbEtleXMsXHJcbiAgICAgIHZpc2libGVDb2xLZXlzLFxyXG4gICAgICBjb2xBdHRyU3BhbnMsXHJcbiAgICAgIHJvd1RvdGFscyxcclxuICAgICAgYXJyb3dFeHBhbmRlZCxcclxuICAgICAgYXJyb3dDb2xsYXBzZWQsXHJcbiAgICAgIGNvbFN1YnRvdGFsRGlzcGxheSxcclxuICAgICAgbWF4Q29sVmlzaWJsZSxcclxuICAgICAgcGl2b3REYXRhLFxyXG4gICAgICBuYW1lc01hcHBpbmcsXHJcbiAgICB9ID0gcGl2b3RTZXR0aW5ncztcclxuICAgIGNvbnN0IHtcclxuICAgICAgaGlnaGxpZ2h0SGVhZGVyQ2VsbHNPbkhvdmVyLFxyXG4gICAgICBvbWl0dGVkSGlnaGxpZ2h0SGVhZGVyR3JvdXBzID0gW10sXHJcbiAgICAgIGhpZ2hsaWdodGVkSGVhZGVyQ2VsbHMsXHJcbiAgICAgIGRhdGVGb3JtYXR0ZXJzLFxyXG4gICAgfSA9IHRoaXMucHJvcHMudGFibGVPcHRpb25zO1xyXG5cclxuICAgIGNvbnN0IHNwYWNlQ2VsbCA9XHJcbiAgICAgIGF0dHJJZHggPT09IDAgJiYgcm93QXR0cnMubGVuZ3RoICE9PSAwID8gKFxyXG4gICAgICAgIDx0aFxyXG4gICAgICAgICAga2V5PVwicGFkZGluZ1wiXHJcbiAgICAgICAgICBjb2xTcGFuPXtyb3dBdHRycy5sZW5ndGh9XHJcbiAgICAgICAgICByb3dTcGFuPXtjb2xBdHRycy5sZW5ndGh9XHJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4gICAgICAgIC8+XHJcbiAgICAgICkgOiBudWxsO1xyXG5cclxuICAgIGNvbnN0IG5lZWRUb2dnbGUgPVxyXG4gICAgICBjb2xTdWJ0b3RhbERpc3BsYXkuZW5hYmxlZCAmJiBhdHRySWR4ICE9PSBjb2xBdHRycy5sZW5ndGggLSAxO1xyXG4gICAgbGV0IGFycm93Q2xpY2tIYW5kbGUgPSBudWxsO1xyXG4gICAgbGV0IHN1YkFycm93ID0gbnVsbDtcclxuICAgIGlmIChuZWVkVG9nZ2xlKSB7XHJcbiAgICAgIGFycm93Q2xpY2tIYW5kbGUgPVxyXG4gICAgICAgIGF0dHJJZHggKyAxIDwgbWF4Q29sVmlzaWJsZVxyXG4gICAgICAgICAgPyB0aGlzLmNvbGxhcHNlQXR0cihmYWxzZSwgYXR0cklkeCwgY29sS2V5cylcclxuICAgICAgICAgIDogdGhpcy5leHBhbmRBdHRyKGZhbHNlLCBhdHRySWR4LCBjb2xLZXlzKTtcclxuICAgICAgc3ViQXJyb3cgPSBhdHRySWR4ICsgMSA8IG1heENvbFZpc2libGUgPyBhcnJvd0V4cGFuZGVkIDogYXJyb3dDb2xsYXBzZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdHRyTmFtZUNlbGwgPSAoXHJcbiAgICAgIDx0aCBrZXk9XCJsYWJlbFwiIGNsYXNzTmFtZT1cInB2dEF4aXNMYWJlbFwiPlxyXG4gICAgICAgIHtkaXNwbGF5SGVhZGVyQ2VsbChcclxuICAgICAgICAgIG5lZWRUb2dnbGUsXHJcbiAgICAgICAgICBzdWJBcnJvdyxcclxuICAgICAgICAgIGFycm93Q2xpY2tIYW5kbGUsXHJcbiAgICAgICAgICBhdHRyTmFtZSxcclxuICAgICAgICAgIG5hbWVzTWFwcGluZyxcclxuICAgICAgICApfVxyXG4gICAgICA8L3RoPlxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBhdHRyVmFsdWVDZWxscyA9IFtdO1xyXG4gICAgY29uc3Qgcm93SW5jclNwYW4gPSByb3dBdHRycy5sZW5ndGggIT09IDAgPyAxIDogMDtcclxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBjb2x1bW5zLiBKdW1wIG92ZXIgZHVwbGljYXRlIHZhbHVlcy5cclxuICAgIGxldCBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgdmlzaWJsZUNvbEtleXMubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGNvbEtleSA9IHZpc2libGVDb2xLZXlzW2ldO1xyXG4gICAgICBjb25zdCBjb2xTcGFuID0gYXR0cklkeCA8IGNvbEtleS5sZW5ndGggPyBjb2xBdHRyU3BhbnNbaV1bYXR0cklkeF0gOiAxO1xyXG4gICAgICBsZXQgY29sTGFiZWxDbGFzcyA9ICdwdnRDb2xMYWJlbCc7XHJcbiAgICAgIGlmIChhdHRySWR4IDwgY29sS2V5Lmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGhpZ2hsaWdodEhlYWRlckNlbGxzT25Ib3ZlciAmJlxyXG4gICAgICAgICAgIW9taXR0ZWRIaWdobGlnaHRIZWFkZXJHcm91cHMuaW5jbHVkZXMoY29sQXR0cnNbYXR0cklkeF0pXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjb2xMYWJlbENsYXNzICs9ICcgaG92ZXJhYmxlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRIZWFkZXJDZWxscyAmJlxyXG4gICAgICAgICAgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlZEhlYWRlckNlbGxzW2NvbEF0dHJzW2F0dHJJZHhdXSkgJiZcclxuICAgICAgICAgIGhpZ2hsaWdodGVkSGVhZGVyQ2VsbHNbY29sQXR0cnNbYXR0cklkeF1dLmluY2x1ZGVzKGNvbEtleVthdHRySWR4XSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbExhYmVsQ2xhc3MgKz0gJyBhY3RpdmUnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgcm93U3BhbiA9IDEgKyAoYXR0cklkeCA9PT0gY29sQXR0cnMubGVuZ3RoIC0gMSA/IHJvd0luY3JTcGFuIDogMCk7XHJcbiAgICAgICAgY29uc3QgZmxhdENvbEtleSA9IGZsYXRLZXkoY29sS2V5LnNsaWNlKDAsIGF0dHJJZHggKyAxKSk7XHJcbiAgICAgICAgY29uc3Qgb25BcnJvd0NsaWNrID0gbmVlZFRvZ2dsZSA/IHRoaXMudG9nZ2xlQ29sS2V5KGZsYXRDb2xLZXkpIDogbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgaGVhZGVyQ2VsbEZvcm1hdHRlZFZhbHVlID1cclxuICAgICAgICAgIGRhdGVGb3JtYXR0ZXJzICYmXHJcbiAgICAgICAgICBkYXRlRm9ybWF0dGVyc1thdHRyTmFtZV0gJiZcclxuICAgICAgICAgIHR5cGVvZiBkYXRlRm9ybWF0dGVyc1thdHRyTmFtZV0gPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgPyBkYXRlRm9ybWF0dGVyc1thdHRyTmFtZV0oY29sS2V5W2F0dHJJZHhdKVxyXG4gICAgICAgICAgICA6IGNvbEtleVthdHRySWR4XTtcclxuICAgICAgICBhdHRyVmFsdWVDZWxscy5wdXNoKFxyXG4gICAgICAgICAgPHRoXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y29sTGFiZWxDbGFzc31cclxuICAgICAgICAgICAga2V5PXtgY29sS2V5LSR7ZmxhdENvbEtleX1gfVxyXG4gICAgICAgICAgICBjb2xTcGFuPXtjb2xTcGFufVxyXG4gICAgICAgICAgICByb3dTcGFuPXtyb3dTcGFufVxyXG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmNsaWNrSGVhZGVySGFuZGxlcihcclxuICAgICAgICAgICAgICBwaXZvdERhdGEsXHJcbiAgICAgICAgICAgICAgY29sS2V5LFxyXG4gICAgICAgICAgICAgIHRoaXMucHJvcHMuY29scyxcclxuICAgICAgICAgICAgICBhdHRySWR4LFxyXG4gICAgICAgICAgICAgIHRoaXMucHJvcHMudGFibGVPcHRpb25zLmNsaWNrQ29sdW1uSGVhZGVyQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIHtkaXNwbGF5SGVhZGVyQ2VsbChcclxuICAgICAgICAgICAgICBuZWVkVG9nZ2xlLFxyXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuY29sbGFwc2VkQ29sc1tmbGF0Q29sS2V5XVxyXG4gICAgICAgICAgICAgICAgPyBhcnJvd0NvbGxhcHNlZFxyXG4gICAgICAgICAgICAgICAgOiBhcnJvd0V4cGFuZGVkLFxyXG4gICAgICAgICAgICAgIG9uQXJyb3dDbGljayxcclxuICAgICAgICAgICAgICBoZWFkZXJDZWxsRm9ybWF0dGVkVmFsdWUsXHJcbiAgICAgICAgICAgICAgbmFtZXNNYXBwaW5nLFxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgPC90aD4sXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChhdHRySWR4ID09PSBjb2xLZXkubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3Qgcm93U3BhbiA9IGNvbEF0dHJzLmxlbmd0aCAtIGNvbEtleS5sZW5ndGggKyByb3dJbmNyU3BhbjtcclxuICAgICAgICBhdHRyVmFsdWVDZWxscy5wdXNoKFxyXG4gICAgICAgICAgPHRoXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7Y29sTGFiZWxDbGFzc30gcHZ0U3VidG90YWxMYWJlbGB9XHJcbiAgICAgICAgICAgIGtleT17YGNvbEtleUJ1ZmZlci0ke2ZsYXRLZXkoY29sS2V5KX1gfVxyXG4gICAgICAgICAgICBjb2xTcGFuPXtjb2xTcGFufVxyXG4gICAgICAgICAgICByb3dTcGFuPXtyb3dTcGFufVxyXG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmNsaWNrSGVhZGVySGFuZGxlcihcclxuICAgICAgICAgICAgICBwaXZvdERhdGEsXHJcbiAgICAgICAgICAgICAgY29sS2V5LFxyXG4gICAgICAgICAgICAgIHRoaXMucHJvcHMuY29scyxcclxuICAgICAgICAgICAgICBhdHRySWR4LFxyXG4gICAgICAgICAgICAgIHRoaXMucHJvcHMudGFibGVPcHRpb25zLmNsaWNrQ29sdW1uSGVhZGVyQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgU3VidG90YWxcclxuICAgICAgICAgIDwvdGg+LFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVGhlIG5leHQgY29sU3BhbiBjb2x1bW5zIHdpbGwgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBhbnl3YXkuLi5cclxuICAgICAgaSArPSBjb2xTcGFuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRvdGFsQ2VsbCA9XHJcbiAgICAgIGF0dHJJZHggPT09IDAgJiYgcm93VG90YWxzID8gKFxyXG4gICAgICAgIDx0aFxyXG4gICAgICAgICAga2V5PVwidG90YWxcIlxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwicHZ0VG90YWxMYWJlbFwiXHJcbiAgICAgICAgICByb3dTcGFuPXtjb2xBdHRycy5sZW5ndGggKyBNYXRoLm1pbihyb3dBdHRycy5sZW5ndGgsIDEpfVxyXG4gICAgICAgICAgb25DbGljaz17dGhpcy5jbGlja0hlYWRlckhhbmRsZXIoXHJcbiAgICAgICAgICAgIHBpdm90RGF0YSxcclxuICAgICAgICAgICAgW10sXHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY29scyxcclxuICAgICAgICAgICAgYXR0cklkeCxcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy50YWJsZU9wdGlvbnMuY2xpY2tDb2x1bW5IZWFkZXJDYWxsYmFjayxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICApfVxyXG4gICAgICAgID5cclxuICAgICAgICAgIHtgVG90YWwgKCR7dGhpcy5wcm9wcy5hZ2dyZWdhdG9yTmFtZX0pYH1cclxuICAgICAgICA8L3RoPlxyXG4gICAgICApIDogbnVsbDtcclxuXHJcbiAgICBjb25zdCBjZWxscyA9IFtzcGFjZUNlbGwsIGF0dHJOYW1lQ2VsbCwgLi4uYXR0clZhbHVlQ2VsbHMsIHRvdGFsQ2VsbF07XHJcbiAgICByZXR1cm4gPHRyIGtleT17YGNvbEF0dHItJHthdHRySWR4fWB9PntjZWxsc308L3RyPjtcclxuICB9XHJcblxyXG4gIHJlbmRlclJvd0hlYWRlclJvdyhwaXZvdFNldHRpbmdzKSB7XHJcbiAgICAvLyBSZW5kZXIganVzdCB0aGUgYXR0cmlidXRlIG5hbWVzIG9mIHRoZSByb3dzICh0aGUgYWN0dWFsIGF0dHJpYnV0ZSB2YWx1ZXNcclxuICAgIC8vIHdpbGwgc2hvdyB1cCBpbiB0aGUgaW5kaXZpZHVhbCByb3dzKS5cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJvd0F0dHJzLFxyXG4gICAgICBjb2xBdHRycyxcclxuICAgICAgcm93S2V5cyxcclxuICAgICAgYXJyb3dDb2xsYXBzZWQsXHJcbiAgICAgIGFycm93RXhwYW5kZWQsXHJcbiAgICAgIHJvd1N1YnRvdGFsRGlzcGxheSxcclxuICAgICAgbWF4Um93VmlzaWJsZSxcclxuICAgICAgcGl2b3REYXRhLFxyXG4gICAgICBuYW1lc01hcHBpbmcsXHJcbiAgICB9ID0gcGl2b3RTZXR0aW5ncztcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDx0ciBrZXk9XCJyb3dIZHJcIj5cclxuICAgICAgICB7cm93QXR0cnMubWFwKChyLCBpKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBuZWVkTGFiZWxUb2dnbGUgPVxyXG4gICAgICAgICAgICByb3dTdWJ0b3RhbERpc3BsYXkuZW5hYmxlZCAmJiBpICE9PSByb3dBdHRycy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgbGV0IGFycm93Q2xpY2tIYW5kbGUgPSBudWxsO1xyXG4gICAgICAgICAgbGV0IHN1YkFycm93ID0gbnVsbDtcclxuICAgICAgICAgIGlmIChuZWVkTGFiZWxUb2dnbGUpIHtcclxuICAgICAgICAgICAgYXJyb3dDbGlja0hhbmRsZSA9XHJcbiAgICAgICAgICAgICAgaSArIDEgPCBtYXhSb3dWaXNpYmxlXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29sbGFwc2VBdHRyKHRydWUsIGksIHJvd0tleXMpXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuZXhwYW5kQXR0cih0cnVlLCBpLCByb3dLZXlzKTtcclxuICAgICAgICAgICAgc3ViQXJyb3cgPSBpICsgMSA8IG1heFJvd1Zpc2libGUgPyBhcnJvd0V4cGFuZGVkIDogYXJyb3dDb2xsYXBzZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwicHZ0QXhpc0xhYmVsXCIga2V5PXtgcm93QXR0ci0ke2l9YH0+XHJcbiAgICAgICAgICAgICAge2Rpc3BsYXlIZWFkZXJDZWxsKFxyXG4gICAgICAgICAgICAgICAgbmVlZExhYmVsVG9nZ2xlLFxyXG4gICAgICAgICAgICAgICAgc3ViQXJyb3csXHJcbiAgICAgICAgICAgICAgICBhcnJvd0NsaWNrSGFuZGxlLFxyXG4gICAgICAgICAgICAgICAgcixcclxuICAgICAgICAgICAgICAgIG5hbWVzTWFwcGluZyxcclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICA8L3RoPlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KX1cclxuICAgICAgICA8dGhcclxuICAgICAgICAgIGNsYXNzTmFtZT1cInB2dFRvdGFsTGFiZWxcIlxyXG4gICAgICAgICAga2V5PVwicGFkZGluZ1wiXHJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLmNsaWNrSGVhZGVySGFuZGxlcihcclxuICAgICAgICAgICAgcGl2b3REYXRhLFxyXG4gICAgICAgICAgICBbXSxcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5yb3dzLFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICB0aGlzLnByb3BzLnRhYmxlT3B0aW9ucy5jbGlja1Jvd0hlYWRlckNhbGxiYWNrLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAge2NvbEF0dHJzLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgICAgICA/IGBUb3RhbCAoJHt0aGlzLnByb3BzLmFnZ3JlZ2F0b3JOYW1lfSlgXHJcbiAgICAgICAgICAgIDogbnVsbH1cclxuICAgICAgICA8L3RoPlxyXG4gICAgICA8L3RyPlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHJlbmRlclRhYmxlUm93KHJvd0tleSwgcm93SWR4LCBwaXZvdFNldHRpbmdzKSB7XHJcbiAgICAvLyBSZW5kZXIgYSBzaW5nbGUgcm93IGluIHRoZSBwaXZvdCB0YWJsZS5cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJvd0F0dHJzLFxyXG4gICAgICBjb2xBdHRycyxcclxuICAgICAgcm93QXR0clNwYW5zLFxyXG4gICAgICB2aXNpYmxlQ29sS2V5cyxcclxuICAgICAgcGl2b3REYXRhLFxyXG4gICAgICByb3dUb3RhbHMsXHJcbiAgICAgIHJvd1N1YnRvdGFsRGlzcGxheSxcclxuICAgICAgYXJyb3dFeHBhbmRlZCxcclxuICAgICAgYXJyb3dDb2xsYXBzZWQsXHJcbiAgICAgIGNlbGxDYWxsYmFja3MsXHJcbiAgICAgIHJvd1RvdGFsQ2FsbGJhY2tzLFxyXG4gICAgICBuYW1lc01hcHBpbmcsXHJcbiAgICB9ID0gcGl2b3RTZXR0aW5ncztcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGhpZ2hsaWdodEhlYWRlckNlbGxzT25Ib3ZlcixcclxuICAgICAgb21pdHRlZEhpZ2hsaWdodEhlYWRlckdyb3VwcyA9IFtdLFxyXG4gICAgICBoaWdobGlnaHRlZEhlYWRlckNlbGxzLFxyXG4gICAgICBjZWxsQ29sb3JGb3JtYXR0ZXJzLFxyXG4gICAgICBkYXRlRm9ybWF0dGVycyxcclxuICAgIH0gPSB0aGlzLnByb3BzLnRhYmxlT3B0aW9ucztcclxuICAgIGNvbnN0IGZsYXRSb3dLZXkgPSBmbGF0S2V5KHJvd0tleSk7XHJcblxyXG4gICAgY29uc3QgY29sSW5jclNwYW4gPSBjb2xBdHRycy5sZW5ndGggIT09IDAgPyAxIDogMDtcclxuICAgIGNvbnN0IGF0dHJWYWx1ZUNlbGxzID0gcm93S2V5Lm1hcCgociwgaSkgPT4ge1xyXG4gICAgICBsZXQgdmFsdWVDZWxsQ2xhc3NOYW1lID0gJ3B2dFJvd0xhYmVsJztcclxuICAgICAgaWYgKFxyXG4gICAgICAgIGhpZ2hsaWdodEhlYWRlckNlbGxzT25Ib3ZlciAmJlxyXG4gICAgICAgICFvbWl0dGVkSGlnaGxpZ2h0SGVhZGVyR3JvdXBzLmluY2x1ZGVzKHJvd0F0dHJzW2ldKVxyXG4gICAgICApIHtcclxuICAgICAgICB2YWx1ZUNlbGxDbGFzc05hbWUgKz0gJyBob3ZlcmFibGUnO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChcclxuICAgICAgICBoaWdobGlnaHRlZEhlYWRlckNlbGxzICYmXHJcbiAgICAgICAgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlZEhlYWRlckNlbGxzW3Jvd0F0dHJzW2ldXSkgJiZcclxuICAgICAgICBoaWdobGlnaHRlZEhlYWRlckNlbGxzW3Jvd0F0dHJzW2ldXS5pbmNsdWRlcyhyKVxyXG4gICAgICApIHtcclxuICAgICAgICB2YWx1ZUNlbGxDbGFzc05hbWUgKz0gJyBhY3RpdmUnO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHJvd1NwYW4gPSByb3dBdHRyU3BhbnNbcm93SWR4XVtpXTtcclxuICAgICAgaWYgKHJvd1NwYW4gPiAwKSB7XHJcbiAgICAgICAgY29uc3QgZmxhdFJvd0tleSA9IGZsYXRLZXkocm93S2V5LnNsaWNlKDAsIGkgKyAxKSk7XHJcbiAgICAgICAgY29uc3QgY29sU3BhbiA9IDEgKyAoaSA9PT0gcm93QXR0cnMubGVuZ3RoIC0gMSA/IGNvbEluY3JTcGFuIDogMCk7XHJcbiAgICAgICAgY29uc3QgbmVlZFJvd1RvZ2dsZSA9XHJcbiAgICAgICAgICByb3dTdWJ0b3RhbERpc3BsYXkuZW5hYmxlZCAmJiBpICE9PSByb3dBdHRycy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGNvbnN0IG9uQXJyb3dDbGljayA9IG5lZWRSb3dUb2dnbGVcclxuICAgICAgICAgID8gdGhpcy50b2dnbGVSb3dLZXkoZmxhdFJvd0tleSlcclxuICAgICAgICAgIDogbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgaGVhZGVyQ2VsbEZvcm1hdHRlZFZhbHVlID1cclxuICAgICAgICAgIGRhdGVGb3JtYXR0ZXJzICYmIGRhdGVGb3JtYXR0ZXJzW3Jvd0F0dHJzW2ldXVxyXG4gICAgICAgICAgICA/IGRhdGVGb3JtYXR0ZXJzW3Jvd0F0dHJzW2ldXShyKVxyXG4gICAgICAgICAgICA6IHI7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIDx0aFxyXG4gICAgICAgICAgICBrZXk9e2Byb3dLZXlMYWJlbC0ke2l9YH1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXt2YWx1ZUNlbGxDbGFzc05hbWV9XHJcbiAgICAgICAgICAgIHJvd1NwYW49e3Jvd1NwYW59XHJcbiAgICAgICAgICAgIGNvbFNwYW49e2NvbFNwYW59XHJcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuY2xpY2tIZWFkZXJIYW5kbGVyKFxyXG4gICAgICAgICAgICAgIHBpdm90RGF0YSxcclxuICAgICAgICAgICAgICByb3dLZXksXHJcbiAgICAgICAgICAgICAgdGhpcy5wcm9wcy5yb3dzLFxyXG4gICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgdGhpcy5wcm9wcy50YWJsZU9wdGlvbnMuY2xpY2tSb3dIZWFkZXJDYWxsYmFjayxcclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAge2Rpc3BsYXlIZWFkZXJDZWxsKFxyXG4gICAgICAgICAgICAgIG5lZWRSb3dUb2dnbGUsXHJcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jb2xsYXBzZWRSb3dzW2ZsYXRSb3dLZXldXHJcbiAgICAgICAgICAgICAgICA/IGFycm93Q29sbGFwc2VkXHJcbiAgICAgICAgICAgICAgICA6IGFycm93RXhwYW5kZWQsXHJcbiAgICAgICAgICAgICAgb25BcnJvd0NsaWNrLFxyXG4gICAgICAgICAgICAgIGhlYWRlckNlbGxGb3JtYXR0ZWRWYWx1ZSxcclxuICAgICAgICAgICAgICBuYW1lc01hcHBpbmcsXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICA8L3RoPlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBhdHRyVmFsdWVQYWRkaW5nQ2VsbCA9XHJcbiAgICAgIHJvd0tleS5sZW5ndGggPCByb3dBdHRycy5sZW5ndGggPyAoXHJcbiAgICAgICAgPHRoXHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJwdnRSb3dMYWJlbCBwdnRTdWJ0b3RhbExhYmVsXCJcclxuICAgICAgICAgIGtleT1cInJvd0tleUJ1ZmZlclwiXHJcbiAgICAgICAgICBjb2xTcGFuPXtyb3dBdHRycy5sZW5ndGggLSByb3dLZXkubGVuZ3RoICsgY29sSW5jclNwYW59XHJcbiAgICAgICAgICByb3dTcGFuPXsxfVxyXG4gICAgICAgICAgb25DbGljaz17dGhpcy5jbGlja0hlYWRlckhhbmRsZXIoXHJcbiAgICAgICAgICAgIHBpdm90RGF0YSxcclxuICAgICAgICAgICAgcm93S2V5LFxyXG4gICAgICAgICAgICB0aGlzLnByb3BzLnJvd3MsXHJcbiAgICAgICAgICAgIHJvd0tleS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMudGFibGVPcHRpb25zLmNsaWNrUm93SGVhZGVyQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICApfVxyXG4gICAgICAgID5cclxuICAgICAgICAgIFN1YnRvdGFsXHJcbiAgICAgICAgPC90aD5cclxuICAgICAgKSA6IG51bGw7XHJcblxyXG4gICAgY29uc3Qgcm93Q2xpY2tIYW5kbGVycyA9IGNlbGxDYWxsYmFja3NbZmxhdFJvd0tleV0gfHwge307XHJcbiAgICBjb25zdCB2YWx1ZUNlbGxzID0gdmlzaWJsZUNvbEtleXMubWFwKGNvbEtleSA9PiB7XHJcbiAgICAgIGNvbnN0IGZsYXRDb2xLZXkgPSBmbGF0S2V5KGNvbEtleSk7XHJcbiAgICAgIGNvbnN0IGFnZyA9IHBpdm90RGF0YS5nZXRBZ2dyZWdhdG9yKHJvd0tleSwgY29sS2V5KTtcclxuICAgICAgY29uc3QgYWdnVmFsdWUgPSBhZ2cudmFsdWUoKTtcclxuXHJcbiAgICAgIGNvbnN0IGtleXMgPSBbLi4ucm93S2V5LCAuLi5jb2xLZXldO1xyXG4gICAgICBsZXQgYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICBpZiAoY2VsbENvbG9yRm9ybWF0dGVycykge1xyXG4gICAgICAgIE9iamVjdC52YWx1ZXMoY2VsbENvbG9yRm9ybWF0dGVycykuZm9yRWFjaChjZWxsQ29sb3JGb3JtYXR0ZXIgPT4ge1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbENvbG9yRm9ybWF0dGVyKSkge1xyXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNlbGxDb2xvckZvcm1hdHRlclxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmb3JtYXR0ZXIgPT4gZm9ybWF0dGVyLmNvbHVtbiA9PT0ga2V5KVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZm9ybWF0dGVyID0+IHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyUmVzdWx0ID0gZm9ybWF0dGVyLmdldENvbG9yRnJvbVZhbHVlKGFnZ1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlclJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGZvcm1hdHRlclJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzdHlsZSA9IGFnZy5pc1N1YnRvdGFsXHJcbiAgICAgICAgPyB7IGZvbnRXZWlnaHQ6ICdib2xkJyB9XHJcbiAgICAgICAgOiB7IGJhY2tncm91bmRDb2xvciB9O1xyXG5cclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICA8dGRcclxuICAgICAgICAgIHJvbGU9XCJncmlkY2VsbFwiXHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJwdnRWYWxcIlxyXG4gICAgICAgICAga2V5PXtgcHZ0VmFsLSR7ZmxhdENvbEtleX1gfVxyXG4gICAgICAgICAgb25DbGljaz17cm93Q2xpY2tIYW5kbGVyc1tmbGF0Q29sS2V5XX1cclxuICAgICAgICAgIG9uQ29udGV4dE1lbnU9e2UgPT4gdGhpcy5wcm9wcy5vbkNvbnRleHRNZW51KGUsIGNvbEtleSwgcm93S2V5KX1cclxuICAgICAgICAgIHN0eWxlPXtzdHlsZX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICB7YWdnLmZvcm1hdChhZ2dWYWx1ZSl9XHJcbiAgICAgICAgPC90ZD5cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCB0b3RhbENlbGwgPSBudWxsO1xyXG4gICAgaWYgKHJvd1RvdGFscykge1xyXG4gICAgICBjb25zdCBhZ2cgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihyb3dLZXksIFtdKTtcclxuICAgICAgY29uc3QgYWdnVmFsdWUgPSBhZ2cudmFsdWUoKTtcclxuICAgICAgdG90YWxDZWxsID0gKFxyXG4gICAgICAgIDx0ZFxyXG4gICAgICAgICAgcm9sZT1cImdyaWRjZWxsXCJcclxuICAgICAgICAgIGtleT1cInRvdGFsXCJcclxuICAgICAgICAgIGNsYXNzTmFtZT1cInB2dFRvdGFsXCJcclxuICAgICAgICAgIG9uQ2xpY2s9e3Jvd1RvdGFsQ2FsbGJhY2tzW2ZsYXRSb3dLZXldfVxyXG4gICAgICAgICAgb25Db250ZXh0TWVudT17ZSA9PiB0aGlzLnByb3BzLm9uQ29udGV4dE1lbnUoZSwgdW5kZWZpbmVkLCByb3dLZXkpfVxyXG4gICAgICAgID5cclxuICAgICAgICAgIHthZ2cuZm9ybWF0KGFnZ1ZhbHVlKX1cclxuICAgICAgICA8L3RkPlxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJvd0NlbGxzID0gW1xyXG4gICAgICAuLi5hdHRyVmFsdWVDZWxscyxcclxuICAgICAgYXR0clZhbHVlUGFkZGluZ0NlbGwsXHJcbiAgICAgIC4uLnZhbHVlQ2VsbHMsXHJcbiAgICAgIHRvdGFsQ2VsbCxcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIDx0ciBrZXk9e2BrZXlSb3ctJHtmbGF0Um93S2V5fWB9Pntyb3dDZWxsc308L3RyPjtcclxuICB9XHJcblxyXG4gIHJlbmRlclRvdGFsc1JvdyhwaXZvdFNldHRpbmdzKSB7XHJcbiAgICAvLyBSZW5kZXIgdGhlIGZpbmFsIHRvdGFscyByb3dzIHRoYXQgaGFzIHRoZSB0b3RhbHMgZm9yIGFsbCB0aGUgY29sdW1ucy5cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJvd0F0dHJzLFxyXG4gICAgICBjb2xBdHRycyxcclxuICAgICAgdmlzaWJsZUNvbEtleXMsXHJcbiAgICAgIHJvd1RvdGFscyxcclxuICAgICAgcGl2b3REYXRhLFxyXG4gICAgICBjb2xUb3RhbENhbGxiYWNrcyxcclxuICAgICAgZ3JhbmRUb3RhbENhbGxiYWNrLFxyXG4gICAgfSA9IHBpdm90U2V0dGluZ3M7XHJcblxyXG4gICAgY29uc3QgdG90YWxMYWJlbENlbGwgPSAoXHJcbiAgICAgIDx0aFxyXG4gICAgICAgIGtleT1cImxhYmVsXCJcclxuICAgICAgICBjbGFzc05hbWU9XCJwdnRUb3RhbExhYmVsIHB2dFJvd1RvdGFsTGFiZWxcIlxyXG4gICAgICAgIGNvbFNwYW49e3Jvd0F0dHJzLmxlbmd0aCArIE1hdGgubWluKGNvbEF0dHJzLmxlbmd0aCwgMSl9XHJcbiAgICAgICAgb25DbGljaz17dGhpcy5jbGlja0hlYWRlckhhbmRsZXIoXHJcbiAgICAgICAgICBwaXZvdERhdGEsXHJcbiAgICAgICAgICBbXSxcclxuICAgICAgICAgIHRoaXMucHJvcHMucm93cyxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICB0aGlzLnByb3BzLnRhYmxlT3B0aW9ucy5jbGlja1Jvd0hlYWRlckNhbGxiYWNrLFxyXG4gICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICl9XHJcbiAgICAgID5cclxuICAgICAgICB7YFRvdGFsICgke3RoaXMucHJvcHMuYWdncmVnYXRvck5hbWV9KWB9XHJcbiAgICAgIDwvdGg+XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHRvdGFsVmFsdWVDZWxscyA9IHZpc2libGVDb2xLZXlzLm1hcChjb2xLZXkgPT4ge1xyXG4gICAgICBjb25zdCBmbGF0Q29sS2V5ID0gZmxhdEtleShjb2xLZXkpO1xyXG4gICAgICBjb25zdCBhZ2cgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihbXSwgY29sS2V5KTtcclxuICAgICAgY29uc3QgYWdnVmFsdWUgPSBhZ2cudmFsdWUoKTtcclxuXHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRkXHJcbiAgICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwicHZ0VG90YWwgcHZ0Um93VG90YWxcIlxyXG4gICAgICAgICAga2V5PXtgdG90YWwtJHtmbGF0Q29sS2V5fWB9XHJcbiAgICAgICAgICBvbkNsaWNrPXtjb2xUb3RhbENhbGxiYWNrc1tmbGF0Q29sS2V5XX1cclxuICAgICAgICAgIG9uQ29udGV4dE1lbnU9e2UgPT4gdGhpcy5wcm9wcy5vbkNvbnRleHRNZW51KGUsIGNvbEtleSwgdW5kZWZpbmVkKX1cclxuICAgICAgICAgIHN0eWxlPXt7IHBhZGRpbmc6ICc1cHgnIH19XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAge2FnZy5mb3JtYXQoYWdnVmFsdWUpfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgZ3JhbmRUb3RhbENlbGwgPSBudWxsO1xyXG4gICAgaWYgKHJvd1RvdGFscykge1xyXG4gICAgICBjb25zdCBhZ2cgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihbXSwgW10pO1xyXG4gICAgICBjb25zdCBhZ2dWYWx1ZSA9IGFnZy52YWx1ZSgpO1xyXG4gICAgICBncmFuZFRvdGFsQ2VsbCA9IChcclxuICAgICAgICA8dGRcclxuICAgICAgICAgIHJvbGU9XCJncmlkY2VsbFwiXHJcbiAgICAgICAgICBrZXk9XCJ0b3RhbFwiXHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJwdnRHcmFuZFRvdGFsIHB2dFJvd1RvdGFsXCJcclxuICAgICAgICAgIG9uQ2xpY2s9e2dyYW5kVG90YWxDYWxsYmFja31cclxuICAgICAgICAgIG9uQ29udGV4dE1lbnU9e2UgPT4gdGhpcy5wcm9wcy5vbkNvbnRleHRNZW51KGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICB7YWdnLmZvcm1hdChhZ2dWYWx1ZSl9XHJcbiAgICAgICAgPC90ZD5cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0b3RhbENlbGxzID0gW3RvdGFsTGFiZWxDZWxsLCAuLi50b3RhbFZhbHVlQ2VsbHMsIGdyYW5kVG90YWxDZWxsXTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8dHIga2V5PVwidG90YWxcIiBjbGFzc05hbWU9XCJwdnRSb3dUb3RhbHNcIj5cclxuICAgICAgICB7dG90YWxDZWxsc31cclxuICAgICAgPC90cj5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICB2aXNpYmxlS2V5cyhrZXlzLCBjb2xsYXBzZWQsIG51bUF0dHJzLCBzdWJ0b3RhbERpc3BsYXkpIHtcclxuICAgIHJldHVybiBrZXlzLmZpbHRlcihcclxuICAgICAga2V5ID0+XHJcbiAgICAgICAgLy8gSXMgdGhlIGtleSBoaWRkZW4gYnkgb25lIG9mIGl0cyBwYXJlbnRzP1xyXG4gICAgICAgICFrZXkuc29tZSgoaywgaikgPT4gY29sbGFwc2VkW2ZsYXRLZXkoa2V5LnNsaWNlKDAsIGopKV0pICYmXHJcbiAgICAgICAgLy8gTGVhZiBrZXkuXHJcbiAgICAgICAgKGtleS5sZW5ndGggPT09IG51bUF0dHJzIHx8XHJcbiAgICAgICAgICAvLyBDaGlsZHJlbiBoaWRkZW4uIE11c3Qgc2hvdyB0b3RhbC5cclxuICAgICAgICAgIGZsYXRLZXkoa2V5KSBpbiBjb2xsYXBzZWQgfHxcclxuICAgICAgICAgIC8vIERvbid0IGhpZGUgdG90YWxzLlxyXG4gICAgICAgICAgIXN1YnRvdGFsRGlzcGxheS5oaWRlT25FeHBhbmQpLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlzRGFzaGJvYXJkRWRpdE1vZGUoKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY29udGFpbnMoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRhc2hib2FyZC0tZWRpdGluZycpKTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIGlmICh0aGlzLmNhY2hlZFByb3BzICE9PSB0aGlzLnByb3BzKSB7XHJcbiAgICAgIHRoaXMuY2FjaGVkUHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICB0aGlzLmNhY2hlZEJhc2VQaXZvdFNldHRpbmdzID0gdGhpcy5nZXRCYXNlUGl2b3RTZXR0aW5ncygpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qge1xyXG4gICAgICBjb2xBdHRycyxcclxuICAgICAgcm93QXR0cnMsXHJcbiAgICAgIHJvd0tleXMsXHJcbiAgICAgIGNvbEtleXMsXHJcbiAgICAgIGNvbFRvdGFscyxcclxuICAgICAgcm93U3VidG90YWxEaXNwbGF5LFxyXG4gICAgICBjb2xTdWJ0b3RhbERpc3BsYXksXHJcbiAgICB9ID0gdGhpcy5jYWNoZWRCYXNlUGl2b3RTZXR0aW5ncztcclxuXHJcbiAgICAvLyBOZWVkIHRvIGFjY291bnQgZm9yIGV4Y2x1c2lvbnMgdG8gY29tcHV0ZSB0aGUgZWZmZWN0aXZlIHJvd1xyXG4gICAgLy8gYW5kIGNvbHVtbiBrZXlzLlxyXG4gICAgY29uc3QgdmlzaWJsZVJvd0tleXMgPSB0aGlzLnZpc2libGVLZXlzKFxyXG4gICAgICByb3dLZXlzLFxyXG4gICAgICB0aGlzLnN0YXRlLmNvbGxhcHNlZFJvd3MsXHJcbiAgICAgIHJvd0F0dHJzLmxlbmd0aCxcclxuICAgICAgcm93U3VidG90YWxEaXNwbGF5LFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHZpc2libGVDb2xLZXlzID0gdGhpcy52aXNpYmxlS2V5cyhcclxuICAgICAgY29sS2V5cyxcclxuICAgICAgdGhpcy5zdGF0ZS5jb2xsYXBzZWRDb2xzLFxyXG4gICAgICBjb2xBdHRycy5sZW5ndGgsXHJcbiAgICAgIGNvbFN1YnRvdGFsRGlzcGxheSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgcGl2b3RTZXR0aW5ncyA9IHtcclxuICAgICAgdmlzaWJsZVJvd0tleXMsXHJcbiAgICAgIG1heFJvd1Zpc2libGU6IE1hdGgubWF4KC4uLnZpc2libGVSb3dLZXlzLm1hcChrID0+IGsubGVuZ3RoKSksXHJcbiAgICAgIHZpc2libGVDb2xLZXlzLFxyXG4gICAgICBtYXhDb2xWaXNpYmxlOiBNYXRoLm1heCguLi52aXNpYmxlQ29sS2V5cy5tYXAoayA9PiBrLmxlbmd0aCkpLFxyXG4gICAgICByb3dBdHRyU3BhbnM6IHRoaXMuY2FsY0F0dHJTcGFucyh2aXNpYmxlUm93S2V5cywgcm93QXR0cnMubGVuZ3RoKSxcclxuICAgICAgY29sQXR0clNwYW5zOiB0aGlzLmNhbGNBdHRyU3BhbnModmlzaWJsZUNvbEtleXMsIGNvbEF0dHJzLmxlbmd0aCksXHJcbiAgICAgIC4uLnRoaXMuY2FjaGVkQmFzZVBpdm90U2V0dGluZ3MsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxTdHlsZXMgaXNEYXNoYm9hcmRFZGl0TW9kZT17dGhpcy5pc0Rhc2hib2FyZEVkaXRNb2RlKCl9PlxyXG4gICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJwdnRUYWJsZVwiIHJvbGU9XCJncmlkXCI+XHJcbiAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgIHtjb2xBdHRycy5tYXAoKGMsIGopID0+XHJcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDb2xIZWFkZXJSb3coYywgaiwgcGl2b3RTZXR0aW5ncyksXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIHtyb3dBdHRycy5sZW5ndGggIT09IDAgJiYgdGhpcy5yZW5kZXJSb3dIZWFkZXJSb3cocGl2b3RTZXR0aW5ncyl9XHJcbiAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICB7dmlzaWJsZVJvd0tleXMubWFwKChyLCBpKSA9PlxyXG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyVGFibGVSb3cociwgaSwgcGl2b3RTZXR0aW5ncyksXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIHtjb2xUb3RhbHMgJiYgdGhpcy5yZW5kZXJUb3RhbHNSb3cocGl2b3RTZXR0aW5ncyl9XHJcbiAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgIDwvU3R5bGVzPlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcblRhYmxlUmVuZGVyZXIucHJvcFR5cGVzID0ge1xyXG4gIC4uLlBpdm90RGF0YS5wcm9wVHlwZXMsXHJcbiAgdGFibGVPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxyXG4gIG9uQ29udGV4dE1lbnU6IFByb3BUeXBlcy5mdW5jLFxyXG59O1xyXG5UYWJsZVJlbmRlcmVyLmRlZmF1bHRQcm9wcyA9IHsgLi4uUGl2b3REYXRhLmRlZmF1bHRQcm9wcywgdGFibGVPcHRpb25zOiB7fSB9O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/plugin-chart-pivot-table/src/react-pivottable/TableRenderers.jsx\n");

/***/ }),

/***/ "./plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js":
/*!****************************************************************************!*\
  !*** ./plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"aggregatorTemplates\": () => (/* binding */ aggregatorTemplates),\n/* harmony export */   \"sortAs\": () => (/* binding */ sortAs),\n/* harmony export */   \"flatKey\": () => (/* binding */ flatKey),\n/* harmony export */   \"PivotData\": () => (/* binding */ PivotData)\n/* harmony export */ });\n/* unused harmony exports aggregators, derivers, locales, naturalSort, numberFormat, getSort */\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/includes */ \"./node_modules/@babel/runtime-corejs3/core-js-stable/instance/includes.js\");\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/translation/TranslatorSingleton.ts\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\n\nconst addSeparators = function (nStr, thousandsSep, decimalSep) {\n  const x = String(nStr).split('.');\n  let x1 = x[0];\n  const x2 = x.length > 1 ? decimalSep + x[1] : '';\n  const rgx = /(\\d+)(\\d{3})/;\n  while (rgx.test(x1)) {\n    x1 = x1.replace(rgx, `$1${thousandsSep}$2`);\n  }\n  return x1 + x2;\n};\n\nconst numberFormat = function (optsIn) {\n  const defaults = {\n    digitsAfterDecimal: 2,\n    scaler: 1,\n    thousandsSep: ',',\n    decimalSep: '.',\n    prefix: '',\n    suffix: '' };\n\n  const opts = { ...defaults, ...optsIn };\n  return function (x) {\n    if (Number.isNaN(x) || !Number.isFinite(x)) {\n      return '';\n    }\n    const result = addSeparators(\n    (opts.scaler * x).toFixed(opts.digitsAfterDecimal),\n    opts.thousandsSep,\n    opts.decimalSep);\n\n    return `${opts.prefix}${result}${opts.suffix}`;\n  };\n};\n\nconst rx = /(\\d+)|(\\D+)/g;\nconst rd = /\\d/;\nconst rz = /^0/;\nconst naturalSort = (as, bs) => {\n  // nulls first\n  if (bs !== null && as === null) {\n    return -1;\n  }\n  if (as !== null && bs === null) {\n    return 1;\n  }\n\n  // then raw NaNs\n  if (typeof as === 'number' && Number.isNaN(as)) {\n    return -1;\n  }\n  if (typeof bs === 'number' && Number.isNaN(bs)) {\n    return 1;\n  }\n\n  // numbers and numbery strings group together\n  const nas = Number(as);\n  const nbs = Number(bs);\n  if (nas < nbs) {\n    return -1;\n  }\n  if (nas > nbs) {\n    return 1;\n  }\n\n  // within that, true numbers before numbery strings\n  if (typeof as === 'number' && typeof bs !== 'number') {\n    return -1;\n  }\n  if (typeof bs === 'number' && typeof as !== 'number') {\n    return 1;\n  }\n  if (typeof as === 'number' && typeof bs === 'number') {\n    return 0;\n  }\n\n  // 'Infinity' is a textual number, so less than 'A'\n  if (Number.isNaN(nbs) && !Number.isNaN(nas)) {\n    return -1;\n  }\n  if (Number.isNaN(nas) && !Number.isNaN(nbs)) {\n    return 1;\n  }\n\n  // finally, \"smart\" string sorting per http://stackoverflow.com/a/4373421/112871\n  let a = String(as);\n  let b = String(bs);\n  if (a === b) {\n    return 0;\n  }\n  if (!rd.test(a) || !rd.test(b)) {\n    return a > b ? 1 : -1;\n  }\n\n  // special treatment for strings containing digits\n  a = a.match(rx);\n  b = b.match(rx);\n  while (a.length && b.length) {\n    const a1 = a.shift();\n    const b1 = b.shift();\n    if (a1 !== b1) {\n      if (rd.test(a1) && rd.test(b1)) {\n        return a1.replace(rz, '.0') - b1.replace(rz, '.0');\n      }\n      return a1 > b1 ? 1 : -1;\n    }\n  }\n  return a.length - b.length;\n};\n\nconst sortAs = function (order) {\n  const mapping = {};\n\n  // sort lowercased keys similarly\n  const lMapping = {};\n  order.forEach((element, i) => {\n    mapping[element] = i;\n    if (typeof element === 'string') {\n      lMapping[element.toLowerCase()] = i;\n    }\n  });\n  return function (a, b) {\n    if (a in mapping && b in mapping) {\n      return mapping[a] - mapping[b];\n    }\n    if (a in mapping) {\n      return -1;\n    }\n    if (b in mapping) {\n      return 1;\n    }\n    if (a in lMapping && b in lMapping) {\n      return lMapping[a] - lMapping[b];\n    }\n    if (a in lMapping) {\n      return -1;\n    }\n    if (b in lMapping) {\n      return 1;\n    }\n    return naturalSort(a, b);\n  };\n};\n\nconst getSort = function (sorters, attr) {\n  if (sorters) {\n    if (typeof sorters === 'function') {\n      const sort = sorters(attr);\n      if (typeof sort === 'function') {\n        return sort;\n      }\n    } else if (attr in sorters) {\n      return sorters[attr];\n    }\n  }\n  return naturalSort;\n};\n\n// aggregator templates default to US number formatting but this is overridable\nconst usFmt = numberFormat();\nconst usFmtInt = numberFormat({ digitsAfterDecimal: 0 });\nconst usFmtPct = numberFormat({\n  digitsAfterDecimal: 1,\n  scaler: 100,\n  suffix: '%' });\n\n\nconst fmtNonString = (formatter) => (x) => typeof x === 'string' ? x : formatter(x);\n\nconst baseAggregatorTemplates = {\n  count(formatter) {if (formatter === void 0) {formatter = usFmtInt;}\n    return () =>\n    function () {\n      return {\n        count: 0,\n        push() {\n          this.count += 1;\n        },\n        value() {\n          return this.count;\n        },\n        format: formatter };\n\n    };\n  },\n\n  uniques(fn, formatter) {if (formatter === void 0) {formatter = usFmtInt;}\n    return function (_ref) {let [attr] = _ref;\n      return function () {\n        return {\n          uniq: [],\n          push(record) {var _context;\n            if (!_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(_context = Array.from(this.uniq)).call(_context, record[attr])) {\n              this.uniq.push(record[attr]);\n            }\n          },\n          value() {\n            return fn(this.uniq);\n          },\n          format: fmtNonString(formatter),\n          numInputs: typeof attr !== 'undefined' ? 0 : 1 };\n\n      };\n    };\n  },\n\n  sum(formatter) {if (formatter === void 0) {formatter = usFmt;}\n    return function (_ref2) {let [attr] = _ref2;\n      return function () {\n        return {\n          sum: 0,\n          push(record) {\n            if (Number.isNaN(Number(record[attr]))) {\n              this.sum = record[attr];\n            } else {\n              this.sum += parseFloat(record[attr]);\n            }\n          },\n          value() {\n            return this.sum;\n          },\n          format: fmtNonString(formatter),\n          numInputs: typeof attr !== 'undefined' ? 0 : 1 };\n\n      };\n    };\n  },\n\n  extremes(mode, formatter) {if (formatter === void 0) {formatter = usFmt;}\n    return function (_ref3) {let [attr] = _ref3;\n      return function (data) {\n        return {\n          val: null,\n          sorter: getSort(\n          typeof data !== 'undefined' ? data.sorters : null,\n          attr),\n\n          push(record) {var _context2;\n            const x = record[attr];\n            if (_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(_context2 = ['min', 'max']).call(_context2, mode)) {\n              const coercedValue = Number(x);\n              if (Number.isNaN(coercedValue)) {\n                this.val =\n                !this.val ||\n                mode === 'min' && x < this.val ||\n                mode === 'max' && x > this.val ?\n                x :\n                this.val;\n              } else {\n                this.val = Math[mode](\n                coercedValue,\n                this.val !== null ? this.val : coercedValue);\n\n              }\n            } else if (\n            mode === 'first' &&\n            this.sorter(x, this.val !== null ? this.val : x) <= 0)\n            {\n              this.val = x;\n            } else if (\n            mode === 'last' &&\n            this.sorter(x, this.val !== null ? this.val : x) >= 0)\n            {\n              this.val = x;\n            }\n          },\n          value() {\n            return this.val;\n          },\n          format(x) {\n            if (typeof x === 'number') {\n              return formatter(x);\n            }\n            return x;\n          },\n          numInputs: typeof attr !== 'undefined' ? 0 : 1 };\n\n      };\n    };\n  },\n\n  quantile(q, formatter) {if (formatter === void 0) {formatter = usFmt;}\n    return function (_ref4) {let [attr] = _ref4;\n      return function () {\n        return {\n          vals: [],\n          strMap: {},\n          push(record) {\n            const val = record[attr];\n            const x = Number(val);\n\n            if (Number.isNaN(x)) {\n              this.strMap[val] = (this.strMap[val] || 0) + 1;\n            } else {\n              this.vals.push(x);\n            }\n          },\n          value() {\n            if (\n            this.vals.length === 0 &&\n            Object.keys(this.strMap).length === 0)\n            {\n              return null;\n            }\n\n            if (Object.keys(this.strMap).length) {\n              const values = Object.values(this.strMap).sort((a, b) => a - b);\n              const middle = Math.floor(values.length / 2);\n\n              const keys = Object.keys(this.strMap);\n              return keys.length % 2 !== 0 ?\n              keys[middle] :\n              (keys[middle - 1] + keys[middle]) / 2;\n            }\n\n            this.vals.sort((a, b) => a - b);\n            const i = (this.vals.length - 1) * q;\n            return (this.vals[Math.floor(i)] + this.vals[Math.ceil(i)]) / 2.0;\n          },\n          format: fmtNonString(formatter),\n          numInputs: typeof attr !== 'undefined' ? 0 : 1 };\n\n      };\n    };\n  },\n\n  runningStat(mode, ddof, formatter) {if (mode === void 0) {mode = 'mean';}if (ddof === void 0) {ddof = 1;}if (formatter === void 0) {formatter = usFmt;}\n    return function (_ref5) {let [attr] = _ref5;\n      return function () {\n        return {\n          n: 0.0,\n          m: 0.0,\n          s: 0.0,\n          strValue: null,\n          push(record) {\n            const x = Number(record[attr]);\n            if (Number.isNaN(x)) {\n              this.strValue =\n              typeof record[attr] === 'string' ? record[attr] : this.strValue;\n              return;\n            }\n            this.n += 1.0;\n            if (this.n === 1.0) {\n              this.m = x;\n            }\n            const mNew = this.m + (x - this.m) / this.n;\n            this.s += (x - this.m) * (x - mNew);\n            this.m = mNew;\n          },\n          value() {\n            if (this.strValue) {\n              return this.strValue;\n            }\n\n            if (mode === 'mean') {\n              if (this.n === 0) {\n                return 0 / 0;\n              }\n              return this.m;\n            }\n            if (this.n <= ddof) {\n              return 0;\n            }\n            switch (mode) {\n              case 'var':\n                return this.s / (this.n - ddof);\n              case 'stdev':\n                return Math.sqrt(this.s / (this.n - ddof));\n              default:\n                throw new Error('unknown mode for runningStat');}\n\n          },\n          format: fmtNonString(formatter),\n          numInputs: typeof attr !== 'undefined' ? 0 : 1 };\n\n      };\n    };\n  },\n\n  sumOverSum(formatter) {if (formatter === void 0) {formatter = usFmt;}\n    return function (_ref6) {let [num, denom] = _ref6;\n      return function () {\n        return {\n          sumNum: 0,\n          sumDenom: 0,\n          push(record) {\n            if (!Number.isNaN(Number(record[num]))) {\n              this.sumNum += parseFloat(record[num]);\n            }\n            if (!Number.isNaN(Number(record[denom]))) {\n              this.sumDenom += parseFloat(record[denom]);\n            }\n          },\n          value() {\n            return this.sumNum / this.sumDenom;\n          },\n          format: formatter,\n          numInputs:\n          typeof num !== 'undefined' && typeof denom !== 'undefined' ? 0 : 2 };\n\n      };\n    };\n  },\n\n  fractionOf(wrapped, type, formatter) {if (type === void 0) {type = 'total';}if (formatter === void 0) {formatter = usFmtPct;}\n    return function () {for (var _len = arguments.length, x = new Array(_len), _key = 0; _key < _len; _key++) {x[_key] = arguments[_key];}return (\n        function (data, rowKey, colKey) {\n          return {\n            selector: { total: [[], []], row: [rowKey, []], col: [[], colKey] }[\n            type],\n\n            inner: wrapped(...Array.from(x || []))(data, rowKey, colKey),\n            push(record) {\n              this.inner.push(record);\n            },\n            format: fmtNonString(formatter),\n            value() {\n              const acc = data.\n              getAggregator(...Array.from(this.selector || [])).\n              inner.value();\n\n              if (typeof acc === 'string') {\n                return acc;\n              }\n\n              return this.inner.value() / acc;\n            },\n            numInputs: wrapped(...Array.from(x || []))().numInputs };\n\n        });};\n  } };\n\n\nconst extendedAggregatorTemplates = {\n  countUnique(f) {\n    return baseAggregatorTemplates.uniques((x) => x.length, f);\n  },\n  listUnique(s, f) {\n    return baseAggregatorTemplates.uniques((x) => x.join(s), f || ((x) => x));\n  },\n  max(f) {\n    return baseAggregatorTemplates.extremes('max', f);\n  },\n  min(f) {\n    return baseAggregatorTemplates.extremes('min', f);\n  },\n  first(f) {\n    return baseAggregatorTemplates.extremes('first', f);\n  },\n  last(f) {\n    return baseAggregatorTemplates.extremes('last', f);\n  },\n  median(f) {\n    return baseAggregatorTemplates.quantile(0.5, f);\n  },\n  average(f) {\n    return baseAggregatorTemplates.runningStat('mean', 1, f);\n  },\n  var(ddof, f) {\n    return baseAggregatorTemplates.runningStat('var', ddof, f);\n  },\n  stdev(ddof, f) {\n    return baseAggregatorTemplates.runningStat('stdev', ddof, f);\n  } };\n\n\nconst aggregatorTemplates = {\n  ...baseAggregatorTemplates,\n  ...extendedAggregatorTemplates };\n\n\n// default aggregators & renderers use US naming and number formatting\nconst aggregators = ((tpl) => ({\n  Count: tpl.count(usFmtInt),\n  'Count Unique Values': tpl.countUnique(usFmtInt),\n  'List Unique Values': tpl.listUnique(', '),\n  Sum: tpl.sum(usFmt),\n  'Integer Sum': tpl.sum(usFmtInt),\n  Average: tpl.average(usFmt),\n  Median: tpl.median(usFmt),\n  'Sample Variance': tpl.var(1, usFmt),\n  'Sample Standard Deviation': tpl.stdev(1, usFmt),\n  Minimum: tpl.min(usFmt),\n  Maximum: tpl.max(usFmt),\n  First: tpl.first(usFmt),\n  Last: tpl.last(usFmt),\n  'Sum over Sum': tpl.sumOverSum(usFmt),\n  'Sum as Fraction of Total': tpl.fractionOf(tpl.sum(), 'total', usFmtPct),\n  'Sum as Fraction of Rows': tpl.fractionOf(tpl.sum(), 'row', usFmtPct),\n  'Sum as Fraction of Columns': tpl.fractionOf(tpl.sum(), 'col', usFmtPct),\n  'Count as Fraction of Total': tpl.fractionOf(tpl.count(), 'total', usFmtPct),\n  'Count as Fraction of Rows': tpl.fractionOf(tpl.count(), 'row', usFmtPct),\n  'Count as Fraction of Columns': tpl.fractionOf(tpl.count(), 'col', usFmtPct) }))(\naggregatorTemplates);\n\nconst locales = {\n  en: {\n    aggregators,\n    localeStrings: {\n      renderError: 'An error occurred rendering the PivotTable results.',\n      computeError: 'An error occurred computing the PivotTable results.',\n      uiRenderError: 'An error occurred rendering the PivotTable UI.',\n      selectAll: 'Select All',\n      selectNone: 'Select None',\n      tooMany: '(too many to list)',\n      filterResults: 'Filter values',\n      apply: 'Apply',\n      cancel: 'Cancel',\n      totals: 'Totals',\n      vs: 'vs',\n      by: 'by' } } };\n\n\n\n\n// dateFormat deriver l10n requires month and day names to be passed in directly\nconst mthNamesEn = [\n'Jan',\n'Feb',\n'Mar',\n'Apr',\n'May',\n'Jun',\n'Jul',\n'Aug',\n'Sep',\n'Oct',\n'Nov',\n'Dec'];\n\nconst dayNamesEn = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\nconst zeroPad = (number) => `0${number}`.substr(-2, 2); // eslint-disable-line no-magic-numbers\n\nconst derivers = {\n  bin(col, binWidth) {\n    return (record) => record[col] - record[col] % binWidth;\n  },\n  dateFormat(\n  col,\n  formatString,\n  utcOutput,\n  mthNames,\n  dayNames)\n  {if (utcOutput === void 0) {utcOutput = false;}if (mthNames === void 0) {mthNames = mthNamesEn;}if (dayNames === void 0) {dayNames = dayNamesEn;}\n    const utc = utcOutput ? 'UTC' : '';\n    return function (record) {\n      const date = new Date(Date.parse(record[col]));\n      if (Number.isNaN(date)) {\n        return '';\n      }\n      return formatString.replace(/%(.)/g, function (m, p) {\n        switch (p) {\n          case 'y':\n            return date[`get${utc}FullYear`]();\n          case 'm':\n            return zeroPad(date[`get${utc}Month`]() + 1);\n          case 'n':\n            return mthNames[date[`get${utc}Month`]()];\n          case 'd':\n            return zeroPad(date[`get${utc}Date`]());\n          case 'w':\n            return dayNames[date[`get${utc}Day`]()];\n          case 'x':\n            return date[`get${utc}Day`]();\n          case 'H':\n            return zeroPad(date[`get${utc}Hours`]());\n          case 'M':\n            return zeroPad(date[`get${utc}Minutes`]());\n          case 'S':\n            return zeroPad(date[`get${utc}Seconds`]());\n          default:\n            return `%${p}`;}\n\n      });\n    };\n  } };\n\n\n// Given an array of attribute values, convert to a key that\n// can be used in objects.\nconst flatKey = (attrVals) => attrVals.join(String.fromCharCode(0));\n\n/*\r\nData Model class\r\n*/\n\nclass PivotData {\n  constructor(inputProps, subtotals) {if (inputProps === void 0) {inputProps = {};}if (subtotals === void 0) {subtotals = {};}\n    this.props = { ...PivotData.defaultProps, ...inputProps };\n    this.processRecord = this.processRecord.bind(this);\n    prop_types__WEBPACK_IMPORTED_MODULE_1___default().checkPropTypes(\n    PivotData.propTypes,\n    this.props,\n    'prop',\n    'PivotData');\n\n\n    this.aggregator = this.props.\n    aggregatorsFactory(this.props.defaultFormatter)[\n    this.props.aggregatorName](this.props.vals);\n    this.formattedAggregators =\n    this.props.customFormatters &&\n    Object.entries(this.props.customFormatters).reduce(\n    (acc, _ref7) => {let [key, columnFormatter] = _ref7;\n      acc[key] = {};\n      Object.entries(columnFormatter).forEach((_ref8) => {let [column, formatter] = _ref8;\n        acc[key][column] = this.props.\n        aggregatorsFactory(formatter)[\n        this.props.aggregatorName](this.props.vals);\n      });\n      return acc;\n    },\n    {});\n\n    this.tree = {};\n    this.rowKeys = [];\n    this.colKeys = [];\n    this.rowTotals = {};\n    this.colTotals = {};\n    this.allTotal = this.aggregator(this, [], []);\n    this.subtotals = subtotals;\n    this.sorted = false;\n\n    // iterate through input, accumulating data for cells\n    PivotData.forEachRecord(this.props.data, this.processRecord);\n  }\n\n  getFormattedAggregator(record, totalsKeys) {\n    if (!this.formattedAggregators) {\n      return this.aggregator;\n    }\n    const [groupName, groupValue] =\n    Object.entries(record).find(\n    (_ref9) => {let [name, value] = _ref9;return (\n        this.formattedAggregators[name] &&\n        this.formattedAggregators[name][value]);}) ||\n    [];\n    if (\n    !groupName ||\n    !groupValue ||\n    totalsKeys && !_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(totalsKeys).call(totalsKeys, groupValue))\n    {\n      return this.aggregator;\n    }\n    return this.formattedAggregators[groupName][groupValue] || this.aggregator;\n  }\n\n  arrSort(attrs, partialOnTop, reverse) {if (reverse === void 0) {reverse = false;}\n    const sortersArr = attrs.map((a) => getSort(this.props.sorters, a));\n    return function (a, b) {\n      const limit = Math.min(a.length, b.length);\n      for (let i = 0; i < limit; i += 1) {\n        const sorter = sortersArr[i];\n        const comparison = reverse ? sorter(b[i], a[i]) : sorter(a[i], b[i]);\n        if (comparison !== 0) {\n          return comparison;\n        }\n      }\n      return partialOnTop ? a.length - b.length : b.length - a.length;\n    };\n  }\n\n  sortKeys() {\n    if (!this.sorted) {\n      this.sorted = true;\n      const v = (r, c) => this.getAggregator(r, c).value();\n      switch (this.props.rowOrder) {\n        case 'key_z_to_a':\n          this.rowKeys.sort(\n          this.arrSort(this.props.rows, this.subtotals.rowPartialOnTop, true));\n\n          break;\n        case 'value_a_to_z':\n          this.rowKeys.sort((a, b) => naturalSort(v(a, []), v(b, [])));\n          break;\n        case 'value_z_to_a':\n          this.rowKeys.sort((a, b) => -naturalSort(v(a, []), v(b, [])));\n          break;\n        default:\n          this.rowKeys.sort(\n          this.arrSort(this.props.rows, this.subtotals.rowPartialOnTop));}\n\n\n      switch (this.props.colOrder) {\n        case 'key_z_to_a':\n          this.colKeys.sort(\n          this.arrSort(this.props.cols, this.subtotals.colPartialOnTop, true));\n\n          break;\n        case 'value_a_to_z':\n          this.colKeys.sort((a, b) => naturalSort(v([], a), v([], b)));\n          break;\n        case 'value_z_to_a':\n          this.colKeys.sort((a, b) => -naturalSort(v([], a), v([], b)));\n          break;\n        default:\n          this.colKeys.sort(\n          this.arrSort(this.props.cols, this.subtotals.colPartialOnTop));}\n\n\n    }\n  }\n\n  getColKeys() {\n    this.sortKeys();\n    return this.colKeys;\n  }\n\n  getRowKeys() {\n    this.sortKeys();\n    return this.rowKeys;\n  }\n\n  processRecord(record) {\n    // this code is called in a tight loop\n    const colKey = [];\n    const rowKey = [];\n    this.props.cols.forEach((col) => {\n      colKey.push(col in record ? record[col] : 'null');\n    });\n    this.props.rows.forEach((row) => {\n      rowKey.push(row in record ? record[row] : 'null');\n    });\n\n    this.allTotal.push(record);\n\n    const rowStart = this.subtotals.rowEnabled ? 1 : Math.max(1, rowKey.length);\n    const colStart = this.subtotals.colEnabled ? 1 : Math.max(1, colKey.length);\n\n    let isRowSubtotal;\n    let isColSubtotal;\n    for (let ri = rowStart; ri <= rowKey.length; ri += 1) {\n      isRowSubtotal = ri < rowKey.length;\n      const fRowKey = rowKey.slice(0, ri);\n      const flatRowKey = flatKey(fRowKey);\n      if (!this.rowTotals[flatRowKey]) {\n        this.rowKeys.push(fRowKey);\n        this.rowTotals[flatRowKey] = this.getFormattedAggregator(\n        record,\n        rowKey)(\n        this, fRowKey, []);\n      }\n      this.rowTotals[flatRowKey].push(record);\n      this.rowTotals[flatRowKey].isSubtotal = isRowSubtotal;\n    }\n\n    for (let ci = colStart; ci <= colKey.length; ci += 1) {\n      isColSubtotal = ci < colKey.length;\n      const fColKey = colKey.slice(0, ci);\n      const flatColKey = flatKey(fColKey);\n      if (!this.colTotals[flatColKey]) {\n        this.colKeys.push(fColKey);\n        this.colTotals[flatColKey] = this.getFormattedAggregator(\n        record,\n        colKey)(\n        this, [], fColKey);\n      }\n      this.colTotals[flatColKey].push(record);\n      this.colTotals[flatColKey].isSubtotal = isColSubtotal;\n    }\n\n    // And now fill in for all the sub-cells.\n    for (let ri = rowStart; ri <= rowKey.length; ri += 1) {\n      isRowSubtotal = ri < rowKey.length;\n      const fRowKey = rowKey.slice(0, ri);\n      const flatRowKey = flatKey(fRowKey);\n      if (!this.tree[flatRowKey]) {\n        this.tree[flatRowKey] = {};\n      }\n      for (let ci = colStart; ci <= colKey.length; ci += 1) {\n        isColSubtotal = ci < colKey.length;\n        const fColKey = colKey.slice(0, ci);\n        const flatColKey = flatKey(fColKey);\n        if (!this.tree[flatRowKey][flatColKey]) {\n          this.tree[flatRowKey][flatColKey] = this.getFormattedAggregator(\n          record)(\n          this, fRowKey, fColKey);\n        }\n        this.tree[flatRowKey][flatColKey].push(record);\n\n        this.tree[flatRowKey][flatColKey].isRowSubtotal = isRowSubtotal;\n        this.tree[flatRowKey][flatColKey].isColSubtotal = isColSubtotal;\n        this.tree[flatRowKey][flatColKey].isSubtotal =\n        isRowSubtotal || isColSubtotal;\n      }\n    }\n  }\n\n  getAggregator(rowKey, colKey) {\n    let agg;\n    const flatRowKey = flatKey(rowKey);\n    const flatColKey = flatKey(colKey);\n    if (rowKey.length === 0 && colKey.length === 0) {\n      agg = this.allTotal;\n    } else if (rowKey.length === 0) {\n      agg = this.colTotals[flatColKey];\n    } else if (colKey.length === 0) {\n      agg = this.rowTotals[flatRowKey];\n    } else {\n      agg = this.tree[flatRowKey][flatColKey];\n    }\n    return (\n      agg || {\n        value() {\n          return null;\n        },\n        format() {\n          return '';\n        } });\n\n\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n// can handle arrays or jQuery selections of tables\nPivotData.forEachRecord = function (input, processRecord) {\n  if (Array.isArray(input)) {\n    // array of objects\n    return input.map((record) => processRecord(record));\n  }\n  throw new Error((0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.t)('Unknown input format'));\n};\n\nPivotData.defaultProps = {\n  aggregators,\n  cols: [],\n  rows: [],\n  vals: [],\n  aggregatorName: 'Count',\n  sorters: {},\n  rowOrder: 'key_a_to_z',\n  colOrder: 'key_a_to_z' };\n\n\nPivotData.propTypes = {\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_1___default().array), (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func)]).\n  isRequired,\n  aggregatorName: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  cols: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  rows: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  vals: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  valueFilter: prop_types__WEBPACK_IMPORTED_MODULE_1___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool))),\n  sorters: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOfType([\n  (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n  prop_types__WEBPACK_IMPORTED_MODULE_1___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().func))]),\n\n  derivedAttributes: prop_types__WEBPACK_IMPORTED_MODULE_1___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().func)),\n  rowOrder: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOf([\n  'key_a_to_z',\n  'key_z_to_a',\n  'value_a_to_z',\n  'value_z_to_a']),\n\n  colOrder: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOf([\n  'key_a_to_z',\n  'key_z_to_a',\n  'value_a_to_z',\n  'value_z_to_a']) };\n\n\n\n;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(addSeparators, \"addSeparators\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(numberFormat, \"numberFormat\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(rx, \"rx\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(rd, \"rd\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(rz, \"rz\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(naturalSort, \"naturalSort\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(sortAs, \"sortAs\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(getSort, \"getSort\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(usFmt, \"usFmt\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(usFmtInt, \"usFmtInt\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(usFmtPct, \"usFmtPct\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(fmtNonString, \"fmtNonString\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(baseAggregatorTemplates, \"baseAggregatorTemplates\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(extendedAggregatorTemplates, \"extendedAggregatorTemplates\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(aggregatorTemplates, \"aggregatorTemplates\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(aggregators, \"aggregators\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(locales, \"locales\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(mthNamesEn, \"mthNamesEn\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(dayNamesEn, \"dayNamesEn\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(zeroPad, \"zeroPad\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(derivers, \"derivers\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(flatKey, \"flatKey\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");reactHotLoader.register(PivotData, \"PivotData\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9zcmMvcmVhY3QtcGl2b3R0YWJsZS91dGlsaXRpZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQWpPQTtBQUFBO0FBb09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBY0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXBpdm90LXRhYmxlL3NyYy9yZWFjdC1waXZvdHRhYmxlL3V0aWxpdGllcy5qcz9iZjU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgeyB0IH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xyXG5cclxuY29uc3QgYWRkU2VwYXJhdG9ycyA9IGZ1bmN0aW9uIChuU3RyLCB0aG91c2FuZHNTZXAsIGRlY2ltYWxTZXApIHtcclxuICBjb25zdCB4ID0gU3RyaW5nKG5TdHIpLnNwbGl0KCcuJyk7XHJcbiAgbGV0IHgxID0geFswXTtcclxuICBjb25zdCB4MiA9IHgubGVuZ3RoID4gMSA/IGRlY2ltYWxTZXAgKyB4WzFdIDogJyc7XHJcbiAgY29uc3Qgcmd4ID0gLyhcXGQrKShcXGR7M30pLztcclxuICB3aGlsZSAocmd4LnRlc3QoeDEpKSB7XHJcbiAgICB4MSA9IHgxLnJlcGxhY2Uocmd4LCBgJDEke3Rob3VzYW5kc1NlcH0kMmApO1xyXG4gIH1cclxuICByZXR1cm4geDEgKyB4MjtcclxufTtcclxuXHJcbmNvbnN0IG51bWJlckZvcm1hdCA9IGZ1bmN0aW9uIChvcHRzSW4pIHtcclxuICBjb25zdCBkZWZhdWx0cyA9IHtcclxuICAgIGRpZ2l0c0FmdGVyRGVjaW1hbDogMixcclxuICAgIHNjYWxlcjogMSxcclxuICAgIHRob3VzYW5kc1NlcDogJywnLFxyXG4gICAgZGVjaW1hbFNlcDogJy4nLFxyXG4gICAgcHJlZml4OiAnJyxcclxuICAgIHN1ZmZpeDogJycsXHJcbiAgfTtcclxuICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0cywgLi4ub3B0c0luIH07XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHgpIHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gYWRkU2VwYXJhdG9ycyhcclxuICAgICAgKG9wdHMuc2NhbGVyICogeCkudG9GaXhlZChvcHRzLmRpZ2l0c0FmdGVyRGVjaW1hbCksXHJcbiAgICAgIG9wdHMudGhvdXNhbmRzU2VwLFxyXG4gICAgICBvcHRzLmRlY2ltYWxTZXAsXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGAke29wdHMucHJlZml4fSR7cmVzdWx0fSR7b3B0cy5zdWZmaXh9YDtcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgcnggPSAvKFxcZCspfChcXEQrKS9nO1xyXG5jb25zdCByZCA9IC9cXGQvO1xyXG5jb25zdCByeiA9IC9eMC87XHJcbmNvbnN0IG5hdHVyYWxTb3J0ID0gKGFzLCBicykgPT4ge1xyXG4gIC8vIG51bGxzIGZpcnN0XHJcbiAgaWYgKGJzICE9PSBudWxsICYmIGFzID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIGlmIChhcyAhPT0gbnVsbCAmJiBicyA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG5cclxuICAvLyB0aGVuIHJhdyBOYU5zXHJcbiAgaWYgKHR5cGVvZiBhcyA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzTmFOKGFzKSkge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGJzID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNOYU4oYnMpKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcblxyXG4gIC8vIG51bWJlcnMgYW5kIG51bWJlcnkgc3RyaW5ncyBncm91cCB0b2dldGhlclxyXG4gIGNvbnN0IG5hcyA9IE51bWJlcihhcyk7XHJcbiAgY29uc3QgbmJzID0gTnVtYmVyKGJzKTtcclxuICBpZiAobmFzIDwgbmJzKSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIGlmIChuYXMgPiBuYnMpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgLy8gd2l0aGluIHRoYXQsIHRydWUgbnVtYmVycyBiZWZvcmUgbnVtYmVyeSBzdHJpbmdzXHJcbiAgaWYgKHR5cGVvZiBhcyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGJzICE9PSAnbnVtYmVyJykge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGJzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXMgIT09ICdudW1iZXInKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBhcyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGJzID09PSAnbnVtYmVyJykge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvLyAnSW5maW5pdHknIGlzIGEgdGV4dHVhbCBudW1iZXIsIHNvIGxlc3MgdGhhbiAnQSdcclxuICBpZiAoTnVtYmVyLmlzTmFOKG5icykgJiYgIU51bWJlci5pc05hTihuYXMpKSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIGlmIChOdW1iZXIuaXNOYU4obmFzKSAmJiAhTnVtYmVyLmlzTmFOKG5icykpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgLy8gZmluYWxseSwgXCJzbWFydFwiIHN0cmluZyBzb3J0aW5nIHBlciBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzczNDIxLzExMjg3MVxyXG4gIGxldCBhID0gU3RyaW5nKGFzKTtcclxuICBsZXQgYiA9IFN0cmluZyhicyk7XHJcbiAgaWYgKGEgPT09IGIpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBpZiAoIXJkLnRlc3QoYSkgfHwgIXJkLnRlc3QoYikpIHtcclxuICAgIHJldHVybiBhID4gYiA/IDEgOiAtMTtcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgZGlnaXRzXHJcbiAgYSA9IGEubWF0Y2gocngpO1xyXG4gIGIgPSBiLm1hdGNoKHJ4KTtcclxuICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGExID0gYS5zaGlmdCgpO1xyXG4gICAgY29uc3QgYjEgPSBiLnNoaWZ0KCk7XHJcbiAgICBpZiAoYTEgIT09IGIxKSB7XHJcbiAgICAgIGlmIChyZC50ZXN0KGExKSAmJiByZC50ZXN0KGIxKSkge1xyXG4gICAgICAgIHJldHVybiBhMS5yZXBsYWNlKHJ6LCAnLjAnKSAtIGIxLnJlcGxhY2UocnosICcuMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhMSA+IGIxID8gMSA6IC0xO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcclxufTtcclxuXHJcbmNvbnN0IHNvcnRBcyA9IGZ1bmN0aW9uIChvcmRlcikge1xyXG4gIGNvbnN0IG1hcHBpbmcgPSB7fTtcclxuXHJcbiAgLy8gc29ydCBsb3dlcmNhc2VkIGtleXMgc2ltaWxhcmx5XHJcbiAgY29uc3QgbE1hcHBpbmcgPSB7fTtcclxuICBvcmRlci5mb3JFYWNoKChlbGVtZW50LCBpKSA9PiB7XHJcbiAgICBtYXBwaW5nW2VsZW1lbnRdID0gaTtcclxuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgbE1hcHBpbmdbZWxlbWVudC50b0xvd2VyQ2FzZSgpXSA9IGk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYSBpbiBtYXBwaW5nICYmIGIgaW4gbWFwcGluZykge1xyXG4gICAgICByZXR1cm4gbWFwcGluZ1thXSAtIG1hcHBpbmdbYl07XHJcbiAgICB9XHJcbiAgICBpZiAoYSBpbiBtYXBwaW5nKSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChiIGluIG1hcHBpbmcpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoYSBpbiBsTWFwcGluZyAmJiBiIGluIGxNYXBwaW5nKSB7XHJcbiAgICAgIHJldHVybiBsTWFwcGluZ1thXSAtIGxNYXBwaW5nW2JdO1xyXG4gICAgfVxyXG4gICAgaWYgKGEgaW4gbE1hcHBpbmcpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGIgaW4gbE1hcHBpbmcpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmF0dXJhbFNvcnQoYSwgYik7XHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IGdldFNvcnQgPSBmdW5jdGlvbiAoc29ydGVycywgYXR0cikge1xyXG4gIGlmIChzb3J0ZXJzKSB7XHJcbiAgICBpZiAodHlwZW9mIHNvcnRlcnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY29uc3Qgc29ydCA9IHNvcnRlcnMoYXR0cik7XHJcbiAgICAgIGlmICh0eXBlb2Ygc29ydCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBzb3J0O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGF0dHIgaW4gc29ydGVycykge1xyXG4gICAgICByZXR1cm4gc29ydGVyc1thdHRyXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG5hdHVyYWxTb3J0O1xyXG59O1xyXG5cclxuLy8gYWdncmVnYXRvciB0ZW1wbGF0ZXMgZGVmYXVsdCB0byBVUyBudW1iZXIgZm9ybWF0dGluZyBidXQgdGhpcyBpcyBvdmVycmlkYWJsZVxyXG5jb25zdCB1c0ZtdCA9IG51bWJlckZvcm1hdCgpO1xyXG5jb25zdCB1c0ZtdEludCA9IG51bWJlckZvcm1hdCh7IGRpZ2l0c0FmdGVyRGVjaW1hbDogMCB9KTtcclxuY29uc3QgdXNGbXRQY3QgPSBudW1iZXJGb3JtYXQoe1xyXG4gIGRpZ2l0c0FmdGVyRGVjaW1hbDogMSxcclxuICBzY2FsZXI6IDEwMCxcclxuICBzdWZmaXg6ICclJyxcclxufSk7XHJcblxyXG5jb25zdCBmbXROb25TdHJpbmcgPSBmb3JtYXR0ZXIgPT4geCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgPyB4IDogZm9ybWF0dGVyKHgpO1xyXG5cclxuY29uc3QgYmFzZUFnZ3JlZ2F0b3JUZW1wbGF0ZXMgPSB7XHJcbiAgY291bnQoZm9ybWF0dGVyID0gdXNGbXRJbnQpIHtcclxuICAgIHJldHVybiAoKSA9PlxyXG4gICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgICAgcHVzaCgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHZhbHVlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBmb3JtYXQ6IGZvcm1hdHRlcixcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHVuaXF1ZXMoZm4sIGZvcm1hdHRlciA9IHVzRm10SW50KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKFthdHRyXSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB1bmlxOiBbXSxcclxuICAgICAgICAgIHB1c2gocmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuZnJvbSh0aGlzLnVuaXEpLmluY2x1ZGVzKHJlY29yZFthdHRyXSkpIHtcclxuICAgICAgICAgICAgICB0aGlzLnVuaXEucHVzaChyZWNvcmRbYXR0cl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLnVuaXEpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZvcm1hdDogZm10Tm9uU3RyaW5nKGZvcm1hdHRlciksXHJcbiAgICAgICAgICBudW1JbnB1dHM6IHR5cGVvZiBhdHRyICE9PSAndW5kZWZpbmVkJyA/IDAgOiAxLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHN1bShmb3JtYXR0ZXIgPSB1c0ZtdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChbYXR0cl0pIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VtOiAwLFxyXG4gICAgICAgICAgcHVzaChyZWNvcmQpIHtcclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihOdW1iZXIocmVjb3JkW2F0dHJdKSkpIHtcclxuICAgICAgICAgICAgICB0aGlzLnN1bSA9IHJlY29yZFthdHRyXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLnN1bSArPSBwYXJzZUZsb2F0KHJlY29yZFthdHRyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB2YWx1ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VtO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZvcm1hdDogZm10Tm9uU3RyaW5nKGZvcm1hdHRlciksXHJcbiAgICAgICAgICBudW1JbnB1dHM6IHR5cGVvZiBhdHRyICE9PSAndW5kZWZpbmVkJyA/IDAgOiAxLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIGV4dHJlbWVzKG1vZGUsIGZvcm1hdHRlciA9IHVzRm10KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKFthdHRyXSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdmFsOiBudWxsLFxyXG4gICAgICAgICAgc29ydGVyOiBnZXRTb3J0KFxyXG4gICAgICAgICAgICB0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhLnNvcnRlcnMgOiBudWxsLFxyXG4gICAgICAgICAgICBhdHRyLFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIHB1c2gocmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSByZWNvcmRbYXR0cl07XHJcbiAgICAgICAgICAgIGlmIChbJ21pbicsICdtYXgnXS5pbmNsdWRlcyhtb2RlKSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IE51bWJlcih4KTtcclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGNvZXJjZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsID1cclxuICAgICAgICAgICAgICAgICAgIXRoaXMudmFsIHx8XHJcbiAgICAgICAgICAgICAgICAgIChtb2RlID09PSAnbWluJyAmJiB4IDwgdGhpcy52YWwpIHx8XHJcbiAgICAgICAgICAgICAgICAgIChtb2RlID09PSAnbWF4JyAmJiB4ID4gdGhpcy52YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB4XHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnZhbDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWwgPSBNYXRoW21vZGVdKFxyXG4gICAgICAgICAgICAgICAgICBjb2VyY2VkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMudmFsICE9PSBudWxsID8gdGhpcy52YWwgOiBjb2VyY2VkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICBtb2RlID09PSAnZmlyc3QnICYmXHJcbiAgICAgICAgICAgICAgdGhpcy5zb3J0ZXIoeCwgdGhpcy52YWwgIT09IG51bGwgPyB0aGlzLnZhbCA6IHgpIDw9IDBcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy52YWwgPSB4O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgIG1vZGUgPT09ICdsYXN0JyAmJlxyXG4gICAgICAgICAgICAgIHRoaXMuc29ydGVyKHgsIHRoaXMudmFsICE9PSBudWxsID8gdGhpcy52YWwgOiB4KSA+PSAwXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIHRoaXMudmFsID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHZhbHVlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWw7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZm9ybWF0KHgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIoeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbnVtSW5wdXRzOiB0eXBlb2YgYXR0ciAhPT0gJ3VuZGVmaW5lZCcgPyAwIDogMSxcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBxdWFudGlsZShxLCBmb3JtYXR0ZXIgPSB1c0ZtdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChbYXR0cl0pIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdmFsczogW10sXHJcbiAgICAgICAgICBzdHJNYXA6IHt9LFxyXG4gICAgICAgICAgcHVzaChyZWNvcmQpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsID0gcmVjb3JkW2F0dHJdO1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gTnVtYmVyKHZhbCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHgpKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5zdHJNYXBbdmFsXSA9ICh0aGlzLnN0ck1hcFt2YWxdIHx8IDApICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLnZhbHMucHVzaCh4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHZhbHVlKCkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgdGhpcy52YWxzLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3RyTWFwKS5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnN0ck1hcCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnN0ck1hcCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdHJNYXApO1xyXG4gICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCAlIDIgIT09IDBcclxuICAgICAgICAgICAgICAgID8ga2V5c1ttaWRkbGVdXHJcbiAgICAgICAgICAgICAgICA6IChrZXlzW21pZGRsZSAtIDFdICsga2V5c1ttaWRkbGVdKSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudmFscy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSAodGhpcy52YWxzLmxlbmd0aCAtIDEpICogcTtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHNbTWF0aC5mbG9vcihpKV0gKyB0aGlzLnZhbHNbTWF0aC5jZWlsKGkpXSkgLyAyLjA7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZm9ybWF0OiBmbXROb25TdHJpbmcoZm9ybWF0dGVyKSxcclxuICAgICAgICAgIG51bUlucHV0czogdHlwZW9mIGF0dHIgIT09ICd1bmRlZmluZWQnID8gMCA6IDEsXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgcnVubmluZ1N0YXQobW9kZSA9ICdtZWFuJywgZGRvZiA9IDEsIGZvcm1hdHRlciA9IHVzRm10KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKFthdHRyXSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBuOiAwLjAsXHJcbiAgICAgICAgICBtOiAwLjAsXHJcbiAgICAgICAgICBzOiAwLjAsXHJcbiAgICAgICAgICBzdHJWYWx1ZTogbnVsbCxcclxuICAgICAgICAgIHB1c2gocmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBOdW1iZXIocmVjb3JkW2F0dHJdKTtcclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih4KSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RyVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHJlY29yZFthdHRyXSA9PT0gJ3N0cmluZycgPyByZWNvcmRbYXR0cl0gOiB0aGlzLnN0clZhbHVlO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm4gKz0gMS4wO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5uID09PSAxLjApIHtcclxuICAgICAgICAgICAgICB0aGlzLm0gPSB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1OZXcgPSB0aGlzLm0gKyAoeCAtIHRoaXMubSkgLyB0aGlzLm47XHJcbiAgICAgICAgICAgIHRoaXMucyArPSAoeCAtIHRoaXMubSkgKiAoeCAtIG1OZXcpO1xyXG4gICAgICAgICAgICB0aGlzLm0gPSBtTmV3O1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHZhbHVlKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJWYWx1ZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ21lYW4nKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRoaXMubiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyAwO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm4gPD0gZGRvZikge1xyXG4gICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zIC8gKHRoaXMubiAtIGRkb2YpO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3N0ZGV2JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5zIC8gKHRoaXMubiAtIGRkb2YpKTtcclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG1vZGUgZm9yIHJ1bm5pbmdTdGF0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBmb3JtYXQ6IGZtdE5vblN0cmluZyhmb3JtYXR0ZXIpLFxyXG4gICAgICAgICAgbnVtSW5wdXRzOiB0eXBlb2YgYXR0ciAhPT0gJ3VuZGVmaW5lZCcgPyAwIDogMSxcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBzdW1PdmVyU3VtKGZvcm1hdHRlciA9IHVzRm10KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKFtudW0sIGRlbm9tXSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdW1OdW06IDAsXHJcbiAgICAgICAgICBzdW1EZW5vbTogMCxcclxuICAgICAgICAgIHB1c2gocmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKE51bWJlcihyZWNvcmRbbnVtXSkpKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5zdW1OdW0gKz0gcGFyc2VGbG9hdChyZWNvcmRbbnVtXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyKHJlY29yZFtkZW5vbV0pKSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuc3VtRGVub20gKz0gcGFyc2VGbG9hdChyZWNvcmRbZGVub21dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHZhbHVlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdW1OdW0gLyB0aGlzLnN1bURlbm9tO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZvcm1hdDogZm9ybWF0dGVyLFxyXG4gICAgICAgICAgbnVtSW5wdXRzOlxyXG4gICAgICAgICAgICB0eXBlb2YgbnVtICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVub20gIT09ICd1bmRlZmluZWQnID8gMCA6IDIsXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgZnJhY3Rpb25PZih3cmFwcGVkLCB0eXBlID0gJ3RvdGFsJywgZm9ybWF0dGVyID0gdXNGbXRQY3QpIHtcclxuICAgIHJldHVybiAoLi4ueCkgPT5cclxuICAgICAgZnVuY3Rpb24gKGRhdGEsIHJvd0tleSwgY29sS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNlbGVjdG9yOiB7IHRvdGFsOiBbW10sIFtdXSwgcm93OiBbcm93S2V5LCBbXV0sIGNvbDogW1tdLCBjb2xLZXldIH1bXHJcbiAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICBpbm5lcjogd3JhcHBlZCguLi5BcnJheS5mcm9tKHggfHwgW10pKShkYXRhLCByb3dLZXksIGNvbEtleSksXHJcbiAgICAgICAgICBwdXNoKHJlY29yZCkge1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gocmVjb3JkKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBmb3JtYXQ6IGZtdE5vblN0cmluZyhmb3JtYXR0ZXIpLFxyXG4gICAgICAgICAgdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjYyA9IGRhdGFcclxuICAgICAgICAgICAgICAuZ2V0QWdncmVnYXRvciguLi5BcnJheS5mcm9tKHRoaXMuc2VsZWN0b3IgfHwgW10pKVxyXG4gICAgICAgICAgICAgIC5pbm5lci52YWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhY2MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIudmFsdWUoKSAvIGFjYztcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBudW1JbnB1dHM6IHdyYXBwZWQoLi4uQXJyYXkuZnJvbSh4IHx8IFtdKSkoKS5udW1JbnB1dHMsXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3QgZXh0ZW5kZWRBZ2dyZWdhdG9yVGVtcGxhdGVzID0ge1xyXG4gIGNvdW50VW5pcXVlKGYpIHtcclxuICAgIHJldHVybiBiYXNlQWdncmVnYXRvclRlbXBsYXRlcy51bmlxdWVzKHggPT4geC5sZW5ndGgsIGYpO1xyXG4gIH0sXHJcbiAgbGlzdFVuaXF1ZShzLCBmKSB7XHJcbiAgICByZXR1cm4gYmFzZUFnZ3JlZ2F0b3JUZW1wbGF0ZXMudW5pcXVlcyh4ID0+IHguam9pbihzKSwgZiB8fCAoeCA9PiB4KSk7XHJcbiAgfSxcclxuICBtYXgoZikge1xyXG4gICAgcmV0dXJuIGJhc2VBZ2dyZWdhdG9yVGVtcGxhdGVzLmV4dHJlbWVzKCdtYXgnLCBmKTtcclxuICB9LFxyXG4gIG1pbihmKSB7XHJcbiAgICByZXR1cm4gYmFzZUFnZ3JlZ2F0b3JUZW1wbGF0ZXMuZXh0cmVtZXMoJ21pbicsIGYpO1xyXG4gIH0sXHJcbiAgZmlyc3QoZikge1xyXG4gICAgcmV0dXJuIGJhc2VBZ2dyZWdhdG9yVGVtcGxhdGVzLmV4dHJlbWVzKCdmaXJzdCcsIGYpO1xyXG4gIH0sXHJcbiAgbGFzdChmKSB7XHJcbiAgICByZXR1cm4gYmFzZUFnZ3JlZ2F0b3JUZW1wbGF0ZXMuZXh0cmVtZXMoJ2xhc3QnLCBmKTtcclxuICB9LFxyXG4gIG1lZGlhbihmKSB7XHJcbiAgICByZXR1cm4gYmFzZUFnZ3JlZ2F0b3JUZW1wbGF0ZXMucXVhbnRpbGUoMC41LCBmKTtcclxuICB9LFxyXG4gIGF2ZXJhZ2UoZikge1xyXG4gICAgcmV0dXJuIGJhc2VBZ2dyZWdhdG9yVGVtcGxhdGVzLnJ1bm5pbmdTdGF0KCdtZWFuJywgMSwgZik7XHJcbiAgfSxcclxuICB2YXIoZGRvZiwgZikge1xyXG4gICAgcmV0dXJuIGJhc2VBZ2dyZWdhdG9yVGVtcGxhdGVzLnJ1bm5pbmdTdGF0KCd2YXInLCBkZG9mLCBmKTtcclxuICB9LFxyXG4gIHN0ZGV2KGRkb2YsIGYpIHtcclxuICAgIHJldHVybiBiYXNlQWdncmVnYXRvclRlbXBsYXRlcy5ydW5uaW5nU3RhdCgnc3RkZXYnLCBkZG9mLCBmKTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3QgYWdncmVnYXRvclRlbXBsYXRlcyA9IHtcclxuICAuLi5iYXNlQWdncmVnYXRvclRlbXBsYXRlcyxcclxuICAuLi5leHRlbmRlZEFnZ3JlZ2F0b3JUZW1wbGF0ZXMsXHJcbn07XHJcblxyXG4vLyBkZWZhdWx0IGFnZ3JlZ2F0b3JzICYgcmVuZGVyZXJzIHVzZSBVUyBuYW1pbmcgYW5kIG51bWJlciBmb3JtYXR0aW5nXHJcbmNvbnN0IGFnZ3JlZ2F0b3JzID0gKHRwbCA9PiAoe1xyXG4gIENvdW50OiB0cGwuY291bnQodXNGbXRJbnQpLFxyXG4gICdDb3VudCBVbmlxdWUgVmFsdWVzJzogdHBsLmNvdW50VW5pcXVlKHVzRm10SW50KSxcclxuICAnTGlzdCBVbmlxdWUgVmFsdWVzJzogdHBsLmxpc3RVbmlxdWUoJywgJyksXHJcbiAgU3VtOiB0cGwuc3VtKHVzRm10KSxcclxuICAnSW50ZWdlciBTdW0nOiB0cGwuc3VtKHVzRm10SW50KSxcclxuICBBdmVyYWdlOiB0cGwuYXZlcmFnZSh1c0ZtdCksXHJcbiAgTWVkaWFuOiB0cGwubWVkaWFuKHVzRm10KSxcclxuICAnU2FtcGxlIFZhcmlhbmNlJzogdHBsLnZhcigxLCB1c0ZtdCksXHJcbiAgJ1NhbXBsZSBTdGFuZGFyZCBEZXZpYXRpb24nOiB0cGwuc3RkZXYoMSwgdXNGbXQpLFxyXG4gIE1pbmltdW06IHRwbC5taW4odXNGbXQpLFxyXG4gIE1heGltdW06IHRwbC5tYXgodXNGbXQpLFxyXG4gIEZpcnN0OiB0cGwuZmlyc3QodXNGbXQpLFxyXG4gIExhc3Q6IHRwbC5sYXN0KHVzRm10KSxcclxuICAnU3VtIG92ZXIgU3VtJzogdHBsLnN1bU92ZXJTdW0odXNGbXQpLFxyXG4gICdTdW0gYXMgRnJhY3Rpb24gb2YgVG90YWwnOiB0cGwuZnJhY3Rpb25PZih0cGwuc3VtKCksICd0b3RhbCcsIHVzRm10UGN0KSxcclxuICAnU3VtIGFzIEZyYWN0aW9uIG9mIFJvd3MnOiB0cGwuZnJhY3Rpb25PZih0cGwuc3VtKCksICdyb3cnLCB1c0ZtdFBjdCksXHJcbiAgJ1N1bSBhcyBGcmFjdGlvbiBvZiBDb2x1bW5zJzogdHBsLmZyYWN0aW9uT2YodHBsLnN1bSgpLCAnY29sJywgdXNGbXRQY3QpLFxyXG4gICdDb3VudCBhcyBGcmFjdGlvbiBvZiBUb3RhbCc6IHRwbC5mcmFjdGlvbk9mKHRwbC5jb3VudCgpLCAndG90YWwnLCB1c0ZtdFBjdCksXHJcbiAgJ0NvdW50IGFzIEZyYWN0aW9uIG9mIFJvd3MnOiB0cGwuZnJhY3Rpb25PZih0cGwuY291bnQoKSwgJ3JvdycsIHVzRm10UGN0KSxcclxuICAnQ291bnQgYXMgRnJhY3Rpb24gb2YgQ29sdW1ucyc6IHRwbC5mcmFjdGlvbk9mKHRwbC5jb3VudCgpLCAnY29sJywgdXNGbXRQY3QpLFxyXG59KSkoYWdncmVnYXRvclRlbXBsYXRlcyk7XHJcblxyXG5jb25zdCBsb2NhbGVzID0ge1xyXG4gIGVuOiB7XHJcbiAgICBhZ2dyZWdhdG9ycyxcclxuICAgIGxvY2FsZVN0cmluZ3M6IHtcclxuICAgICAgcmVuZGVyRXJyb3I6ICdBbiBlcnJvciBvY2N1cnJlZCByZW5kZXJpbmcgdGhlIFBpdm90VGFibGUgcmVzdWx0cy4nLFxyXG4gICAgICBjb21wdXRlRXJyb3I6ICdBbiBlcnJvciBvY2N1cnJlZCBjb21wdXRpbmcgdGhlIFBpdm90VGFibGUgcmVzdWx0cy4nLFxyXG4gICAgICB1aVJlbmRlckVycm9yOiAnQW4gZXJyb3Igb2NjdXJyZWQgcmVuZGVyaW5nIHRoZSBQaXZvdFRhYmxlIFVJLicsXHJcbiAgICAgIHNlbGVjdEFsbDogJ1NlbGVjdCBBbGwnLFxyXG4gICAgICBzZWxlY3ROb25lOiAnU2VsZWN0IE5vbmUnLFxyXG4gICAgICB0b29NYW55OiAnKHRvbyBtYW55IHRvIGxpc3QpJyxcclxuICAgICAgZmlsdGVyUmVzdWx0czogJ0ZpbHRlciB2YWx1ZXMnLFxyXG4gICAgICBhcHBseTogJ0FwcGx5JyxcclxuICAgICAgY2FuY2VsOiAnQ2FuY2VsJyxcclxuICAgICAgdG90YWxzOiAnVG90YWxzJyxcclxuICAgICAgdnM6ICd2cycsXHJcbiAgICAgIGJ5OiAnYnknLFxyXG4gICAgfSxcclxuICB9LFxyXG59O1xyXG5cclxuLy8gZGF0ZUZvcm1hdCBkZXJpdmVyIGwxMG4gcmVxdWlyZXMgbW9udGggYW5kIGRheSBuYW1lcyB0byBiZSBwYXNzZWQgaW4gZGlyZWN0bHlcclxuY29uc3QgbXRoTmFtZXNFbiA9IFtcclxuICAnSmFuJyxcclxuICAnRmViJyxcclxuICAnTWFyJyxcclxuICAnQXByJyxcclxuICAnTWF5JyxcclxuICAnSnVuJyxcclxuICAnSnVsJyxcclxuICAnQXVnJyxcclxuICAnU2VwJyxcclxuICAnT2N0JyxcclxuICAnTm92JyxcclxuICAnRGVjJyxcclxuXTtcclxuY29uc3QgZGF5TmFtZXNFbiA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J107XHJcbmNvbnN0IHplcm9QYWQgPSBudW1iZXIgPT4gYDAke251bWJlcn1gLnN1YnN0cigtMiwgMik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xyXG5cclxuY29uc3QgZGVyaXZlcnMgPSB7XHJcbiAgYmluKGNvbCwgYmluV2lkdGgpIHtcclxuICAgIHJldHVybiByZWNvcmQgPT4gcmVjb3JkW2NvbF0gLSAocmVjb3JkW2NvbF0gJSBiaW5XaWR0aCk7XHJcbiAgfSxcclxuICBkYXRlRm9ybWF0KFxyXG4gICAgY29sLFxyXG4gICAgZm9ybWF0U3RyaW5nLFxyXG4gICAgdXRjT3V0cHV0ID0gZmFsc2UsXHJcbiAgICBtdGhOYW1lcyA9IG10aE5hbWVzRW4sXHJcbiAgICBkYXlOYW1lcyA9IGRheU5hbWVzRW4sXHJcbiAgKSB7XHJcbiAgICBjb25zdCB1dGMgPSB1dGNPdXRwdXQgPyAnVVRDJyA6ICcnO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2UocmVjb3JkW2NvbF0pKTtcclxuICAgICAgaWYgKE51bWJlci5pc05hTihkYXRlKSkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0U3RyaW5nLnJlcGxhY2UoLyUoLikvZywgZnVuY3Rpb24gKG0sIHApIHtcclxuICAgICAgICBzd2l0Y2ggKHApIHtcclxuICAgICAgICAgIGNhc2UgJ3knOlxyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZVtgZ2V0JHt1dGN9RnVsbFllYXJgXSgpO1xyXG4gICAgICAgICAgY2FzZSAnbSc6XHJcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkKGRhdGVbYGdldCR7dXRjfU1vbnRoYF0oKSArIDEpO1xyXG4gICAgICAgICAgY2FzZSAnbic6XHJcbiAgICAgICAgICAgIHJldHVybiBtdGhOYW1lc1tkYXRlW2BnZXQke3V0Y31Nb250aGBdKCldO1xyXG4gICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkKGRhdGVbYGdldCR7dXRjfURhdGVgXSgpKTtcclxuICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICByZXR1cm4gZGF5TmFtZXNbZGF0ZVtgZ2V0JHt1dGN9RGF5YF0oKV07XHJcbiAgICAgICAgICBjYXNlICd4JzpcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVbYGdldCR7dXRjfURheWBdKCk7XHJcbiAgICAgICAgICBjYXNlICdIJzpcclxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWQoZGF0ZVtgZ2V0JHt1dGN9SG91cnNgXSgpKTtcclxuICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZChkYXRlW2BnZXQke3V0Y31NaW51dGVzYF0oKSk7XHJcbiAgICAgICAgICBjYXNlICdTJzpcclxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWQoZGF0ZVtgZ2V0JHt1dGN9U2Vjb25kc2BdKCkpO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGAlJHtwfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEdpdmVuIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSB2YWx1ZXMsIGNvbnZlcnQgdG8gYSBrZXkgdGhhdFxyXG4vLyBjYW4gYmUgdXNlZCBpbiBvYmplY3RzLlxyXG5jb25zdCBmbGF0S2V5ID0gYXR0clZhbHMgPT4gYXR0clZhbHMuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKDApKTtcclxuXHJcbi8qXHJcbkRhdGEgTW9kZWwgY2xhc3NcclxuKi9cclxuXHJcbmNsYXNzIFBpdm90RGF0YSB7XHJcbiAgY29uc3RydWN0b3IoaW5wdXRQcm9wcyA9IHt9LCBzdWJ0b3RhbHMgPSB7fSkge1xyXG4gICAgdGhpcy5wcm9wcyA9IHsgLi4uUGl2b3REYXRhLmRlZmF1bHRQcm9wcywgLi4uaW5wdXRQcm9wcyB9O1xyXG4gICAgdGhpcy5wcm9jZXNzUmVjb3JkID0gdGhpcy5wcm9jZXNzUmVjb3JkLmJpbmQodGhpcyk7XHJcbiAgICBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoXHJcbiAgICAgIFBpdm90RGF0YS5wcm9wVHlwZXMsXHJcbiAgICAgIHRoaXMucHJvcHMsXHJcbiAgICAgICdwcm9wJyxcclxuICAgICAgJ1Bpdm90RGF0YScsXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuYWdncmVnYXRvciA9IHRoaXMucHJvcHNcclxuICAgICAgLmFnZ3JlZ2F0b3JzRmFjdG9yeSh0aGlzLnByb3BzLmRlZmF1bHRGb3JtYXR0ZXIpXHJcbiAgICAgIFt0aGlzLnByb3BzLmFnZ3JlZ2F0b3JOYW1lXSh0aGlzLnByb3BzLnZhbHMpO1xyXG4gICAgdGhpcy5mb3JtYXR0ZWRBZ2dyZWdhdG9ycyA9XHJcbiAgICAgIHRoaXMucHJvcHMuY3VzdG9tRm9ybWF0dGVycyAmJlxyXG4gICAgICBPYmplY3QuZW50cmllcyh0aGlzLnByb3BzLmN1c3RvbUZvcm1hdHRlcnMpLnJlZHVjZShcclxuICAgICAgICAoYWNjLCBba2V5LCBjb2x1bW5Gb3JtYXR0ZXJdKSA9PiB7XHJcbiAgICAgICAgICBhY2Nba2V5XSA9IHt9O1xyXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29sdW1uRm9ybWF0dGVyKS5mb3JFYWNoKChbY29sdW1uLCBmb3JtYXR0ZXJdKSA9PiB7XHJcbiAgICAgICAgICAgIGFjY1trZXldW2NvbHVtbl0gPSB0aGlzLnByb3BzXHJcbiAgICAgICAgICAgICAgLmFnZ3JlZ2F0b3JzRmFjdG9yeShmb3JtYXR0ZXIpXHJcbiAgICAgICAgICAgICAgW3RoaXMucHJvcHMuYWdncmVnYXRvck5hbWVdKHRoaXMucHJvcHMudmFscyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7fSxcclxuICAgICAgKTtcclxuICAgIHRoaXMudHJlZSA9IHt9O1xyXG4gICAgdGhpcy5yb3dLZXlzID0gW107XHJcbiAgICB0aGlzLmNvbEtleXMgPSBbXTtcclxuICAgIHRoaXMucm93VG90YWxzID0ge307XHJcbiAgICB0aGlzLmNvbFRvdGFscyA9IHt9O1xyXG4gICAgdGhpcy5hbGxUb3RhbCA9IHRoaXMuYWdncmVnYXRvcih0aGlzLCBbXSwgW10pO1xyXG4gICAgdGhpcy5zdWJ0b3RhbHMgPSBzdWJ0b3RhbHM7XHJcbiAgICB0aGlzLnNvcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBpbnB1dCwgYWNjdW11bGF0aW5nIGRhdGEgZm9yIGNlbGxzXHJcbiAgICBQaXZvdERhdGEuZm9yRWFjaFJlY29yZCh0aGlzLnByb3BzLmRhdGEsIHRoaXMucHJvY2Vzc1JlY29yZCk7XHJcbiAgfVxyXG5cclxuICBnZXRGb3JtYXR0ZWRBZ2dyZWdhdG9yKHJlY29yZCwgdG90YWxzS2V5cykge1xyXG4gICAgaWYgKCF0aGlzLmZvcm1hdHRlZEFnZ3JlZ2F0b3JzKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFnZ3JlZ2F0b3I7XHJcbiAgICB9XHJcbiAgICBjb25zdCBbZ3JvdXBOYW1lLCBncm91cFZhbHVlXSA9XHJcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlY29yZCkuZmluZChcclxuICAgICAgICAoW25hbWUsIHZhbHVlXSkgPT5cclxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkQWdncmVnYXRvcnNbbmFtZV0gJiZcclxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkQWdncmVnYXRvcnNbbmFtZV1bdmFsdWVdLFxyXG4gICAgICApIHx8IFtdO1xyXG4gICAgaWYgKFxyXG4gICAgICAhZ3JvdXBOYW1lIHx8XHJcbiAgICAgICFncm91cFZhbHVlIHx8XHJcbiAgICAgICh0b3RhbHNLZXlzICYmICF0b3RhbHNLZXlzLmluY2x1ZGVzKGdyb3VwVmFsdWUpKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFnZ3JlZ2F0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZWRBZ2dyZWdhdG9yc1tncm91cE5hbWVdW2dyb3VwVmFsdWVdIHx8IHRoaXMuYWdncmVnYXRvcjtcclxuICB9XHJcblxyXG4gIGFyclNvcnQoYXR0cnMsIHBhcnRpYWxPblRvcCwgcmV2ZXJzZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBzb3J0ZXJzQXJyID0gYXR0cnMubWFwKGEgPT4gZ2V0U29ydCh0aGlzLnByb3BzLnNvcnRlcnMsIGEpKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkgKz0gMSkge1xyXG4gICAgICAgIGNvbnN0IHNvcnRlciA9IHNvcnRlcnNBcnJbaV07XHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IHJldmVyc2UgPyBzb3J0ZXIoYltpXSwgYVtpXSkgOiBzb3J0ZXIoYVtpXSwgYltpXSk7XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcclxuICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFydGlhbE9uVG9wID8gYS5sZW5ndGggLSBiLmxlbmd0aCA6IGIubGVuZ3RoIC0gYS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc29ydEtleXMoKSB7XHJcbiAgICBpZiAoIXRoaXMuc29ydGVkKSB7XHJcbiAgICAgIHRoaXMuc29ydGVkID0gdHJ1ZTtcclxuICAgICAgY29uc3QgdiA9IChyLCBjKSA9PiB0aGlzLmdldEFnZ3JlZ2F0b3IociwgYykudmFsdWUoKTtcclxuICAgICAgc3dpdGNoICh0aGlzLnByb3BzLnJvd09yZGVyKSB7XHJcbiAgICAgICAgY2FzZSAna2V5X3pfdG9fYSc6XHJcbiAgICAgICAgICB0aGlzLnJvd0tleXMuc29ydChcclxuICAgICAgICAgICAgdGhpcy5hcnJTb3J0KHRoaXMucHJvcHMucm93cywgdGhpcy5zdWJ0b3RhbHMucm93UGFydGlhbE9uVG9wLCB0cnVlKSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd2YWx1ZV9hX3RvX3onOlxyXG4gICAgICAgICAgdGhpcy5yb3dLZXlzLnNvcnQoKGEsIGIpID0+IG5hdHVyYWxTb3J0KHYoYSwgW10pLCB2KGIsIFtdKSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndmFsdWVfel90b19hJzpcclxuICAgICAgICAgIHRoaXMucm93S2V5cy5zb3J0KChhLCBiKSA9PiAtbmF0dXJhbFNvcnQodihhLCBbXSksIHYoYiwgW10pKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhpcy5yb3dLZXlzLnNvcnQoXHJcbiAgICAgICAgICAgIHRoaXMuYXJyU29ydCh0aGlzLnByb3BzLnJvd3MsIHRoaXMuc3VidG90YWxzLnJvd1BhcnRpYWxPblRvcCksXHJcbiAgICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5jb2xPcmRlcikge1xyXG4gICAgICAgIGNhc2UgJ2tleV96X3RvX2EnOlxyXG4gICAgICAgICAgdGhpcy5jb2xLZXlzLnNvcnQoXHJcbiAgICAgICAgICAgIHRoaXMuYXJyU29ydCh0aGlzLnByb3BzLmNvbHMsIHRoaXMuc3VidG90YWxzLmNvbFBhcnRpYWxPblRvcCwgdHJ1ZSksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndmFsdWVfYV90b196JzpcclxuICAgICAgICAgIHRoaXMuY29sS2V5cy5zb3J0KChhLCBiKSA9PiBuYXR1cmFsU29ydCh2KFtdLCBhKSwgdihbXSwgYikpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3ZhbHVlX3pfdG9fYSc6XHJcbiAgICAgICAgICB0aGlzLmNvbEtleXMuc29ydCgoYSwgYikgPT4gLW5hdHVyYWxTb3J0KHYoW10sIGEpLCB2KFtdLCBiKSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRoaXMuY29sS2V5cy5zb3J0KFxyXG4gICAgICAgICAgICB0aGlzLmFyclNvcnQodGhpcy5wcm9wcy5jb2xzLCB0aGlzLnN1YnRvdGFscy5jb2xQYXJ0aWFsT25Ub3ApLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0Q29sS2V5cygpIHtcclxuICAgIHRoaXMuc29ydEtleXMoKTtcclxuICAgIHJldHVybiB0aGlzLmNvbEtleXM7XHJcbiAgfVxyXG5cclxuICBnZXRSb3dLZXlzKCkge1xyXG4gICAgdGhpcy5zb3J0S2V5cygpO1xyXG4gICAgcmV0dXJuIHRoaXMucm93S2V5cztcclxuICB9XHJcblxyXG4gIHByb2Nlc3NSZWNvcmQocmVjb3JkKSB7XHJcbiAgICAvLyB0aGlzIGNvZGUgaXMgY2FsbGVkIGluIGEgdGlnaHQgbG9vcFxyXG4gICAgY29uc3QgY29sS2V5ID0gW107XHJcbiAgICBjb25zdCByb3dLZXkgPSBbXTtcclxuICAgIHRoaXMucHJvcHMuY29scy5mb3JFYWNoKGNvbCA9PiB7XHJcbiAgICAgIGNvbEtleS5wdXNoKGNvbCBpbiByZWNvcmQgPyByZWNvcmRbY29sXSA6ICdudWxsJyk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMucHJvcHMucm93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgIHJvd0tleS5wdXNoKHJvdyBpbiByZWNvcmQgPyByZWNvcmRbcm93XSA6ICdudWxsJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmFsbFRvdGFsLnB1c2gocmVjb3JkKTtcclxuXHJcbiAgICBjb25zdCByb3dTdGFydCA9IHRoaXMuc3VidG90YWxzLnJvd0VuYWJsZWQgPyAxIDogTWF0aC5tYXgoMSwgcm93S2V5Lmxlbmd0aCk7XHJcbiAgICBjb25zdCBjb2xTdGFydCA9IHRoaXMuc3VidG90YWxzLmNvbEVuYWJsZWQgPyAxIDogTWF0aC5tYXgoMSwgY29sS2V5Lmxlbmd0aCk7XHJcblxyXG4gICAgbGV0IGlzUm93U3VidG90YWw7XHJcbiAgICBsZXQgaXNDb2xTdWJ0b3RhbDtcclxuICAgIGZvciAobGV0IHJpID0gcm93U3RhcnQ7IHJpIDw9IHJvd0tleS5sZW5ndGg7IHJpICs9IDEpIHtcclxuICAgICAgaXNSb3dTdWJ0b3RhbCA9IHJpIDwgcm93S2V5Lmxlbmd0aDtcclxuICAgICAgY29uc3QgZlJvd0tleSA9IHJvd0tleS5zbGljZSgwLCByaSk7XHJcbiAgICAgIGNvbnN0IGZsYXRSb3dLZXkgPSBmbGF0S2V5KGZSb3dLZXkpO1xyXG4gICAgICBpZiAoIXRoaXMucm93VG90YWxzW2ZsYXRSb3dLZXldKSB7XHJcbiAgICAgICAgdGhpcy5yb3dLZXlzLnB1c2goZlJvd0tleSk7XHJcbiAgICAgICAgdGhpcy5yb3dUb3RhbHNbZmxhdFJvd0tleV0gPSB0aGlzLmdldEZvcm1hdHRlZEFnZ3JlZ2F0b3IoXHJcbiAgICAgICAgICByZWNvcmQsXHJcbiAgICAgICAgICByb3dLZXksXHJcbiAgICAgICAgKSh0aGlzLCBmUm93S2V5LCBbXSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5yb3dUb3RhbHNbZmxhdFJvd0tleV0ucHVzaChyZWNvcmQpO1xyXG4gICAgICB0aGlzLnJvd1RvdGFsc1tmbGF0Um93S2V5XS5pc1N1YnRvdGFsID0gaXNSb3dTdWJ0b3RhbDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBjaSA9IGNvbFN0YXJ0OyBjaSA8PSBjb2xLZXkubGVuZ3RoOyBjaSArPSAxKSB7XHJcbiAgICAgIGlzQ29sU3VidG90YWwgPSBjaSA8IGNvbEtleS5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IGZDb2xLZXkgPSBjb2xLZXkuc2xpY2UoMCwgY2kpO1xyXG4gICAgICBjb25zdCBmbGF0Q29sS2V5ID0gZmxhdEtleShmQ29sS2V5KTtcclxuICAgICAgaWYgKCF0aGlzLmNvbFRvdGFsc1tmbGF0Q29sS2V5XSkge1xyXG4gICAgICAgIHRoaXMuY29sS2V5cy5wdXNoKGZDb2xLZXkpO1xyXG4gICAgICAgIHRoaXMuY29sVG90YWxzW2ZsYXRDb2xLZXldID0gdGhpcy5nZXRGb3JtYXR0ZWRBZ2dyZWdhdG9yKFxyXG4gICAgICAgICAgcmVjb3JkLFxyXG4gICAgICAgICAgY29sS2V5LFxyXG4gICAgICAgICkodGhpcywgW10sIGZDb2xLZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY29sVG90YWxzW2ZsYXRDb2xLZXldLnB1c2gocmVjb3JkKTtcclxuICAgICAgdGhpcy5jb2xUb3RhbHNbZmxhdENvbEtleV0uaXNTdWJ0b3RhbCA9IGlzQ29sU3VidG90YWw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQW5kIG5vdyBmaWxsIGluIGZvciBhbGwgdGhlIHN1Yi1jZWxscy5cclxuICAgIGZvciAobGV0IHJpID0gcm93U3RhcnQ7IHJpIDw9IHJvd0tleS5sZW5ndGg7IHJpICs9IDEpIHtcclxuICAgICAgaXNSb3dTdWJ0b3RhbCA9IHJpIDwgcm93S2V5Lmxlbmd0aDtcclxuICAgICAgY29uc3QgZlJvd0tleSA9IHJvd0tleS5zbGljZSgwLCByaSk7XHJcbiAgICAgIGNvbnN0IGZsYXRSb3dLZXkgPSBmbGF0S2V5KGZSb3dLZXkpO1xyXG4gICAgICBpZiAoIXRoaXMudHJlZVtmbGF0Um93S2V5XSkge1xyXG4gICAgICAgIHRoaXMudHJlZVtmbGF0Um93S2V5XSA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobGV0IGNpID0gY29sU3RhcnQ7IGNpIDw9IGNvbEtleS5sZW5ndGg7IGNpICs9IDEpIHtcclxuICAgICAgICBpc0NvbFN1YnRvdGFsID0gY2kgPCBjb2xLZXkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGZDb2xLZXkgPSBjb2xLZXkuc2xpY2UoMCwgY2kpO1xyXG4gICAgICAgIGNvbnN0IGZsYXRDb2xLZXkgPSBmbGF0S2V5KGZDb2xLZXkpO1xyXG4gICAgICAgIGlmICghdGhpcy50cmVlW2ZsYXRSb3dLZXldW2ZsYXRDb2xLZXldKSB7XHJcbiAgICAgICAgICB0aGlzLnRyZWVbZmxhdFJvd0tleV1bZmxhdENvbEtleV0gPSB0aGlzLmdldEZvcm1hdHRlZEFnZ3JlZ2F0b3IoXHJcbiAgICAgICAgICAgIHJlY29yZCxcclxuICAgICAgICAgICkodGhpcywgZlJvd0tleSwgZkNvbEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJlZVtmbGF0Um93S2V5XVtmbGF0Q29sS2V5XS5wdXNoKHJlY29yZCk7XHJcblxyXG4gICAgICAgIHRoaXMudHJlZVtmbGF0Um93S2V5XVtmbGF0Q29sS2V5XS5pc1Jvd1N1YnRvdGFsID0gaXNSb3dTdWJ0b3RhbDtcclxuICAgICAgICB0aGlzLnRyZWVbZmxhdFJvd0tleV1bZmxhdENvbEtleV0uaXNDb2xTdWJ0b3RhbCA9IGlzQ29sU3VidG90YWw7XHJcbiAgICAgICAgdGhpcy50cmVlW2ZsYXRSb3dLZXldW2ZsYXRDb2xLZXldLmlzU3VidG90YWwgPVxyXG4gICAgICAgICAgaXNSb3dTdWJ0b3RhbCB8fCBpc0NvbFN1YnRvdGFsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRBZ2dyZWdhdG9yKHJvd0tleSwgY29sS2V5KSB7XHJcbiAgICBsZXQgYWdnO1xyXG4gICAgY29uc3QgZmxhdFJvd0tleSA9IGZsYXRLZXkocm93S2V5KTtcclxuICAgIGNvbnN0IGZsYXRDb2xLZXkgPSBmbGF0S2V5KGNvbEtleSk7XHJcbiAgICBpZiAocm93S2V5Lmxlbmd0aCA9PT0gMCAmJiBjb2xLZXkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGFnZyA9IHRoaXMuYWxsVG90YWw7XHJcbiAgICB9IGVsc2UgaWYgKHJvd0tleS5sZW5ndGggPT09IDApIHtcclxuICAgICAgYWdnID0gdGhpcy5jb2xUb3RhbHNbZmxhdENvbEtleV07XHJcbiAgICB9IGVsc2UgaWYgKGNvbEtleS5sZW5ndGggPT09IDApIHtcclxuICAgICAgYWdnID0gdGhpcy5yb3dUb3RhbHNbZmxhdFJvd0tleV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhZ2cgPSB0aGlzLnRyZWVbZmxhdFJvd0tleV1bZmxhdENvbEtleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBhZ2cgfHwge1xyXG4gICAgICAgIHZhbHVlKCkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXQoKSB7XHJcbiAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSxcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIGNhbiBoYW5kbGUgYXJyYXlzIG9yIGpRdWVyeSBzZWxlY3Rpb25zIG9mIHRhYmxlc1xyXG5QaXZvdERhdGEuZm9yRWFjaFJlY29yZCA9IGZ1bmN0aW9uIChpbnB1dCwgcHJvY2Vzc1JlY29yZCkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgLy8gYXJyYXkgb2Ygb2JqZWN0c1xyXG4gICAgcmV0dXJuIGlucHV0Lm1hcChyZWNvcmQgPT4gcHJvY2Vzc1JlY29yZChyZWNvcmQpKTtcclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKHQoJ1Vua25vd24gaW5wdXQgZm9ybWF0JykpO1xyXG59O1xyXG5cclxuUGl2b3REYXRhLmRlZmF1bHRQcm9wcyA9IHtcclxuICBhZ2dyZWdhdG9ycyxcclxuICBjb2xzOiBbXSxcclxuICByb3dzOiBbXSxcclxuICB2YWxzOiBbXSxcclxuICBhZ2dyZWdhdG9yTmFtZTogJ0NvdW50JyxcclxuICBzb3J0ZXJzOiB7fSxcclxuICByb3dPcmRlcjogJ2tleV9hX3RvX3onLFxyXG4gIGNvbE9yZGVyOiAna2V5X2FfdG9feicsXHJcbn07XHJcblxyXG5QaXZvdERhdGEucHJvcFR5cGVzID0ge1xyXG4gIGRhdGE6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKVxyXG4gICAgLmlzUmVxdWlyZWQsXHJcbiAgYWdncmVnYXRvck5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgY29sczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXHJcbiAgcm93czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXHJcbiAgdmFsczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXHJcbiAgdmFsdWVGaWx0ZXI6IFByb3BUeXBlcy5vYmplY3RPZihQcm9wVHlwZXMub2JqZWN0T2YoUHJvcFR5cGVzLmJvb2wpKSxcclxuICBzb3J0ZXJzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgIFByb3BUeXBlcy5mdW5jLFxyXG4gICAgUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5mdW5jKSxcclxuICBdKSxcclxuICBkZXJpdmVkQXR0cmlidXRlczogUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5mdW5jKSxcclxuICByb3dPcmRlcjogUHJvcFR5cGVzLm9uZU9mKFtcclxuICAgICdrZXlfYV90b196JyxcclxuICAgICdrZXlfel90b19hJyxcclxuICAgICd2YWx1ZV9hX3RvX3onLFxyXG4gICAgJ3ZhbHVlX3pfdG9fYScsXHJcbiAgXSksXHJcbiAgY29sT3JkZXI6IFByb3BUeXBlcy5vbmVPZihbXHJcbiAgICAna2V5X2FfdG9feicsXHJcbiAgICAna2V5X3pfdG9fYScsXHJcbiAgICAndmFsdWVfYV90b196JyxcclxuICAgICd2YWx1ZV96X3RvX2EnLFxyXG4gIF0pLFxyXG59O1xyXG5cclxuZXhwb3J0IHtcclxuICBhZ2dyZWdhdG9yVGVtcGxhdGVzLFxyXG4gIGFnZ3JlZ2F0b3JzLFxyXG4gIGRlcml2ZXJzLFxyXG4gIGxvY2FsZXMsXHJcbiAgbmF0dXJhbFNvcnQsXHJcbiAgbnVtYmVyRm9ybWF0LFxyXG4gIGdldFNvcnQsXHJcbiAgc29ydEFzLFxyXG4gIGZsYXRLZXksXHJcbiAgUGl2b3REYXRhLFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\n");

/***/ }),

/***/ "./plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx":
/*!******************************************************************!*\
  !*** ./plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PivotTableChart)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/includes */ \"./node_modules/@babel/runtime-corejs3/core-js-stable/instance/includes.js\");\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ant-design/icons */ \"./node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js\");\n/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ant-design/icons */ \"./node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/number-format/NumberFormatterRegistrySingleton.ts\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/query/getColumnLabel.ts\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/query/types/Column.ts\");\n/* harmony import */ var _react_pivottable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./react-pivottable */ \"./plugins/plugin-chart-pivot-table/src/react-pivottable/utilities.js\");\n/* harmony import */ var _react_pivottable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./react-pivottable */ \"./plugins/plugin-chart-pivot-table/src/react-pivottable/PivotTable.jsx\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types */ \"./plugins/plugin-chart-pivot-table/src/types.ts\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\nconst Styles = _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.styled.div`\n  ${(_ref) => {let { height, width, margin } = _ref;return `\n      margin: ${margin}px;\n      height: ${height - margin * 2}px;\n      width: ${typeof width === 'string' ? parseInt(width, 10) : width - margin * 2}px;\n `;}}\n`;\nconst PivotTableWrapper = _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.styled.div`\n  height: 100%;\n  max-width: fit-content;\n  overflow: auto;\n`;\nconst METRIC_KEY = 'metric';\nconst vals = ['value'];\nconst StyledPlusSquareOutlined = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(_ant_design_icons__WEBPACK_IMPORTED_MODULE_3__[\"default\"])`\n  stroke: ${(_ref2) => {let { theme } = _ref2;return theme.colors.grayscale.light2;}};\n  stroke-width: 16px;\n`;\nconst StyledMinusSquareOutlined = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__[\"default\"])`\n  stroke: ${(_ref3) => {let { theme } = _ref3;return theme.colors.grayscale.light2;}};\n  stroke-width: 16px;\n`;\nconst aggregatorsFactory = (formatter) => ({\n  Count: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.count(formatter),\n  'Count Unique Values': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.countUnique(formatter),\n  'List Unique Values': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.listUnique(', ', formatter),\n  Sum: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.sum(formatter),\n  Average: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.average(formatter),\n  Median: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.median(formatter),\n  'Sample Variance': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates[\"var\"](1, formatter),\n  'Sample Standard Deviation': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.stdev(1, formatter),\n  Minimum: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.min(formatter),\n  Maximum: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.max(formatter),\n  First: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.first(formatter),\n  Last: _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.last(formatter),\n  'Sum as Fraction of Total': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.fractionOf(_react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.sum(), 'total', formatter),\n  'Sum as Fraction of Rows': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.fractionOf(_react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.sum(), 'row', formatter),\n  'Sum as Fraction of Columns': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.fractionOf(_react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.sum(), 'col', formatter),\n  'Count as Fraction of Total': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.fractionOf(_react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.count(), 'total', formatter),\n  'Count as Fraction of Rows': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.fractionOf(_react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.count(), 'row', formatter),\n  'Count as Fraction of Columns': _react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.fractionOf(_react_pivottable__WEBPACK_IMPORTED_MODULE_5__.aggregatorTemplates.count(), 'col', formatter) });\n\n/* If you change this logic, please update the corresponding Python\n * function (https://github.com/apache/superset/blob/master/superset/charts/post_processing.py),\n * or reach out to @betodealmeida.\n */\nfunction PivotTableChart(props) {\n  const { data, height, width, groupbyRows: groupbyRowsRaw, groupbyColumns: groupbyColumnsRaw, metrics, colOrder, rowOrder, aggregateFunction, transposePivot, combineMetric, rowSubtotalPosition, colSubtotalPosition, colTotals, rowTotals, valueFormat, emitFilter, setDataMask, selectedFilters, verboseMap, columnFormats, metricsLayout, metricColorFormatters, dateFormatters, onContextMenu, timeGrainSqla } = props;\n  const theme = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  const defaultFormatter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.getNumberFormatter)(valueFormat), [valueFormat]);\n  const columnFormatsArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => Object.entries(columnFormats), [columnFormats]);\n  const hasCustomMetricFormatters = columnFormatsArray.length > 0;\n  const metricFormatters = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => hasCustomMetricFormatters ?\n  {\n    [METRIC_KEY]: Object.fromEntries(columnFormatsArray.map((_ref4) => {let [metric, format] = _ref4;return [\n      metric,\n      (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.getNumberFormatter)(format)];})) } :\n\n\n  undefined, [columnFormatsArray, hasCustomMetricFormatters]);\n  const metricNames = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => metrics.map((metric) => typeof metric === 'string' ? metric : metric.label), [metrics]);\n  const unpivotedData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => data.reduce((acc, record) => [\n  ...acc,\n  ...metricNames.\n  map((name) => ({\n    ...record,\n    [METRIC_KEY]: name,\n    value: record[name] })).\n\n  filter((record) => record.value !== null)],\n  []), [data, metricNames]);\n  const groupbyRows = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => groupbyRowsRaw.map(_superset_ui_core__WEBPACK_IMPORTED_MODULE_7__[\"default\"]), [groupbyRowsRaw]);\n  const groupbyColumns = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => groupbyColumnsRaw.map(_superset_ui_core__WEBPACK_IMPORTED_MODULE_7__[\"default\"]), [groupbyColumnsRaw]);\n  const sorters = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    [METRIC_KEY]: (0,_react_pivottable__WEBPACK_IMPORTED_MODULE_5__.sortAs)(metricNames) }),\n  [metricNames]);\n  const [rows, cols] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    let [rows_, cols_] = transposePivot ?\n    [groupbyColumns, groupbyRows] :\n    [groupbyRows, groupbyColumns];\n    if (metricsLayout === _types__WEBPACK_IMPORTED_MODULE_8__.MetricsLayoutEnum.ROWS) {\n      rows_ = combineMetric ? [...rows_, METRIC_KEY] : [METRIC_KEY, ...rows_];\n    } else\n    {\n      cols_ = combineMetric ? [...cols_, METRIC_KEY] : [METRIC_KEY, ...cols_];\n    }\n    return [rows_, cols_];\n  }, [\n  combineMetric,\n  groupbyColumns,\n  groupbyRows,\n  metricsLayout,\n  transposePivot]);\n\n  const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((filters) => {\n    const filterKeys = Object.keys(filters);\n    const groupby = [...groupbyRowsRaw, ...groupbyColumnsRaw];\n    setDataMask({\n      extraFormData: {\n        filters: filterKeys.length === 0 ?\n        undefined :\n        filterKeys.map((key) => {var _groupby$find;\n          const val = filters == null ? void 0 : filters[key];\n          const col = (_groupby$find = groupby.find((item) => {\n            if ((0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_9__.isPhysicalColumn)(item)) {\n              return item === key;\n            }\n            if ((0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_9__.isAdhocColumn)(item)) {\n              return item.label === key;\n            }\n            return false;\n          })) != null ? _groupby$find : '';\n          if (val === null || val === undefined)\n          return {\n            col,\n            op: 'IS NULL' };\n\n          return {\n            col,\n            op: 'IN',\n            val: val };\n\n        }) },\n\n      filterState: {\n        value: filters && Object.keys(filters).length ?\n        Object.values(filters) :\n        null,\n        selectedFilters: filters && Object.keys(filters).length ? filters : null } });\n\n\n  }, [groupbyColumnsRaw, groupbyRowsRaw, setDataMask]);\n  const toggleFilter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e, value, filters, pivotData, isSubtotal, isGrandTotal) => {\n    if (isSubtotal || isGrandTotal || !emitFilter) {\n      return;\n    }\n    const isActiveFilterValue = (key, val) => {var _selectedFilters$key;return !!selectedFilters && ((_selectedFilters$key = selectedFilters[key]) == null ? void 0 : _babel_runtime_corejs3_core_js_stable_instance_includes__WEBPACK_IMPORTED_MODULE_0___default()(_selectedFilters$key).call(_selectedFilters$key, val));};\n    const filtersCopy = { ...filters };\n    delete filtersCopy[METRIC_KEY];\n    const filtersEntries = Object.entries(filtersCopy);\n    if (filtersEntries.length === 0) {\n      return;\n    }\n    const [key, val] = filtersEntries[filtersEntries.length - 1];\n    let updatedFilters = { ...(selectedFilters || {}) };\n    // multi select\n    // if (selectedFilters && isActiveFilterValue(key, val)) {\n    //   updatedFilters[key] = selectedFilters[key].filter((x: DataRecordValue) => x !== val);\n    // } else {\n    //   updatedFilters[key] = [...(selectedFilters?.[key] || []), val];\n    // }\n    // single select\n    if (selectedFilters && isActiveFilterValue(key, val)) {\n      updatedFilters = {};\n    } else\n    {\n      updatedFilters = {\n        [key]: [val] };\n\n    }\n    if (Array.isArray(updatedFilters[key]) &&\n    updatedFilters[key].length === 0) {\n      delete updatedFilters[key];\n    }\n    handleChange(updatedFilters);\n  }, [emitFilter, selectedFilters, handleChange]);\n  const tableOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    clickRowHeaderCallback: toggleFilter,\n    clickColumnHeaderCallback: toggleFilter,\n    colTotals,\n    rowTotals,\n    highlightHeaderCellsOnHover: emitFilter,\n    highlightedHeaderCells: selectedFilters,\n    omittedHighlightHeaderGroups: [METRIC_KEY],\n    cellColorFormatters: { [METRIC_KEY]: metricColorFormatters },\n    dateFormatters }),\n  [\n  colTotals,\n  dateFormatters,\n  emitFilter,\n  metricColorFormatters,\n  rowTotals,\n  selectedFilters,\n  toggleFilter]);\n\n  const subtotalOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    colSubtotalDisplay: { displayOnTop: colSubtotalPosition },\n    rowSubtotalDisplay: { displayOnTop: rowSubtotalPosition },\n    arrowCollapsed: (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(StyledPlusSquareOutlined, null),\n    arrowExpanded: (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(StyledMinusSquareOutlined, null) }),\n  [colSubtotalPosition, rowSubtotalPosition]);\n  const handleContextMenu = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e, colKey, rowKey) => {\n    if (onContextMenu) {\n      e.preventDefault();\n      e.stopPropagation();\n      const filters = [];\n      if (colKey && colKey.length > 1) {\n        colKey.forEach((val, i) => {\n          const col = cols[i];\n          const formatter = dateFormatters[col];\n          const formattedVal = (formatter == null ? void 0 : formatter(val)) || String(val);\n          if (i > 0) {\n            filters.push({\n              col,\n              op: '==',\n              val,\n              formattedVal,\n              grain: formatter ? timeGrainSqla : undefined });\n\n          }\n        });\n      }\n      if (rowKey) {\n        rowKey.forEach((val, i) => {\n          const col = rows[i];\n          const formatter = dateFormatters[col];\n          const formattedVal = (formatter == null ? void 0 : formatter(val)) || String(val);\n          filters.push({\n            col,\n            op: '==',\n            val,\n            formattedVal,\n            grain: formatter ? timeGrainSqla : undefined });\n\n        });\n      }\n      onContextMenu(e.clientX, e.clientY, filters);\n    }\n  }, [cols, dateFormatters, onContextMenu, rows, timeGrainSqla]);\n  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(Styles, { height: height, width: width, margin: theme.gridUnit * 4 },\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(PivotTableWrapper, null,\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(_react_pivottable__WEBPACK_IMPORTED_MODULE_11__[\"default\"], { data: unpivotedData, rows: rows, cols: cols, aggregatorsFactory: aggregatorsFactory, defaultFormatter: defaultFormatter, customFormatters: metricFormatters, aggregatorName: aggregateFunction, vals: vals, colOrder: colOrder, rowOrder: rowOrder, sorters: sorters, tableOptions: tableOptions, subtotalOptions: subtotalOptions, namesMapping: verboseMap, onContextMenu: handleContextMenu })));\n\n\n}__signature__(PivotTableChart, \"useTheme{theme}\\nuseMemo{defaultFormatter}\\nuseMemo{columnFormatsArray}\\nuseMemo{metricFormatters}\\nuseMemo{metricNames}\\nuseMemo{unpivotedData}\\nuseMemo{groupbyRows}\\nuseMemo{groupbyColumns}\\nuseMemo{sorters}\\nuseMemo{[rows, cols]}\\nuseCallback{handleChange}\\nuseCallback{toggleFilter}\\nuseMemo{tableOptions}\\nuseMemo{subtotalOptions}\\nuseCallback{handleContextMenu}\", () => [_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.useTheme]);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Styles, \"Styles\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");reactHotLoader.register(PivotTableWrapper, \"PivotTableWrapper\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");reactHotLoader.register(METRIC_KEY, \"METRIC_KEY\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");reactHotLoader.register(vals, \"vals\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");reactHotLoader.register(StyledPlusSquareOutlined, \"StyledPlusSquareOutlined\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");reactHotLoader.register(StyledMinusSquareOutlined, \"StyledMinusSquareOutlined\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");reactHotLoader.register(aggregatorsFactory, \"aggregatorsFactory\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");reactHotLoader.register(PivotTableChart, \"PivotTableChart\", \"/app/superset-frontend/plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9zcmMvUGl2b3RUYWJsZUNoYXJ0LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSkE7QUFEQTtBQVVBOzs7O0FBQUE7QUFNQTtBQUNBO0FBRUE7QUFDQTs7QUFEQTtBQUtBO0FBQ0E7O0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTs7QUFPQTs7OztBQUlBO0FBQ0E7QUE2QkE7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBOzs7QUFJQTtBQUlBO0FBUUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUlBO0FBSUE7QUFLQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUlBO0FBSUE7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTs7O0FBb0JBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9zcmMvUGl2b3RUYWJsZUNoYXJ0LnRzeD83ZDMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUGx1c1NxdWFyZU91dGxpbmVkLCBNaW51c1NxdWFyZU91dGxpbmVkIH0gZnJvbSAnQGFudC1kZXNpZ24vaWNvbnMnO1xyXG5pbXBvcnQge1xyXG4gIEFkaG9jTWV0cmljLFxyXG4gIERhdGFSZWNvcmRWYWx1ZSxcclxuICBnZXRDb2x1bW5MYWJlbCxcclxuICBnZXROdW1iZXJGb3JtYXR0ZXIsXHJcbiAgaXNQaHlzaWNhbENvbHVtbixcclxuICBOdW1iZXJGb3JtYXR0ZXIsXHJcbiAgc3R5bGVkLFxyXG4gIHVzZVRoZW1lLFxyXG4gIGlzQWRob2NDb2x1bW4sXHJcbiAgQmluYXJ5UXVlcnlPYmplY3RGaWx0ZXJDbGF1c2UsXHJcbn0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xyXG5pbXBvcnQgeyBQaXZvdFRhYmxlLCBzb3J0QXMsIGFnZ3JlZ2F0b3JUZW1wbGF0ZXMgfSBmcm9tICcuL3JlYWN0LXBpdm90dGFibGUnO1xyXG5pbXBvcnQge1xyXG4gIEZpbHRlclR5cGUsXHJcbiAgTWV0cmljc0xheW91dEVudW0sXHJcbiAgUGl2b3RUYWJsZVByb3BzLFxyXG4gIFBpdm90VGFibGVTdHlsZXNQcm9wcyxcclxuICBTZWxlY3RlZEZpbHRlcnNUeXBlLFxyXG59IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuY29uc3QgU3R5bGVzID0gc3R5bGVkLmRpdjxQaXZvdFRhYmxlU3R5bGVzUHJvcHM+YFxyXG4gICR7KHsgaGVpZ2h0LCB3aWR0aCwgbWFyZ2luIH0pID0+IGBcclxuICAgICAgbWFyZ2luOiAke21hcmdpbn1weDtcclxuICAgICAgaGVpZ2h0OiAke2hlaWdodCAtIG1hcmdpbiAqIDJ9cHg7XHJcbiAgICAgIHdpZHRoOiAke1xyXG4gICAgICAgIHR5cGVvZiB3aWR0aCA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh3aWR0aCwgMTApIDogd2lkdGggLSBtYXJnaW4gKiAyXHJcbiAgICAgIH1weDtcclxuIGB9XHJcbmA7XHJcblxyXG5jb25zdCBQaXZvdFRhYmxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXHJcbiAgaGVpZ2h0OiAxMDAlO1xyXG4gIG1heC13aWR0aDogZml0LWNvbnRlbnQ7XHJcbiAgb3ZlcmZsb3c6IGF1dG87XHJcbmA7XHJcblxyXG5jb25zdCBNRVRSSUNfS0VZID0gJ21ldHJpYyc7XHJcbmNvbnN0IHZhbHMgPSBbJ3ZhbHVlJ107XHJcblxyXG5jb25zdCBTdHlsZWRQbHVzU3F1YXJlT3V0bGluZWQgPSBzdHlsZWQoUGx1c1NxdWFyZU91dGxpbmVkKWBcclxuICBzdHJva2U6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDJ9O1xyXG4gIHN0cm9rZS13aWR0aDogMTZweDtcclxuYDtcclxuXHJcbmNvbnN0IFN0eWxlZE1pbnVzU3F1YXJlT3V0bGluZWQgPSBzdHlsZWQoTWludXNTcXVhcmVPdXRsaW5lZClgXHJcbiAgc3Ryb2tlOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQyfTtcclxuICBzdHJva2Utd2lkdGg6IDE2cHg7XHJcbmA7XHJcblxyXG5jb25zdCBhZ2dyZWdhdG9yc0ZhY3RvcnkgPSAoZm9ybWF0dGVyOiBOdW1iZXJGb3JtYXR0ZXIpID0+ICh7XHJcbiAgQ291bnQ6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuY291bnQoZm9ybWF0dGVyKSxcclxuICAnQ291bnQgVW5pcXVlIFZhbHVlcyc6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuY291bnRVbmlxdWUoZm9ybWF0dGVyKSxcclxuICAnTGlzdCBVbmlxdWUgVmFsdWVzJzogYWdncmVnYXRvclRlbXBsYXRlcy5saXN0VW5pcXVlKCcsICcsIGZvcm1hdHRlciksXHJcbiAgU3VtOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLnN1bShmb3JtYXR0ZXIpLFxyXG4gIEF2ZXJhZ2U6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuYXZlcmFnZShmb3JtYXR0ZXIpLFxyXG4gIE1lZGlhbjogYWdncmVnYXRvclRlbXBsYXRlcy5tZWRpYW4oZm9ybWF0dGVyKSxcclxuICAnU2FtcGxlIFZhcmlhbmNlJzogYWdncmVnYXRvclRlbXBsYXRlcy52YXIoMSwgZm9ybWF0dGVyKSxcclxuICAnU2FtcGxlIFN0YW5kYXJkIERldmlhdGlvbic6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuc3RkZXYoMSwgZm9ybWF0dGVyKSxcclxuICBNaW5pbXVtOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLm1pbihmb3JtYXR0ZXIpLFxyXG4gIE1heGltdW06IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMubWF4KGZvcm1hdHRlciksXHJcbiAgRmlyc3Q6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuZmlyc3QoZm9ybWF0dGVyKSxcclxuICBMYXN0OiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmxhc3QoZm9ybWF0dGVyKSxcclxuICAnU3VtIGFzIEZyYWN0aW9uIG9mIFRvdGFsJzogYWdncmVnYXRvclRlbXBsYXRlcy5mcmFjdGlvbk9mKFxyXG4gICAgYWdncmVnYXRvclRlbXBsYXRlcy5zdW0oKSxcclxuICAgICd0b3RhbCcsXHJcbiAgICBmb3JtYXR0ZXIsXHJcbiAgKSxcclxuICAnU3VtIGFzIEZyYWN0aW9uIG9mIFJvd3MnOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmZyYWN0aW9uT2YoXHJcbiAgICBhZ2dyZWdhdG9yVGVtcGxhdGVzLnN1bSgpLFxyXG4gICAgJ3JvdycsXHJcbiAgICBmb3JtYXR0ZXIsXHJcbiAgKSxcclxuICAnU3VtIGFzIEZyYWN0aW9uIG9mIENvbHVtbnMnOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmZyYWN0aW9uT2YoXHJcbiAgICBhZ2dyZWdhdG9yVGVtcGxhdGVzLnN1bSgpLFxyXG4gICAgJ2NvbCcsXHJcbiAgICBmb3JtYXR0ZXIsXHJcbiAgKSxcclxuICAnQ291bnQgYXMgRnJhY3Rpb24gb2YgVG90YWwnOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmZyYWN0aW9uT2YoXHJcbiAgICBhZ2dyZWdhdG9yVGVtcGxhdGVzLmNvdW50KCksXHJcbiAgICAndG90YWwnLFxyXG4gICAgZm9ybWF0dGVyLFxyXG4gICksXHJcbiAgJ0NvdW50IGFzIEZyYWN0aW9uIG9mIFJvd3MnOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmZyYWN0aW9uT2YoXHJcbiAgICBhZ2dyZWdhdG9yVGVtcGxhdGVzLmNvdW50KCksXHJcbiAgICAncm93JyxcclxuICAgIGZvcm1hdHRlcixcclxuICApLFxyXG4gICdDb3VudCBhcyBGcmFjdGlvbiBvZiBDb2x1bW5zJzogYWdncmVnYXRvclRlbXBsYXRlcy5mcmFjdGlvbk9mKFxyXG4gICAgYWdncmVnYXRvclRlbXBsYXRlcy5jb3VudCgpLFxyXG4gICAgJ2NvbCcsXHJcbiAgICBmb3JtYXR0ZXIsXHJcbiAgKSxcclxufSk7XHJcblxyXG4vKiBJZiB5b3UgY2hhbmdlIHRoaXMgbG9naWMsIHBsZWFzZSB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgUHl0aG9uXHJcbiAqIGZ1bmN0aW9uIChodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL3N1cGVyc2V0L2Jsb2IvbWFzdGVyL3N1cGVyc2V0L2NoYXJ0cy9wb3N0X3Byb2Nlc3NpbmcucHkpLFxyXG4gKiBvciByZWFjaCBvdXQgdG8gQGJldG9kZWFsbWVpZGEuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQaXZvdFRhYmxlQ2hhcnQocHJvcHM6IFBpdm90VGFibGVQcm9wcykge1xyXG4gIGNvbnN0IHtcclxuICAgIGRhdGEsXHJcbiAgICBoZWlnaHQsXHJcbiAgICB3aWR0aCxcclxuICAgIGdyb3VwYnlSb3dzOiBncm91cGJ5Um93c1JhdyxcclxuICAgIGdyb3VwYnlDb2x1bW5zOiBncm91cGJ5Q29sdW1uc1JhdyxcclxuICAgIG1ldHJpY3MsXHJcbiAgICBjb2xPcmRlcixcclxuICAgIHJvd09yZGVyLFxyXG4gICAgYWdncmVnYXRlRnVuY3Rpb24sXHJcbiAgICB0cmFuc3Bvc2VQaXZvdCxcclxuICAgIGNvbWJpbmVNZXRyaWMsXHJcbiAgICByb3dTdWJ0b3RhbFBvc2l0aW9uLFxyXG4gICAgY29sU3VidG90YWxQb3NpdGlvbixcclxuICAgIGNvbFRvdGFscyxcclxuICAgIHJvd1RvdGFscyxcclxuICAgIHZhbHVlRm9ybWF0LFxyXG4gICAgZW1pdEZpbHRlcixcclxuICAgIHNldERhdGFNYXNrLFxyXG4gICAgc2VsZWN0ZWRGaWx0ZXJzLFxyXG4gICAgdmVyYm9zZU1hcCxcclxuICAgIGNvbHVtbkZvcm1hdHMsXHJcbiAgICBtZXRyaWNzTGF5b3V0LFxyXG4gICAgbWV0cmljQ29sb3JGb3JtYXR0ZXJzLFxyXG4gICAgZGF0ZUZvcm1hdHRlcnMsXHJcbiAgICBvbkNvbnRleHRNZW51LFxyXG4gICAgdGltZUdyYWluU3FsYSxcclxuICB9ID0gcHJvcHM7XHJcblxyXG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcclxuICBjb25zdCBkZWZhdWx0Rm9ybWF0dGVyID0gdXNlTWVtbyhcclxuICAgICgpID0+IGdldE51bWJlckZvcm1hdHRlcih2YWx1ZUZvcm1hdCksXHJcbiAgICBbdmFsdWVGb3JtYXRdLFxyXG4gICk7XHJcbiAgY29uc3QgY29sdW1uRm9ybWF0c0FycmF5ID0gdXNlTWVtbyhcclxuICAgICgpID0+IE9iamVjdC5lbnRyaWVzKGNvbHVtbkZvcm1hdHMpLFxyXG4gICAgW2NvbHVtbkZvcm1hdHNdLFxyXG4gICk7XHJcbiAgY29uc3QgaGFzQ3VzdG9tTWV0cmljRm9ybWF0dGVycyA9IGNvbHVtbkZvcm1hdHNBcnJheS5sZW5ndGggPiAwO1xyXG4gIGNvbnN0IG1ldHJpY0Zvcm1hdHRlcnMgPSB1c2VNZW1vKFxyXG4gICAgKCkgPT5cclxuICAgICAgaGFzQ3VzdG9tTWV0cmljRm9ybWF0dGVyc1xyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBbTUVUUklDX0tFWV06IE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgICAgICAgICBjb2x1bW5Gb3JtYXRzQXJyYXkubWFwKChbbWV0cmljLCBmb3JtYXRdKSA9PiBbXHJcbiAgICAgICAgICAgICAgICBtZXRyaWMsXHJcbiAgICAgICAgICAgICAgICBnZXROdW1iZXJGb3JtYXR0ZXIoZm9ybWF0KSxcclxuICAgICAgICAgICAgICBdKSxcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgIH1cclxuICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgIFtjb2x1bW5Gb3JtYXRzQXJyYXksIGhhc0N1c3RvbU1ldHJpY0Zvcm1hdHRlcnNdLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IG1ldHJpY05hbWVzID0gdXNlTWVtbyhcclxuICAgICgpID0+XHJcbiAgICAgIG1ldHJpY3MubWFwKChtZXRyaWM6IHN0cmluZyB8IEFkaG9jTWV0cmljKSA9PlxyXG4gICAgICAgIHR5cGVvZiBtZXRyaWMgPT09ICdzdHJpbmcnID8gbWV0cmljIDogKG1ldHJpYy5sYWJlbCBhcyBzdHJpbmcpLFxyXG4gICAgICApLFxyXG4gICAgW21ldHJpY3NdLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IHVucGl2b3RlZERhdGEgPSB1c2VNZW1vKFxyXG4gICAgKCkgPT5cclxuICAgICAgZGF0YS5yZWR1Y2UoXHJcbiAgICAgICAgKGFjYzogUmVjb3JkPHN0cmluZywgYW55PltdLCByZWNvcmQ6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFtcclxuICAgICAgICAgIC4uLmFjYyxcclxuICAgICAgICAgIC4uLm1ldHJpY05hbWVzXHJcbiAgICAgICAgICAgIC5tYXAoKG5hbWU6IHN0cmluZykgPT4gKHtcclxuICAgICAgICAgICAgICAuLi5yZWNvcmQsXHJcbiAgICAgICAgICAgICAgW01FVFJJQ19LRVldOiBuYW1lLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmRbbmFtZV0sXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAuZmlsdGVyKHJlY29yZCA9PiByZWNvcmQudmFsdWUgIT09IG51bGwpLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgW10sXHJcbiAgICAgICksXHJcbiAgICBbZGF0YSwgbWV0cmljTmFtZXNdLFxyXG4gICk7XHJcbiAgY29uc3QgZ3JvdXBieVJvd3MgPSB1c2VNZW1vKFxyXG4gICAgKCkgPT4gZ3JvdXBieVJvd3NSYXcubWFwKGdldENvbHVtbkxhYmVsKSxcclxuICAgIFtncm91cGJ5Um93c1Jhd10sXHJcbiAgKTtcclxuICBjb25zdCBncm91cGJ5Q29sdW1ucyA9IHVzZU1lbW8oXHJcbiAgICAoKSA9PiBncm91cGJ5Q29sdW1uc1Jhdy5tYXAoZ2V0Q29sdW1uTGFiZWwpLFxyXG4gICAgW2dyb3VwYnlDb2x1bW5zUmF3XSxcclxuICApO1xyXG5cclxuICBjb25zdCBzb3J0ZXJzID0gdXNlTWVtbyhcclxuICAgICgpID0+ICh7XHJcbiAgICAgIFtNRVRSSUNfS0VZXTogc29ydEFzKG1ldHJpY05hbWVzKSxcclxuICAgIH0pLFxyXG4gICAgW21ldHJpY05hbWVzXSxcclxuICApO1xyXG5cclxuICBjb25zdCBbcm93cywgY29sc10gPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGxldCBbcm93c18sIGNvbHNfXSA9IHRyYW5zcG9zZVBpdm90XHJcbiAgICAgID8gW2dyb3VwYnlDb2x1bW5zLCBncm91cGJ5Um93c11cclxuICAgICAgOiBbZ3JvdXBieVJvd3MsIGdyb3VwYnlDb2x1bW5zXTtcclxuXHJcbiAgICBpZiAobWV0cmljc0xheW91dCA9PT0gTWV0cmljc0xheW91dEVudW0uUk9XUykge1xyXG4gICAgICByb3dzXyA9IGNvbWJpbmVNZXRyaWMgPyBbLi4ucm93c18sIE1FVFJJQ19LRVldIDogW01FVFJJQ19LRVksIC4uLnJvd3NfXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbHNfID0gY29tYmluZU1ldHJpYyA/IFsuLi5jb2xzXywgTUVUUklDX0tFWV0gOiBbTUVUUklDX0tFWSwgLi4uY29sc19dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtyb3dzXywgY29sc19dO1xyXG4gIH0sIFtcclxuICAgIGNvbWJpbmVNZXRyaWMsXHJcbiAgICBncm91cGJ5Q29sdW1ucyxcclxuICAgIGdyb3VwYnlSb3dzLFxyXG4gICAgbWV0cmljc0xheW91dCxcclxuICAgIHRyYW5zcG9zZVBpdm90LFxyXG4gIF0pO1xyXG5cclxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcclxuICAgIChmaWx0ZXJzOiBTZWxlY3RlZEZpbHRlcnNUeXBlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGZpbHRlcktleXMgPSBPYmplY3Qua2V5cyhmaWx0ZXJzKTtcclxuICAgICAgY29uc3QgZ3JvdXBieSA9IFsuLi5ncm91cGJ5Um93c1JhdywgLi4uZ3JvdXBieUNvbHVtbnNSYXddO1xyXG4gICAgICBzZXREYXRhTWFzayh7XHJcbiAgICAgICAgZXh0cmFGb3JtRGF0YToge1xyXG4gICAgICAgICAgZmlsdGVyczpcclxuICAgICAgICAgICAgZmlsdGVyS2V5cy5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgIDogZmlsdGVyS2V5cy5tYXAoa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gZmlsdGVycz8uW2tleV07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBieS5maW5kKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGh5c2ljYWxDb2x1bW4oaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPT09IGtleTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FkaG9jQ29sdW1uKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsID09PSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkgPz8gJyc7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbCxcclxuICAgICAgICAgICAgICAgICAgICAgIG9wOiAnSVMgTlVMTCcsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJTicsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWwgYXMgKHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4pW10sXHJcbiAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbHRlclN0YXRlOiB7XHJcbiAgICAgICAgICB2YWx1ZTpcclxuICAgICAgICAgICAgZmlsdGVycyAmJiBPYmplY3Qua2V5cyhmaWx0ZXJzKS5sZW5ndGhcclxuICAgICAgICAgICAgICA/IE9iamVjdC52YWx1ZXMoZmlsdGVycylcclxuICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICBzZWxlY3RlZEZpbHRlcnM6XHJcbiAgICAgICAgICAgIGZpbHRlcnMgJiYgT2JqZWN0LmtleXMoZmlsdGVycykubGVuZ3RoID8gZmlsdGVycyA6IG51bGwsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgW2dyb3VwYnlDb2x1bW5zUmF3LCBncm91cGJ5Um93c1Jhdywgc2V0RGF0YU1hc2tdLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZUZpbHRlciA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKFxyXG4gICAgICBlOiBNb3VzZUV2ZW50LFxyXG4gICAgICB2YWx1ZTogc3RyaW5nLFxyXG4gICAgICBmaWx0ZXJzOiBGaWx0ZXJUeXBlLFxyXG4gICAgICBwaXZvdERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXHJcbiAgICAgIGlzU3VidG90YWw6IGJvb2xlYW4sXHJcbiAgICAgIGlzR3JhbmRUb3RhbDogYm9vbGVhbixcclxuICAgICkgPT4ge1xyXG4gICAgICBpZiAoaXNTdWJ0b3RhbCB8fCBpc0dyYW5kVG90YWwgfHwgIWVtaXRGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGlzQWN0aXZlRmlsdGVyVmFsdWUgPSAoa2V5OiBzdHJpbmcsIHZhbDogRGF0YVJlY29yZFZhbHVlKSA9PlxyXG4gICAgICAgICEhc2VsZWN0ZWRGaWx0ZXJzICYmIHNlbGVjdGVkRmlsdGVyc1trZXldPy5pbmNsdWRlcyh2YWwpO1xyXG5cclxuICAgICAgY29uc3QgZmlsdGVyc0NvcHkgPSB7IC4uLmZpbHRlcnMgfTtcclxuICAgICAgZGVsZXRlIGZpbHRlcnNDb3B5W01FVFJJQ19LRVldO1xyXG5cclxuICAgICAgY29uc3QgZmlsdGVyc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhmaWx0ZXJzQ29weSk7XHJcbiAgICAgIGlmIChmaWx0ZXJzRW50cmllcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IFtrZXksIHZhbF0gPSBmaWx0ZXJzRW50cmllc1tmaWx0ZXJzRW50cmllcy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgIGxldCB1cGRhdGVkRmlsdGVycyA9IHsgLi4uKHNlbGVjdGVkRmlsdGVycyB8fCB7fSkgfTtcclxuICAgICAgLy8gbXVsdGkgc2VsZWN0XHJcbiAgICAgIC8vIGlmIChzZWxlY3RlZEZpbHRlcnMgJiYgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbCkpIHtcclxuICAgICAgLy8gICB1cGRhdGVkRmlsdGVyc1trZXldID0gc2VsZWN0ZWRGaWx0ZXJzW2tleV0uZmlsdGVyKCh4OiBEYXRhUmVjb3JkVmFsdWUpID0+IHggIT09IHZhbCk7XHJcbiAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgIC8vICAgdXBkYXRlZEZpbHRlcnNba2V5XSA9IFsuLi4oc2VsZWN0ZWRGaWx0ZXJzPy5ba2V5XSB8fCBbXSksIHZhbF07XHJcbiAgICAgIC8vIH1cclxuICAgICAgLy8gc2luZ2xlIHNlbGVjdFxyXG4gICAgICBpZiAoc2VsZWN0ZWRGaWx0ZXJzICYmIGlzQWN0aXZlRmlsdGVyVmFsdWUoa2V5LCB2YWwpKSB7XHJcbiAgICAgICAgdXBkYXRlZEZpbHRlcnMgPSB7fTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1cGRhdGVkRmlsdGVycyA9IHtcclxuICAgICAgICAgIFtrZXldOiBbdmFsXSxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChcclxuICAgICAgICBBcnJheS5pc0FycmF5KHVwZGF0ZWRGaWx0ZXJzW2tleV0pICYmXHJcbiAgICAgICAgdXBkYXRlZEZpbHRlcnNba2V5XS5sZW5ndGggPT09IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRGaWx0ZXJzW2tleV07XHJcbiAgICAgIH1cclxuICAgICAgaGFuZGxlQ2hhbmdlKHVwZGF0ZWRGaWx0ZXJzKTtcclxuICAgIH0sXHJcbiAgICBbZW1pdEZpbHRlciwgc2VsZWN0ZWRGaWx0ZXJzLCBoYW5kbGVDaGFuZ2VdLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IHRhYmxlT3B0aW9ucyA9IHVzZU1lbW8oXHJcbiAgICAoKSA9PiAoe1xyXG4gICAgICBjbGlja1Jvd0hlYWRlckNhbGxiYWNrOiB0b2dnbGVGaWx0ZXIsXHJcbiAgICAgIGNsaWNrQ29sdW1uSGVhZGVyQ2FsbGJhY2s6IHRvZ2dsZUZpbHRlcixcclxuICAgICAgY29sVG90YWxzLFxyXG4gICAgICByb3dUb3RhbHMsXHJcbiAgICAgIGhpZ2hsaWdodEhlYWRlckNlbGxzT25Ib3ZlcjogZW1pdEZpbHRlcixcclxuICAgICAgaGlnaGxpZ2h0ZWRIZWFkZXJDZWxsczogc2VsZWN0ZWRGaWx0ZXJzLFxyXG4gICAgICBvbWl0dGVkSGlnaGxpZ2h0SGVhZGVyR3JvdXBzOiBbTUVUUklDX0tFWV0sXHJcbiAgICAgIGNlbGxDb2xvckZvcm1hdHRlcnM6IHsgW01FVFJJQ19LRVldOiBtZXRyaWNDb2xvckZvcm1hdHRlcnMgfSxcclxuICAgICAgZGF0ZUZvcm1hdHRlcnMsXHJcbiAgICB9KSxcclxuICAgIFtcclxuICAgICAgY29sVG90YWxzLFxyXG4gICAgICBkYXRlRm9ybWF0dGVycyxcclxuICAgICAgZW1pdEZpbHRlcixcclxuICAgICAgbWV0cmljQ29sb3JGb3JtYXR0ZXJzLFxyXG4gICAgICByb3dUb3RhbHMsXHJcbiAgICAgIHNlbGVjdGVkRmlsdGVycyxcclxuICAgICAgdG9nZ2xlRmlsdGVyLFxyXG4gICAgXSxcclxuICApO1xyXG5cclxuICBjb25zdCBzdWJ0b3RhbE9wdGlvbnMgPSB1c2VNZW1vKFxyXG4gICAgKCkgPT4gKHtcclxuICAgICAgY29sU3VidG90YWxEaXNwbGF5OiB7IGRpc3BsYXlPblRvcDogY29sU3VidG90YWxQb3NpdGlvbiB9LFxyXG4gICAgICByb3dTdWJ0b3RhbERpc3BsYXk6IHsgZGlzcGxheU9uVG9wOiByb3dTdWJ0b3RhbFBvc2l0aW9uIH0sXHJcbiAgICAgIGFycm93Q29sbGFwc2VkOiA8U3R5bGVkUGx1c1NxdWFyZU91dGxpbmVkIC8+LFxyXG4gICAgICBhcnJvd0V4cGFuZGVkOiA8U3R5bGVkTWludXNTcXVhcmVPdXRsaW5lZCAvPixcclxuICAgIH0pLFxyXG4gICAgW2NvbFN1YnRvdGFsUG9zaXRpb24sIHJvd1N1YnRvdGFsUG9zaXRpb25dLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZUNvbnRleHRNZW51ID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoXHJcbiAgICAgIGU6IE1vdXNlRXZlbnQsXHJcbiAgICAgIGNvbEtleTogKHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4pW10gfCB1bmRlZmluZWQsXHJcbiAgICAgIHJvd0tleTogKHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4pW10gfCB1bmRlZmluZWQsXHJcbiAgICApID0+IHtcclxuICAgICAgaWYgKG9uQ29udGV4dE1lbnUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXJzOiBCaW5hcnlRdWVyeU9iamVjdEZpbHRlckNsYXVzZVtdID0gW107XHJcbiAgICAgICAgaWYgKGNvbEtleSAmJiBjb2xLZXkubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgY29sS2V5LmZvckVhY2goKHZhbCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSBjb2xzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBkYXRlRm9ybWF0dGVyc1tjb2xdO1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRWYWwgPSBmb3JtYXR0ZXI/Lih2YWwgYXMgbnVtYmVyKSB8fCBTdHJpbmcodmFsKTtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGNvbCxcclxuICAgICAgICAgICAgICAgIG9wOiAnPT0nLFxyXG4gICAgICAgICAgICAgICAgdmFsLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsLFxyXG4gICAgICAgICAgICAgICAgZ3JhaW46IGZvcm1hdHRlciA/IHRpbWVHcmFpblNxbGEgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm93S2V5KSB7XHJcbiAgICAgICAgICByb3dLZXkuZm9yRWFjaCgodmFsLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHJvd3NbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGRhdGVGb3JtYXR0ZXJzW2NvbF07XHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbCA9IGZvcm1hdHRlcj8uKHZhbCBhcyBudW1iZXIpIHx8IFN0cmluZyh2YWwpO1xyXG4gICAgICAgICAgICBmaWx0ZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgIGNvbCxcclxuICAgICAgICAgICAgICBvcDogJz09JyxcclxuICAgICAgICAgICAgICB2YWwsXHJcbiAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsLFxyXG4gICAgICAgICAgICAgIGdyYWluOiBmb3JtYXR0ZXIgPyB0aW1lR3JhaW5TcWxhIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvbkNvbnRleHRNZW51KGUuY2xpZW50WCwgZS5jbGllbnRZLCBmaWx0ZXJzKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFtjb2xzLCBkYXRlRm9ybWF0dGVycywgb25Db250ZXh0TWVudSwgcm93cywgdGltZUdyYWluU3FsYV0sXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxTdHlsZXMgaGVpZ2h0PXtoZWlnaHR9IHdpZHRoPXt3aWR0aH0gbWFyZ2luPXt0aGVtZS5ncmlkVW5pdCAqIDR9PlxyXG4gICAgICA8UGl2b3RUYWJsZVdyYXBwZXI+XHJcbiAgICAgICAgPFBpdm90VGFibGVcclxuICAgICAgICAgIGRhdGE9e3VucGl2b3RlZERhdGF9XHJcbiAgICAgICAgICByb3dzPXtyb3dzfVxyXG4gICAgICAgICAgY29scz17Y29sc31cclxuICAgICAgICAgIGFnZ3JlZ2F0b3JzRmFjdG9yeT17YWdncmVnYXRvcnNGYWN0b3J5fVxyXG4gICAgICAgICAgZGVmYXVsdEZvcm1hdHRlcj17ZGVmYXVsdEZvcm1hdHRlcn1cclxuICAgICAgICAgIGN1c3RvbUZvcm1hdHRlcnM9e21ldHJpY0Zvcm1hdHRlcnN9XHJcbiAgICAgICAgICBhZ2dyZWdhdG9yTmFtZT17YWdncmVnYXRlRnVuY3Rpb259XHJcbiAgICAgICAgICB2YWxzPXt2YWxzfVxyXG4gICAgICAgICAgY29sT3JkZXI9e2NvbE9yZGVyfVxyXG4gICAgICAgICAgcm93T3JkZXI9e3Jvd09yZGVyfVxyXG4gICAgICAgICAgc29ydGVycz17c29ydGVyc31cclxuICAgICAgICAgIHRhYmxlT3B0aW9ucz17dGFibGVPcHRpb25zfVxyXG4gICAgICAgICAgc3VidG90YWxPcHRpb25zPXtzdWJ0b3RhbE9wdGlvbnN9XHJcbiAgICAgICAgICBuYW1lc01hcHBpbmc9e3ZlcmJvc2VNYXB9XHJcbiAgICAgICAgICBvbkNvbnRleHRNZW51PXtoYW5kbGVDb250ZXh0TWVudX1cclxuICAgICAgICAvPlxyXG4gICAgICA8L1Bpdm90VGFibGVXcmFwcGVyPlxyXG4gICAgPC9TdHlsZXM+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/plugin-chart-pivot-table/src/PivotTableChart.tsx\n");

/***/ })

}]);